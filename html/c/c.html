<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
	<title>C语言</title>
	<style>p{line-height:2em}</style>
</head>
<body>
	<p>#include "xxx.h" 或 &ltxxx.h>：头文件，编译预处理命令<br>其中 #include "xxx.h" 表示用户自定义的头文件；#include &ltxxx.h> 表示标准c库中的头文件<br>预编译又叫预处理。预编译不是编译，而是编译前的处理。这个操作是在正式编译之前由系统自动完成的。凡是以“#”开头的均为预处理指令。<br>
	#include 命令告诉预处理器将指定头文件的内容插入到预处理器命令的相应位置，从而把头文件和当前源文件连接成一个源文件，这与复制粘贴的效果相同<br>文件包括函数原型、宏定义和类型定义。<br>
	如：myproject.h（可避免头文件本重复包含从而报错） <br>
	#ifndef	__MYPROJECT_H <br>#define	__MYPROJECT_H<br>......<br>#endif<br>
	其他文件需要使用到此头文件时，如 myproject.c 里使用：<br>#include "myproject.h"<br>
	或其他不是同一目录下的文件使用：<br>#include "xx\xx\myproject.h"<br>
	或在myproje.c文件里面使用标准库 math.h：<br>#include &ltmath.h><br>
	</p>
	<hr><p>#define：宏定义，定义一个不变常量或函数另种使用或作为一个标识等。<br>定义的标识符不占内存，只是一个临时的符号，预编译后这个符号就不存在了。<br>
	用 #define 定义标识符的一般形式为：<br>#define  标识符  常量   //注意, 最后没有分号，常量可为数字、字符、字符串、表达式等<br>或
	#define 宏名(参数表) 字符串 //如表达式计算或判断等<br>或#define 字符串 //这里作为程序标识，可用于避免头文件重复包含或配合 #ifdef 字符串 条件编译使用<br>
	宏定义 #define 一般都写在函数外面，与 #include 写在一起。当然，写在函数里面也没有语法错误，但通常不那么写。<br>#define 的作用域为自 #define 那一行起到源程序结束。如果要终止其作用域可以使用 #undef 命令，格式为：<br>
	#undef  标识符<br>
	宏定义中的#和##的作用，如下：<br>#define A(X) T##X //##为连接符，将前后字符粘连起来，即TX<br>
	#define B(X) //#@会将宏参数进行格式化，并加上''号，即'X'<br>#define //#将参数格式化，并加上""号，即"X"<br>
	例如：<br>#define paster(n,b) printf("token " #n " and " #b " max is = %d\n",token##n > token##b ? token##n :token##b)<br>
	即#为格式化，#n就是n的n，#b就是b，token##n就是tokenn，也就相当于连接符。<br>
	define可以替代多行的代码，在每一个换行的时候加上一个反斜杠"\"<br>#define MAX(X,Y) do { \<br>语句1; \<br>语句2; \<br>/* 注释的写法 */ \<br>} while(0) /* (no trailing ; ) */ \<br>
	预定义宏：__LINE__（当前行数）、__FILE__（当前文件名称）、__FUNCTION__（当前函数名称）、__DATE__（编译日期）、__TIME__（编译时间）、__STDC__ （如果编译器接受标准C，那么值为1）
	</p>
	<hr><p>void：无类型。void 指针可以指向任意类型的数据。<br>当函数不需要返回值值时，必须使用void限定<br>当函数不允许接受参数时，必须使用void限定<br>
	在C语言中，凡不加返回值类型限定的函数，就会被编译器作为返回整型值处理。<br>如：hhh(char *da){return *da;} int main(void){printf("%d",hhh("1"))} 这里输出的是49（ascii中十进制49就是数字'1'）<br>
	</p>
	<p>int：整型，4字节，取整范围：16位-2^15~2^15-1；32位-2^31~2^31-1。<br>unsiged int取值范围：16位0-2^16；32位0-2^32。</p>
	<p>char：字符型，1字节。取值范围：-128~127。unsiged char取值范围：0~255。</p>
	<p>float：单精度浮点型，4字节。取值范围：-3.4E+38~3.4E+38[-2^128~2^128]</p>
	<p>double：双精度浮点型，8字节。取值范围：-1.79E+308 ~ +1.79E+308[-2^1024 ~ +2^1024]</p>
	<p>bool：布尔类，只有真假两种结果，true为1，false为0。</p>
	<p>注释：//或/**/，前面一个为当行注释，后面一个为多行注释，只要在/*和*/的内部则都是注释部分</p>
	<p>sizeof：关键字是，一个单目运算符，它的参数可以是数组、指针、类型、对象、函数等。包括结束字符（即 null 字符）</p>
	<hr><p>运算符：+ - * / % ^ == != > < >= <= && || ! & | ~ ++ -- = >> << <br>
	<table border="1" cellpadding="0" cellspacing="0">
	<tr>
		<td width="4%" class="btbg font-center">优先级</td>
		<td width="8%" class="btbg font-center">运算符</td>
		<td width="8%" class="btbg font-center">名称或含义</td>
		<td width="8%" class="btbg font-center">使用形式</td>
		<td width="8%" class="btbg font-center">结合方向</td>
		<td width="8%" class="btbg font-center">说明</td>
	</tr>
	<tr>
		<td width="4%" class="btbg font-center">1</td>
		<td width="8%" class="btbg font-center">[]</td>
		<td width="8%" class="btbg font-center">数组下标</td>
		<td width="8%" class="btbg font-center">数组名[常量表达式]</td>
		<td width="8%" class="btbg font-center">左到右</td>
		<td width="8%" class="btbg font-center"></td>
	</tr>
	<tr>
		<td width="4%" class="btbg font-center">1</td>
		<td width="8%" class="btbg font-center">()</td>
		<td width="8%" class="btbg font-center">圆括号</td>
		<td width="8%" class="btbg font-center">（表达式）/函数名(形参表)</td>
		<td width="8%" class="btbg font-center">左到右</td>
		<td width="8%" class="btbg font-center"></td>
	</tr>
	<tr>
		<td width="4%" class="btbg font-center">1</td>
		<td width="8%" class="btbg font-center">.</td>
		<td width="8%" class="btbg font-center">成员选择（对象）</td>
		<td width="8%" class="btbg font-center">对象.成员名</td>
		<td width="8%" class="btbg font-center">左到右</td>
		<td width="8%" class="btbg font-center"></td>
	</tr>
	<tr>
		<td width="4%" class="btbg font-center">1</td>
		<td width="8%" class="btbg font-center">-></td>
		<td width="8%" class="btbg font-center">成员选择（指针）</td>
		<td width="8%" class="btbg font-center">对象指针->成员名</td>
		<td width="8%" class="btbg font-center">左到右</td>
		<td width="8%" class="btbg font-center"></td>
	</tr>
	<tr>
		<td width="4%" class="btbg font-center">1</td>
		<td width="8%" class="btbg font-center">++</td>
		<td width="8%" class="btbg font-center">后置自增运算符</td>
		<td width="8%" class="btbg font-center">++变量名</td>
		<td width="8%" class="btbg font-center">左到右</td>
		<td width="8%" class="btbg font-center">单目运算符</td>
	</tr>
	<tr>
		<td width="4%" class="btbg font-center">1</td>
		<td width="8%" class="btbg font-center">--</td>
		<td width="8%" class="btbg font-center">后置自减运算符</td>
		<td width="8%" class="btbg font-center">--变量名</td>
		<td width="8%" class="btbg font-center">左到右</td>
		<td width="8%" class="btbg font-center">单目运算符</td>
	</tr>
	<tr>
		<td width="4%" class="btbg font-center">2</td>
		<td width="8%" class="btbg font-center">-</td>
		<td width="8%" class="btbg font-center">负号运算符</td>
		<td width="8%" class="btbg font-center">-表达式</td>
		<td width="8%" class="btbg font-center">右到左</td>
		<td width="8%" class="btbg font-center">单目运算符</td>
	</tr>
	</table>






(类型)
强制类型转换
(数据类型)表达式
++
前置自增运算符
变量名++
单目运算符
--
前置自减运算符
变量名--
单目运算符
*
取值运算符
*指针变量
单目运算符
&
取地址运算符
&变量名
单目运算符
!
逻辑非运算符
!表达式
单目运算符
~
按位取反运算符
~表达式
单目运算符
sizeof
长度运算符
sizeof(表达式)
3
/
除
表达式/表达式
左到右
双目运算符
*
乘
表达式*表达式
双目运算符
%
余数（取模）
整型表达式/整型表达式
双目运算符
4
+
加
表达式+表达式
左到右
双目运算符
-
减
表达式-表达式
双目运算符
5
<<
左移
变量<<表达式
左到右
双目运算符
>>
右移
变量>>表达式
双目运算符
6
>
大于
表达式>表达式
左到右
双目运算符
>=
大于等于
表达式>=表达式
双目运算符
<
小于
表达式<表达式
双目运算符
<=
小于等于
表达式<=表达式
双目运算符
7
==
等于
表达式==表达式
左到右
双目运算符
!=
不等于
表达式!= 表达式
双目运算符
8
&
按位与
表达式&表达式
左到右
双目运算符
9
^
按位异或
表达式^表达式
左到右
双目运算符
10
|
按位或
表达式|表达式
左到右
双目运算符
11
&&
逻辑与
表达式&&表达式
左到右
双目运算符
12
||
逻辑或
表达式||表达式
左到右
双目运算符
13
?:
条件运算符
表达式1? 表达式2: 表达式3
右到左
三目运算符
14
=
赋值运算符
变量=表达式
右到左
/=
除后赋值
变量/=表达式
*=
乘后赋值
变量*=表达式
%=
取模后赋值
变量%=表达式
+=
加后赋值
变量+=表达式
-=
减后赋值
变量-=表达式
<<=
左移后赋值
变量<<=表达式
>>=
右移后赋值
变量>>=表达式
&=
按位与后赋值
变量&=表达式
^=
按位异或后赋值
变量^=表达式
|=
按位或后赋值
变量|=表达式
15
,
逗号运算符
表达式,表达式,…
左到右
从左向右顺序运算</p>
	<hr><p>static：局部变量或函数，只作用在当前文件或函数</p>
	<hr><p>volatile：关键字，确保本条质量不会因为编译器的优化而省略</p>
	<hr><p>inline：内联</p>
	<hr><p>enum：枚举</p>
	<hr><p>extern</p>
	<hr><p>return</p>
	<hr><p>const：</p>
	<hr><p>break：</p>
	<hr><p>continue：</p>	
	
	<hr><p>sprintf(x,xxx)：格式化输入到x里面</p>
	<hr><p>sscanf：取格式化的字符串中的数据</p>
	<hr><p>#if x ... #elif x ... #endif</p>
	<hr><p>if(xxx){...}else if(xxx){...}else{...}：条件判断语句，若if的xxx为true则执行if内语句，否则判断else if是否成立，满足则执行else if内语句，都不满足则执行else内语句</p>
	<hr><p>ifndef xx ... #else ... #endif，在每个头文件中加入#ifndef	__XX_H	#define	__XX_H	... #endif可避免头文件被重复包含。</p>
	<hr><p>ifdef x ... #else ... #endif</p>
	<hr><p>switch(xx){case x:xxx;break;case y:xxx;default:xxx}：switch中的xx作为判断条件，判断case里面是否有符合xx的结果，有则跳到对应case处执行语句，都没有则执行default处语句。break为结束之后的语句，若没有break则会一直执行到default。</p>
	<hr><p>for(xx;yy;zz){}：循环语句，若设置成for(;;)则是一个死循环</p>
	<hr><p>while(){xx}：循环语句，若设置成while(1){}则为死循环</p>

	<hr><p>函数：</p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<hr><p>typedef</p>
	<hr><p>struct：结构体。struct xxx{};而加入typedef则为另命名，typedef struct{}xxx;<br>两者区别：1.struct定义结构体变量时需要写成:struct xxx y; 2.typedef可写成：xxx y;
	<hr><br>可在函数前加struct，如 struct netif *getGprsNetIf(xx)目前暂不知道作用是什么</p>
	<hr><p>数组：</p>
	<hr><p>指针：</p>
	<hr><p>链表</p>



	<hr><p>标准库函数：</p>
	<p>&ltstring.h></p>
	<p>void *memmove(void *dest, const void *src, unsigned int count)：拷贝</p>
	<p>void *memcpy(void *destin, void *source, unsigned n)：拷贝</p>
	<p>void *memset(void *str, int c, size_t n)：将某一块内存中的内容全部设置为指定的值</p>
	<p>strlen：是一个函数，它用来计算指定字符串 str 的长度，但不包括结束字符（即 null 字符）</p>
	<p>char *strchr(const char *str, int c)：即在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。返回在字符串 str 中第一次出现字符 c 的位置，如果未找到该字符则返回 NULL。</p>
	<p>char *strstr(const char *haystack, const char *needle)：判断字符串str2是否是str1的子串。如果是，则该函数返回 str1字符串从 str2第一次出现的位置开始到 str1结尾的字符串；否则，返回NULL。</p>
	<p>char *strcpy(char *dest, const char *src)：把从src地址开始且含有’\0’结束符的字符串复制到以dest开始的地址空间</p>
	<p>int strcmp(const char* stri1,const char* str2)：比较两个字符串并根据比较结果返回整数，返回0为两字符串相等</p>
	<p>int strncmp ( const char * str1, const char * str2, size_t n )：比较两字符串前n字符</p>
	<p>char *strtok(char *str, const char *delim)：分解字符串为一组字符串。s为要分解的字符串，delim为分隔符字符</p>
	<p>char *strncpy(char *dest, const char *src, int n)：将指定长度的字符串复制到字符数组中</p>
	<p>char *strcat(char *dest, const char *src)：把src所指向的字符串追加到dest所指向的字符串的结尾，所以必须要保证dest有足够的内存空间来容纳两个字符串，否则会导致溢出错误。</p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	
	
	
	<hr><p>stdio.h</p>
	<p>printf(xxx)：格式化输出打印。</p>
	<p>scanf()</p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	
	
	<hr><p>&ltctype.h></p>
	<p></p>
	<p>int isalpha(int c)：判断字符ch是否为英文字母，若为英文字母，返回非0（小写字母为2，大写字母为1）。若不是字母，返回0。</p>
	<p>int isupper(int c)：判断一个字符是否为大写字母</p>
	<p>int islower(int c)：判断一个字符是否为小写字母</p>
	<p>int isdigit(int c)：检查所传的字符是否是十进制数字字符。即阿拉伯数字0-9。</p>
	<p>int isxdigit(int c)：检查所传的字符是否是十六进制数字，即0-9、a-f、A-F。</p>
	<p>int isspace(int c)：判断一个字符是否是空白符。即空格""，定位符"\t"或"\r"或"\n"，垂直符"\v"或"\f"。</p>
	<p>int ispunct(int c)：检查所传的字符是否是标点符号字符。非空格、数字和英文字母的。</p>
	<p>void isalnum(int c)：检查所传的字符是否是字母和数字。</p>
	<p>int isprint(int c)：检查所传的字符是否是可打印的。可打印字符是非控制字符的字符。</p>
	<p>int isgraph (int c) 函数说明 检查参数c是否为可打印字符</p>
	<p>void iscntrl(int c) 检查所传的字符是否是控制字符。0-30之间</p>
	<p>int isascii(int c)：函数说明检查参数 c 是否为ASCII 码字符，即0-127之间</p>
	<p>int toascii(int ch); 功能: 把一个字符转换为ASCII</p>
	<p>int toupper(int c) 把小写字母转换为大写字母。</p>
	<p>int tolower(int c) 把给定的字母转换为小写字母。</p>
	<p>int isblank(int c)：函数说明：检查参数c是否为空白字符，也就是判断是否为空白（space，ascii为32）或是制表符（tab，ascii为9）。</p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	
	
	
	<hr><p>&ltstdlib.h></p>
	<p>void *malloc(size_t size){}：动态内存分配。分配所需的内存空间,并返回一个指向它的指针</p>
	<p>void free(void *ptr)：释放动态内存</p>	
	<p>int atoi(const char *str)：将字符串转换为整形数</p>
	<p>double atof(const char *nptr)：把字符串转换成浮点数</p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	
	
	
	

	<hr><p>&lttime.h></p>
	<p>struct tm *gmtime(const time_t *timer)：把日期和时间转换为格林威治(GMT)时间的函数。</p>
	</p>size_t strftime (char* ptr, size_t maxsize, const char* format,const struct tm* timeptr )：格式化显示当前事件，如：strftime(s,sizeof(s),"%Y-%m-%d %H:%M:%S",gmtime(time_t c))，其中Y为年，m为月，d为日，H为时，M为分，S为秒</p>




	<hr><p>linux下<arpa/inet.h> 和windows下<winsock.h> </p>
	<p>uint32_t htonl(uint32_t hostlong)：将主机的无符号长整形数转换成网络字节顺序。如 s_addr = htonl(((u32_t)0x00000000UL));</p>
	<p>uint16_t htons(uint16_t hostshort)：将主机的无符号短整形数转换成网络字节顺序。如 port = htons(10000);</p>
	<p>uint32_t ntohl(uint32_t netlong)：将一个无符号长整形数从网络字节顺序转换为主机字节顺序。   </p>
	<p>uint16_t ntohs(uint16_t netshort)：将一个无符号短整形数从网络字节顺序转换为主机字节顺序。  </p>
	<p>in_addr_t inet_addr(const char* strptr)：将一个点间隔地址转换成一个in_addr。如 l1= inet_addr("192.168.0.74");</p>
	<p>char *inet_ntoa (struct in_addr)：将网络地址转换成“.”点隔的字符串格式。</p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	
	
	
</body>
</html>
