<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
	<link rel="shortcut icon" href="../../../picture/favicon.ico" type="image/x-icon">
	<title>C++</title>
	<link rel="stylesheet" type="text/css" href="../../../home/all.css" >
	<style>
		.main_body a{text-decoration:none}
		.main_body p{line-height:25px;}
	</style>
</head>
<body>
	<div class="menu_body">
		<a href="../../../home.html">首页</a>
		<a href="../../study.html">学习</a>
		<a href="../../../工具/tools.html">工具</a>
		<a href="../../../阅读/read.html">阅读</a>
		<a href="../../../娱乐/play.html">娱乐</a>
	</div>
	<div class="left_body">
		<ul>
			<li><a href="../c/c.html">c</a></li>
			<li><a href="./c++.html">c++</a></li>
			<li><a href="../css/css.html">css</a></li>
			<li><a href="../html/html.html">html</a></li>
			<li><a href="../协议/http/http.html">http</a></li>
			<li><a href="../java/java.html">java</a></li>
			<li><a href="../javascript/javascript.html">javascript</a></li>
			<li><a href="../python/python.html">python</a></li>
			<li><a href="../sql/sql.html">Sql</a></li>
			<li><a href="../php/php.html">php</a></li>
			<li><a href="../photoshop/photoshop.html">PS</a></li>
			<li><a href="../cad/cad.html">CAD</a></li>
			<li><a href="../硬件/硬件.html">硬件</a></li>
			<li><a href="../语言/语言.html">语言</a></li>
			<li><a href="../系统/系统.html">系统</a></li>
		</ul>
	</div>
	<div class="table_body">
		<a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br>
		<a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br>
		<a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br>
		<a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br>
		<a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br>
		<a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br>
	</div>
	<div class="main_body">
		<div>
			<h3>简介</h3>
			<p>C++ 是 C 的扩展，向下兼容 C，也就是，C 编写的程序可完全直接在 C++ 上运行<br/>C++ 是面向对象的程序语言，面向对象的三要素为封装、继承、多态<br/>
				封装：将数据和处理数据的方法封装在一起成为一个类，类的实体是对象，对象一旦定义就可看出一个完全封装的实体，使用类，使类的成员外部不可见，但是可以提供接口供外部设置或读取<br/>
				继承：一个始位保留了另一种始位的全部特征并具有自身独有的特征。子类从父类（基类）中继承内部成员与成员函数，新类型从现有类型中派生出来的称为派生类<br/>
				多态：多种事物继承同一事物时，同一种操作在它们之间表现不同的行为</p>
			<p>基本字符：字母（大小写 a-z ）、数字（0-9）、特殊符号（+ - * / = , . _ : ; ? \ " ' ~ | ! # % & ( ) [ ] { } ^ < > 空格）</p>
			<p>标识符：字母、数字、下划线组成，其中数字不能作为开头，不能和关键字同名，区分大小写，有一定长度（一般有效长度 32 字节，超出将被截断）</p>
			<p>常量：整个程序运行过程中不可变的值，符号常量和文字常量，如 PI 3.14157 这里 PI 符号常量（标识符），3.14157 文字常量（值）</p>
			<p>变量：整个程序运行过程中会被改动，未初始化的变量是全局变量则默认为 0，局部变量则是随机的值</p>
			<p>语句：标号语句、表达式语句、复合语句、选择语句、循环语句、跳转语句、声明语句等。<br/>
				声明语句：对变量名、函数原型、类名、对象名进行声明的语句。<br/>
				表达式语句：在表达式末尾添加一个分号就构成了表达式语句，如 a=a+3;<br/>
				复合语句：执行两条或两条以上的语句序列，这时使用复合语句来替代单条语句，复合语句由花括号括起来。</p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3>关键字</h3>
			<table border="1">
				<tr><td>auto</td><td>bool</td><td>break</td><td>case</td><td>catch</td><td>char</td><td>class</td></tr>
				<tr><td>const</td><td>const_cast</td><td>continue</td><td>default</td><td>delete</td><td>do</td><td>double</td><td></td></tr>
				<tr><td>dynamic_cast</td><td>else</td><td>enum</td><td>explicit</td><td>extern</td><td>false</td><td>float</td></tr>
				<tr><td>for</td><td>friend</td><td>goto</td><td>if</td><td>inline</td><td>int</td><td>long</td></tr>
				<tr><td>mutable</td><td>namespace</td><td>new</td><td>operator</td><td>private</td><td>protected</td><td>public</td></tr>
				<tr><td>register</td><td>reinterpret_cast</td><td>return</td><td>short</td><td>signed</td><td>sizeof</td><td>static</td></tr>
				<tr><td>static_cast</td><td>struct</td><td>switch</td><td>template</td><td>this</td><td>throw</td><td>true</td></tr>
				<tr><td>try</td><td>typedef</td><td>typeid</td><td>typename</td><td>union</td><td>unsigned</td><td>using</td></tr>
				<tr><td>virtual</td><td>void</td><td>volatile</td><td>while</td><td></td><td></td><td></td></tr>
			</table>
			<p></p>
			</div><hr/>
		<div>
			<h3>数据类型</h3>
			<p>整型：int、short int（int 可省略）、long int（int 可省略）、signed（可省略）、unsign、char（字符也可作为整型）<br/>
				整型形式：十进制（0-9）、八进制（0-7,0 开头）、十六进制（0-9、A-F，0x 开头）、长整型可用后缀 L/l，无符号可用 U/u<br/>
				整型最值：在 climits.h 头文件中一系列宏定义表示，如 SHRT_MIN/MAX 短整型最大小值、INT_MIN/MAX 整型最大小值、LONG_MIN/MAX 长整型最大小值、USHRT_MAX 无符号短整型最大值、UINT_MAX 无符号整型最大值、ULONG_MAX 无符号长整型</p>
			<p>浮点型：float（单精度）、double（双精度）、long double（扩展精度）<br/>
				一般形式：12.5、-12.5<br/>指数形式：12.5E+3（12.5 * 10的三次方）、.123e-1（0.123 * 10的负一次方）、12.e-3（12.0 * 10的负三次方）<br/>
				注意：浮点文字量之间不能出现空格<br/>
				默认 double，若需要为 float 则需加后缀 F/f，long double 需加后缀 L/l</p>
			<p>字符型：一个字符使用单引号括起来<br/>
				转义字符：\n（换行符）、\t（水平制表符）、\v（垂直制表符）、\b（退格符）、\r（回车键）、\f（换页符）、\a（响铃符）、\\（反斜杠）、\?（问号）、\'（单引号）、\"（双引号）、一般的转义序列（\xx，xx 表示八进制序列，如 \7 响铃符、\14 换行符、\0 空、\062 即 '2'）<br/>
				以数组存放 C 风格的字符串，如 char str[]="hello!";<br/>
				string 类型字符串：需要引用 string.h 头文件，可使用处理方式由字符串的复制、拼接、比较、查找、插入、求子串、求串长度等</p>
			<p>字符串型：c 语言的字符串类型和 c++ 的 String 类，在 c++ 中基本数据类型中没有字符串型的变量，只有 c 的字符串常量，但可以用数组存放字符串。<br/>
				字符串赋值最后会加一个'\0'作为结束符</p>
			<p>布尔型：bool，只有 true 和 false 两个值，常用于关系、相等的比较或逻辑运算的结果</p>
			<p>引用类型：主要作为函数的参数使用，可实现参数的双向传递，从语法上看就是一个变量的别名<br/>
				引用必须在声明的时候进行初始化，一经初始化就不能改变（指的是引用关系不可变，也就是在程序运行过程中一个引用只能始终作为同一变量的别名，当然可以通过引用改变它代表的变量），比如<br/>
				int a=10; int &b=a;//这里就是用 a 初始化了引用 b，这样 b 就成为变量 a 的别名，也就是引用 b 和变量名 a 的变量地址是一样的<br/>
				这时 b 和 a 相等（值），&b 和 &a 相等（地址）。<br/>
				用引用作为函数的参数可以实现形参和实参相结合，使形参成为实参变量的引用。这样在被调函数中就可以通过引用访问主调函数中的实参变量，如：<br/>
				void swap(int &a,int &b){int t; t=a;a=b;b=t;}<br/>
				int main{int x(5),y(10);swap(x,y);return 0;}<br/>
				在我看来这和常规的函数没有什么区别。指针也可以实现传值。</p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3>运算</h3>
			<p>算术运算：++（前后置的自增）、--（前后置的自减）、+、-、*、/、%。<br/>
				&nbsp;优先级为：（后置-- 和后置++）&gt;（前置-- 和前置++）&gt;（* / %）&gt; （+ -）</p>
			<p>赋值运算：符号 =，将其右边的表达式值赋给左边的对象。<br/>
				&nbsp;复合赋值运算符：*=、/=、%=、+=、-=、&gt;&gt;=、&lt;&lt=、&=、^=、|=。优先级高于逗号运算符低于其他运算符。</p>
			<p>逗号运算符：逗号表达式是一系列由逗号分开的表达式，从左到右计算，逗号表达式的结果是最右边表达式的值。如：<br/>
				&nbsp;bool a = true;<br/>&nbsp;int b, c;<br/>&nbsp;a ? b=1, c=b : c=2, b=b;<br/>&nbsp;结果是 a=true，b=1，c=1</p>
			<p>关系运算符：用于比较数据大小关系，返回 true 或 false，关系运算符优先级相同，运算次序自左向右，运算符有： &lt;、&lt;=、&gt;、&gt;=、==、!=</p>
			<p>逻辑运算符：将多个关系表达式和相等表达式组合起来构成复杂的逻辑判断，优先级为 逻辑非(!) &gt; && 和 ||</p>
			<p>sizeof 运算：返回一个对象或类型的字节长度，有三种形式：sizeof(类型名称)、sizeof(表达式)、sizeof(对象)。<br/>
				&nbsp;如：sizeof(short)</p>
			<p>位运算：按位非(~ ，0 和 1 的翻转)，左移(&lt;&lt;)、右移(&gt;&gt;)、按位与(&)、按位异或(^)、按位或(|)、</p>
			<p>类型转换：隐式转换和显示转换，其中隐式转换包括混合算术运算、将值赋给另一类型的变量、函数参数传递、函数返回返回值<br/>
				混合算术运算是将低精度转换高精度类型，从低到高 char->short->int>unsigned int->long->unsigned long->float->double<br/>
				显示转换时一种强制转换，如 类型说明符(表达式) 或 (类型说明符)表达式，前面是 c++ 强制转换方式，后面是 c 转换方式</p>
			<p></p>
			<p>运算符优先级：<ol>
				<li>::作用域解析符</li>
				<li>[]、()、.(对象型成员调用)、->(指针型成员调用)、--(后置)、++(后置)</li>
				<li>++(前置)、--(后置)、sizeof、&(取值指针)、*(指针取值)、+(正号)、-(负号)、~(按位取反)、!(逻辑取反)</li>
				<li>(强制类型转换)</li>
				<li>->*(类指针成员引用)、.*(类对象成员引用)</li>
				<li>*(乘)、/、%</li>
				<li>+(加)、-(减)</li>
				<li>&lt;、&gt;、&lt;=、&gt;=</li>
				<li>==、!=</li>
				<li>&</li>
				<li>^</li>
				<li>|</li>
				<li>&&</li>
				<li>||</li>
				<li>?:</li>
				<li>=、*=、/=、%=、+=、-=、&lt;&lt;=、&gt;&gt;=、&=、^=、|=</li>
				<li>,</li>
				<li></li>
				<li></li>
			</p>
			</div><hr/>
		<div>
			<h3>条件语句</h3>
			<p>if()...else if()...else...：用于条件判断</p>
			<p>switch()...case x:...case xx:...default:...：用于选择判断</p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3>循环语句</h3>
			<p>while()...：判断是否为 true，是则进入</p>
			<p>do...while();：先执行，再判断是否为 true，是则再执行</p>
			<p>for(;;)...：</p>
			<p>break：退出循环，多层循环只会跳出最里面一层循环，可用于循环和 switch 语句</p>
			<p>continue：执行下次循环，只用于循环语句</p>
			<p>注意:循环嵌套时，break和continue只影响包含它们的最内层循环，与外层循环无关。</p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3>goto语句</h3>
			<p>执行到此语句是会强制跳转到指定的位置去继续执行，不提倡使用，使用不当可能会造成死循环</p>
			<p>goto xxx;...xxx:...：从 goto 直接跳转到 xxx: 而不会执行中间的语句</p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3>数组</h3>
			<p>数组是具有一定顺序关系的若干对象的集合体，组成数组的对象称为该数组的元素，数组元素用数组名与带方括号的下标表示，同一数组的各元素具有相同的类型。数组可由除 void 型以外的任何类型构成。一维数组用于储存和表示线性序列，二维数组可存储和表示数学中的矩阵</p>
			<p>一维数组：声明语法形式 T Name[size]，其中 T 类型名（如 float），Name 数组名，size常量表达式（数组大小），如 int a[5]={0,1,2,3,4}; 定义的同时为数组分配内存空间并对数组进行初始化，数组元素通过下标访问，下标从 0 开始，下标最大值 数组个数-1。注意：切勿数组越界</p>
			<p>多维数组：声明语法形式 T Name[size1][size2]...，其中size1 和 size2 等为常量表达式，分别对应各维度大小，如：<br/>
				int a[3][5]={{0,1,2,3,4},{1,2,3,4,5},{5,4,3,2,1}} 或 a[3][5]={0,1,2,3,4,5,6,7,8,9,5,4,3,2,1}，显式的行列并赋初值<br/>
				int a[][5]={1,2,3,4,5,5,4,3,2,1}，全部初始化，省略一维大小<br/>
				int a[3][5]={1,2,3,4,5,6,7} //只初始化部分元素的值，另一部分未初始化的值默认被初始化为 0<br/>
				int a[3][5]={{1},{2},{3}} //值初始化每行首元素的值</p>
			<p>数组拷贝实现：<br/>
				void swap(char a[],char b[],int len){for(int i=0;i<len;i++){b[i]=a[i];}}<br/>
				int main(){char x[3]={'1','2','3'},y[4]={'3','2','1','0'};swap(x,y,sizeof(x));printf("x=%s,y=%s",x,y);return 0;}<br/>
				参数的双向传递，前面的引用类型中也可实现传值。</p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3>指针</h3>
			<p>变量取地址需要使用取地址符(&)，如 a=1; 取 a 的地址为 &a，通过地址运算可以得到变量在内存中的地址</p>
			<p>一维数组在内存中是连续存储的，若访问的数组下标越界，则会访问到其他内存单元得到错误的值，地址之间相差的字节数由定义的数组类型决定，如 int 类型的一般是 4 字节，多维数组可通过循环嵌套得到每个对应的值和地址，如 a[i][j] 和 &a[i][j]，数组名即首地址，即 int a[5] 的首地址为 a 或 &a[0]</p>
			<p>指针语法形式 T *Name;，其中 T 为类型（指针所指对象的类型），* 表明此变量为指针，Name 定制指针的名称。声明指针后必须先赋值才可以引用。</p>
			<p>指针赋初值：1.声明的同时赋值；2.声明后使用赋值表达式语句为指针赋值。<br/>
				注意：赋给指针变量的值必须是地址常量（如数组名）或地址变量，不能是非0的整数<br/>
				若给一个指针变量赋值为0表示该指针是一个空指针，不指向任何地址。建议初始化时不需要赋值时赋值为 0，因为声明时没有赋值则会是一个没有确定的地址值，即随机值，若不小心误用作为地址访问内存单元则会造成不可预见的错误。</p>
			<p>数组和指针示例：<br/>
				int a[5]={1,2,3,4,5}<br/>
				int *p= a;</p>
			<p>指针函数：<br/>
				void swap(int *a,int *b){int t; t=*a;*a=*b;*b=t;}<br/>
				int main{int x(5),y(10);swap(&x,&y);return 0;}<br/>
				参数的双向传递，前面的引用类型中也可实现传值。</p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3>new 和 free</h3>
			<p>c++ 可通过 new 和 free 对动态内存进行分配和释放</p>
			<p>new：动态内存分配，或称动态创建堆对象。<br/>
				动态分配单个变量的语法形式为 new T(初值列表);<br/>
				动态分配一维数组的语法形式为 new T[元素个数];，其中 T 是类型名（将新申请的内存空间作为什么类型的变量使用），new 运算的结果值为新分配空间的起始地址，若分配失败则 new 结果为 0，动态分配的数值无法显式的指定元素的初始值。<br/>
				动态分配二维数组的语法形式为 new T[列数][行数];，使用指针赋值可这样用 int (*p)[3];//指向一维数组的指针 p=new int[2][3];//指针的指针指向二维数组的首地址，访问方式可为 p[i][j]，也可以是指针 (*(*(p+i)+j))<br/>
				运行时动态分配的内存空间不能命名，也就不能通过变量名来访问，只能通过new得到的地址进行操作。</p>
			<p>delete：用来删除由new创建的对象，释放指针所指向的内存空间，释放单个变量空间的语法形式 delete 指针名;，释放动态数组空间的语法形式 delete []指针名; </p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3>string 类字符串</h3>
			<p>可进行字符串的复制、拼接、比较、查找、插入、求子串、求串长等，在头文件 string.h 里</p>
			<p>语法形式为 string Name="xx"; 定义 string 类的字符串，字符串名称 Name，字符串初始化值 xx<br/>
				初始化还可以为 string Name2(Name); 这个的前提是 Name 已定义好了</p>
			<p>构造函数如下：<br/>
				string(); //默认构造函数，建立长度为 0 的串<br/>
				string(const string &rhs); //拷贝构造函数<br/>
				string(const char *s); //用指针 s 所指向的字符串初始化 string 对象<br/>
				string(const ctring &rhs,unsigned int pos,unsigned int n); //将对象 rhs 中的串从位置 pos 开始取 n 个字符，用来初始化 string 对象<br/>
				string(const char *s,unsigned int n); //用指针 s 所指向的字符串中的前 n 个字符串初始化 string 对象<br/>
				string(unsigned int n,char c); //在 string 对象中填充 n 个字符 c</p>
			<p>成员函数如下：<br/>
				//访问字符串大小<br/>
				size(); //字符串长度的 lenght()，如 Name.size();<br/>
				resize(); //重新分配 string 的大小<br/>
				capacity(); //返回 string 不需要重新分配内存空间的容量<br/>
				reserve(); //将字符串逆序<br/>
				empty(); //返回 string 的状态是否为空<br/>
				//对字符串进行修改<br/>
				append(); //将字符串添加到本串尾部，相当于 += 操作，如 Name1.append(Name);<br/>
				assign(); //将字符串复制给本对象，相当于 = 操作，如 Name1.assign(Name);<br/>
				insert(); //将提供的字符串插入到当前字符串的某个位置前，如 Name.insert(3,"hhh");<br/>
				substr(); //取子串，取所需要的子串，返回新的 string<br/>
				clear();  //清空所有内容<br/>
				erase();  //删除提供的字符<br/>
				//用于查找<br/>
				find(); //查找出现某个字符（串）的第一个位置<br/>
				rfind(); //逆向查找出现某个字符的第一个位置<br/>
				find_first_of(); //查找所提供字符串中字符出现的第一个位置，如 int value=Name.find_first_of("the");<br/>
				find_last_of(); //查找所提供字符串中字符出现的最后一个位置<br/>
				find_first_not_of(); //查找不是所提供字符串中字符出现的第一个位置<br/>
				find_last_not_of(); //查找不是所提供字符串中字符出现的最后一个位置<br/>
				//比较<br/>
				compare(); //比较大小，大于返回正数，小于返回负数，相等返回 0，如 int value=Name1.compare(Name);<br/>
				以上操作一般具有多种重载形式，具体重载形式可参考 string 类的定义，另外 string 类还重载了许多运算符（重载运算符，string 类有 +、=、+=、==、!=、&lt;、&lt;=、&gt;、&gt;=、[]），具体参考重载运算符一章</p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3>枚举</h3>
			<p>声明形式为 enum 枚举类型名 {变量值列表};</p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3>函数</h3>
			<p>语法如下：<br/>
				函数返回类型 函数名(参数列表)<br/>
				{<br/>
					&nbsp; //函数体<br/>
				}<br/>
				函数返回值：使用 return 对函数进行返回，从被调函数传递给主调函数，若没有则表示函数没有返回值，此时函数返回类型必须为 void<br/>
				函数名：自定义名称，作为函数标识<br/>
				参数列表：形式参数，即形参。函数要处理的数据，或处理方法的定制需求。形参只有再函数被调用时才会为形参分配存储单元并以实参的值初始化形参，形参结合的方式有传值、传引用、传地址<br/>
				函数体：函数功能的具体实现代码</p>
			<p>缺省参数值：设置了缺省值的参数可以在调用时不给实参，使用缺省值来初始化形参。<br/>
				省略参数：如 printf() 这个函数就是一个典型的省略参数，即无法列出传递给函数的所有实参的类型和数目，使用省略号指定函数参数表</p>
			<p>递归函数：函数在计算的过程中调用自己。递归由递推和回归两个过程构成。递推式由未知到已知过程，回归就是退出递归调用的点，否则会无限循环造成死循环</p>
			<p>内联函数：为程序的分解和代码重用提供方便,此函数必须结构简单，语句少，不能由循环和 switch 语句<br/>
				语法：inline 类型说明符 被调函数名(形参表){函数体;}</p>
			<p>函数指针：用于存放函数代码首地址的变量<br/>
				语法：数据类型 (*函数指针名)(形参表)<br/>
				函数指针在使用前也要先进行复制，使指针指向一个已存在的函数代码的起始地址，赋值如下：<br/>
				函数指针名 = 函数名; 或 函数指针名 = &函数名; //函数名即表示了它的地址<br/>
				函数名必须是一个已经声明过的，和函数指针具有相同返回类型和相同形参表的函数，赋值后就可以通过函数指针名来直接引用这个指针指向的函数<br/>
				注意：若是函数调用，则还必须包含一个圆括号括起来的参数表<br/>
				举例如下：<br/>
				int func_sum(int n)<br/>
				{<br/>
					&nbsp; int sum = 0;<br/>
					&nbsp; if (n < 0)<br/>
					&nbsp; {<br/>
						&nbsp; &nbsp; printf("n must be > 0\n");<br/>
						&nbsp; &nbsp; exit(-1);<br/>
					&nbsp; }<br/>
					&nbsp; for (int i = 0; i <= n; i++)<br/>
					&nbsp; {<br/>
						&nbsp; &nbsp; sum += i;<br/>
					&nbsp; }<br/>
					&nbsp; return sum;<br/>
				}<br/>
				int callback(int n, int (*p)(int))<br/>
				{<br/>
					&nbsp; return p(n);<br/>
				}<br/>
				int main()<br/>
				{<br/>
					&nbsp; int n = 0;<br/>
					&nbsp; printf("please input number:");<br/>
					&nbsp; scanf("%d", &n);<br/>
					&nbsp; printf("the sum from 0 to %d is %d\n", n, callback(n, func_sum));<br/>
					&nbsp; system("pause");<br/>
					&nbsp; return 0;<br/>
				}</p>
			<p>函数重载：两个以上的函数，具有相同的函数名，但形参个数或类型不同，编译器根据实参和形参的类型即个数进行最佳匹配，自动确定调用哪个函数，这就是函数重载<br/>
				举例：<br/>
				#include &lt;iostream><br/>
				using namespace std;<br/>
				int add(int x,int y){return x+y;}<br/>
				int add(int a,int b,int c){return a+b+c;}<br/>
				double add(double x,double y){return x+y;}<br/>
				double add(double a,double b,double c){return a+b+c;}<br/>
				int main()<br/>
				{<br/>
					&nbsp; int a=10,b=20,c=30;<br/>
					&nbsp; double e=1,f=2,g=3;<br/>
					&nbsp; printf("add a+b=%d,a+b+c=%d,e+f=%d,e+f+g=%d",add(a,b),add(a,b,c),add(e,f),add(e,f,g));<br/>
					&nbsp; return 0;<br/>
				}</p>
			<p>成员函数：类里面的成员函数。</p>
			<p>构造函数：在对象被创建时利用特定的值初始化对象，也是类的一个成员函数，但是函数名和类名相同并且没有返回值，构造函数在对象被创建时被自动调用。若没写构造函数则编译器自动生成一个缺省形式的构造函数，即没有参数，也不做任何事情的构造函数。若类中声明了构造函数则编译器不会生成任何构造函数<br/>
				语法：<br/>
				class 类名{<br/>
				public:<br/>
					&nbsp; 类型名 函数名(形参表);//成员函数<br/>
					&nbsp; 类名(形参表);//构造函数<br/>
					&nbsp; 类名(类名 &对象名);//拷贝构造函数<br/>
					&nbsp; friend 类型名 函数名(形参表); //友元函数<br/>
				};<br/>
				类型名 类名::函数名(形参表){<br/>
					&nbsp; 函数体; //成员函数实现<br/>
				}<br/>
				类名::类名(形参表){<br/>
					函数体; //构造函数实现<br/>
				}<br/>
				类名::类名(类名 &对象名){<br/>
					&nbsp; 函数体; //拷贝构造函数实现<br/>
				}<br/>
				类型名 函数名(形参表){<br/>
					&nbsp; 函数体; //友元函数实现<br/>
				}<br/>
				拷贝构造函数：对象成员在构造时动态分配内存空间</p>
			<p>析构函数：类对象在使用完后要进行析构，在对象生存期间占用资源（如动态申请内存空间），那在析构的时候就需要释放资源，否则可能造成资源泄露。<br/>
				析构在对象生存期结束对象即将消亡时会自动被调用，析构函数时类的一个公有函数成员，析构函数不接受任何参数<br/>
				类不写析构则编译器会自动生成默认的析构函数，若类中声明了析构函数则编译器就不再自动生成。<br/>
				语法：~类名(){析构实现;}</p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3>类</h3>
			<p>语法：<br/>
				class 类名称{<br/>
				public:<br/>
					&nbsp; 外部接口，公有成员函数<br/>
				protected:<br/>
					&nbsp; 保护成员<br/>
				private:<br/>
					&nbsp; 私有成员<br/>
				};</p>
			<p>类：用户自定义的类型，用来对现实世界或其他学科研究领域的复杂对象建模</p>
			<p>类定义：使用关键字 class 声明类名，然后进行类体的定义，包括基本的成员变量和成员函数，分别表示类的属性和行为</p>
			<p>类成员 3 种类型：private、protected、public 三种。<br/>
				private：私有成员，只能被所定义的类和类的友元访问，封装<br/>
				public：共有成员，可以被类访问，可以以对象访问的方式被任何其他类或函数进行访问，一般用于类的接口实现和其他类进行交互<br/>
				protected：保护成员，对于本类的派生来说是 public，对于其他类来说，类似于 private。</p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3>对象</h3>
			<p>对象的定义和初始化，语法如下：<br/>
				类名 对象名;<br/>
				定义对象后，通过 对象名.成员名 访问公有成员。</p>
			<p>对象的属性于行为：每个对象都具有属性和行为，具有共同属性和行为的对象属于同一类。如每个学生都有学号，姓名、班级等属性，有上课、选课等行为，将共同的 属性和行为抽象出来就形成了对学生这一类对象的描述<br/>
				每个学生对象就是学生类的一个实例。同一类对象具有共同属性，但属性值可彼此不同。</p>
			<p>对象属性的抽象：属性的抽象是指分析同类对象所具有的共同属性，找出需要解决的问题密切相关的属性，用类的数据成员来描述。</p>
			<p>对象功能与行为的抽象：功能与行为抽象指的是分析同类对象所具有的共同功能/行为，找出与需要解决的问题密切相关的功能和行为，用面向对象的程序语言进行抽象的描述。表现为函数成员</p>
			<p>类与对象：类是对一类问题的共同属性和行为的抽象，而对象是需要定义类类型的实例</p>
			<p>对象数组：<br/>
				初始化语法1：<br/>
				&nbsp; 类名 对象名[num]={{value,value1,value2,value3},{value4,value5,value6,value7},...,{value8,value9,value10,value11}};<br/>
				初始化语法2：<br/>
				&nbsp; 类名 对象名[num]={<br/>
					&nbsp; &nbsp; 类名(value,value1,value2,value3),<br/>
					&nbsp; &nbsp; 类名(value4,value5,value6,value7),<br/>
					&nbsp; &nbsp; ...,<br/>
					&nbsp; &nbsp; {value8,value9,value10,value11}};<br/>
				语法 2 不能和拷贝构造函数共存，如有了 Student::Student(Student &cp) 则语法 2 就会直接报错，编译无法通过。</p>
			<p>对象指针：通过指针访问对象，如管理的对象群体元素个数直到运行时才能确定，这时需要在运行时确定数组大小，这样就需要用动态内存分配的方式构造数组。<br/>
				</p>
			<p>以对象作为函数参数：若形参时对象，则实参也是同类型对象，或公有派生类的对象，在执行函数调用时进行形实结合，自动调用拷贝构造函数，用实参对象初始化形参</p>
			<p></p>
			</div><hr/>
		<div>
			<h3>this 指针</h3>
			<p>类的每个非静态成员函数都有一个指向当前对象的指针，这个特殊指针就是 this 指针。在类的非静态成员函数中访问数据成员时，隐含以“this->数据成员名”的形式访问的。</p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3>结构体</h3>
			<p>使用关键字 struct 定义，它的所有成员变量和成员函数都默认 public 类型。</p>
			<p>语法：<br/>
			struct 结构名{<br/>
				&nbsp; 数据类型 成员名;<br/>
				&nbsp; ...<br/>
				&nbsp; 数据类型 成员名;<br/>
			};</p>
			<p></p>
			<p></p>
			<form>
				<fieldset>
				<legend>** <b>Student 示例</b> **</legend>
				#include &lt;iostream><br/>
				using namespace std;<br/>
				struct student{<br/>
					&nbsp; int num;<br/>
					&nbsp; string name;<br/>
					&nbsp; char gender;<br/>
					&nbsp; //student(){num=0;name="china";gender='H';}//和对象数组冲突了<br/>
					&nbsp; void setstudent(int _num,string _name,char _gender){<br/>
						&nbsp; &nbsp; num=_num;<br/>
						&nbsp; &nbsp; name=_name;<br/>
						&nbsp; &nbsp; gender=_gender;<br/>
					&nbsp; }<br/>
					&nbsp; void printall();<br/>
				};<br/>
				void student::printall(){<br/>
					&nbsp; cout<&lt;this->num<&lt;this->name<&lt;this->gender<&lt;endl;<br/>
				}<br/>
				int main()<br/>
				{<br/>
					&nbsp; student stu;<br/>
					&nbsp; stu.setstudent(1,"en",'M');<br/>
					&nbsp; cout<&lt;stu.name<&lt;stu.num<&lt;stu.gender<&lt;endl;<br/>
					&nbsp; student stu1[3]={{1,"ch",'H'},{2,"en",'M'},{3,"jp",'L'}};<br/>
					&nbsp; cout<&lt;stu1[0].name<&lt;stu1[0].num<&lt;stu1[0].gender<&lt;endl;<br/>
					&nbsp; cout<&lt;stu1[1].name<&lt;stu1[1].num<&lt;stu1[1].gender<&lt;endl;<br/>
					&nbsp; cout<&lt;stu1[2].name<&lt;stu1[2].num<&lt;stu1[2].gender<&lt;endl;<br/>
					&nbsp; stu1[0].printall();<br/>
					&nbsp; stu1[1].printall();<br/>
					&nbsp; stu1[2].printall();<br/>
					&nbsp; return 0;<br/>
				}</fieldset>
			</form>
			
			</div><hr/>
		<div>
			<h3>联合体</h3>
			<p>通过关键字 union 定义，它的所有成员变量和成员函数都默认 public 类型。<br/>
				占用空间时其中单个变量占用的最大空间，即联合体中所有成员在内存中首地址一样，不同成员共有相同内存。</p>
			<p>语法：<br/>
			union 联合名{<br/>
				&nbsp; 数据类型 成员名;//数据类型不能是 string 字符串，char * 却可以<br/>
				&nbsp; ...<br/>
				&nbsp; 数据类型 成员名;<br/>
			};</p>
			<p>联合体类型变量说明语法：联合名 联合变量名;。联合体类型变量的引用形式：联合变量名.成员名</p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3>友元</h3>
			<p>友元函数：允许一个函数或类访问另一个类的私有成员，这时需要声明友元。如在重载运算符为非成员函数是通常将运算符函数声明为友元；在类中有另一个类的对象作为成员时有时需要声明组合类为部件类的友元来方便对成员对象进行操作。</p>
			<p>友元函数声明以关键字 friend 开始，只能出现在类的定义中，因为友元不是授权类的成员，因此不受其所在类的声明区域的影响。</p>
			<p>友元函数语法：<br/>
				1.全局函数声明为友元：friend 函数类型 函数名(参数表);<br/>
				2.其他类的成员函数声明为友元：friend 函数类型 其他类名::成员函数名(参数表); 这里不能是私有成员函数</p>
			<p>友元类：类似友元函数，指数此时声明的是一个类，被声明为友元的类可访问声明友元类的所有私有数据成员</p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<form>
				<fieldset>
				<legend>** <b>student 友元函数示例</b> **</legend>
				#include &lt;iostream><br/>
				using namespace std;<br/>
				class student{<br/>
				private:<br/>
					&nbsp; int num;<br/>
					&nbsp; string name;<br/>
					&nbsp; int score;<br/>
				public:<br/>
					&nbsp; student(){num=1;name="Bob";score=99;}<br/>
					&nbsp; ~student(){}<br/>
					&nbsp; friend void printall(student value);<br/>
				};<br/>
				void printall(student value){<br/>
					&nbsp; cout<&lt;value.num<&lt;value.name<&lt;value.score<&lt;endl;<br/>
				}<br/>
				int main(){<br/>
					&nbsp; student stu;<br/>
					&nbsp; printall(stu);<br/>
					&nbsp; return 0;<br/>
				}</fieldset>
			</form>
			<form>
				<fieldset>
				<legend>** <b>友元类示例</b> **</legend>
				#include &lt;iostream><br/>
				using namespace std;<br/>
				class b;//声明<br/>
				class a{<br/>
				private:<br/>
					&nbsp; double x;<br/>
				public:<br/>
					&nbsp; friend class b;<br/>
					&nbsp; a(double _x):x(_x){}<br/>
					&nbsp; ~a(){}<br/>
				};<br/>
				class b{<br/>
				public:<br/>
					&nbsp; b(){}<br/>
					&nbsp; ~b(){}<br/>
					&nbsp; void print(const a y){cout&lt;&lt;y.x&lt;&lt;endl;}<br/>
				};<br/>
				int main()<br/>
				{<br/>
					&nbsp; a tempa(10.1);<br/>
					&nbsp; b tempb;<br/>
					&nbsp; tempb.print(tempa);<br/>
					&nbsp; return 0;<br/>
				}
				</fieldset>
			</form>
			</div><hr/>
		<div>
			<h3>运算符重载函数</h3>
			<p>运算符重载就是对已有的运算符赋予多重含义，使之能够作用于自定义的新数据类型。</p>
			<p>运算符重载只针对 c++ 原有运算符进行重载，不能通过重载创建新的运算符，下面 5 个运算符不允许重载：.（成员访问运算符）、.*（成员指针运算符）、::（作用域区分运算符）、?:（条件运算符）、sizeof（测数据空间大小运算符）<br/>
				由于很多一元和二元运算符共有，如 * 即可间接访问也可用于两数相乘，为避免混淆，c++ 不允许为重载的运算符函数设置默认参数值，调用时也不可省略实参。<br/>
				重载运算符应尽可能保持原有基本语义，如 + 含义应当是相加、添加、连接等。重载运算符应体现为原运算符的功能在新的数据类型上的延伸。</p>
			<p>运算符重载为成员函数：作为成员函数重载时第一操作数就是对象本身，因此并不需要出现在参数表中；重载二元运算符时参数表中只有一个参数；重载一元运算符时参数表为空，表示没有第二操作数。<br/>
				如：- 二元运算符表达式为 a-b 等同于 a.operator-(b)；<br/>++ 表达式为 ++a 等同于 a.operator++()。这里 ++ 有前置和后置之分，为了区分，以成员函数形式重载的后置单目运算符需要有一个 int 类型的参数（此参数只作为区分，实际并不会使用）<br/>
				除 new 和 delete 以外，任何运算符都可重载为成员函数；=、[]、()、-> 以及所有的类型转换运算符只能作为成员函数重载<br/>
				语法：<br/>
				类 operator 运算符(形参表);//一目运算符定义；或 函数类型 operator运算符(形参表);<br/>
				类 类::operator运算符(形参表){函数体;}//实现；或 函数类型 类::operator运算符(形参表){函数体;}<br/>
				如 a=10,b=20,c=a+b;//可作为 + 运算符重载使用</p>
			<p>运算符重载为非成员函数：一般使用友元，由于友元函数不是任何类的成员，所以重载时必须在参数表中显示给出所有操作数。<br/>
				重载二元运算符时参数表有两个参数，- 表达式 a-b 等同于 operator(a,b)；++ 表达式 ++a 等同于 operator++(a)。和成员函数一样有前后之分，区分方式一样。<br/>
				重载一个前置一元运算符时参数表有一个参数；重载一个后置一元运算符时参数表中有个 int 参数。<br/>
				=、[]、()、-> 以及所有类型转换运算符不能作为非成员函数重载<br/>
				语法：<br/>
				friend 类 operator运算符(形参表);//定义；或 friend 函数类型 operator运算符(形参表);<br/>
				类 operator运算符(形参表){函数体;}//实现；或 函数类型 operator运算符(形参表){函数体;}<br/>
				如 a=10,b=20;c=a+b;//使用</p>
			<p>前置和后置举例：<br/>
				成员函数：<br/>
				//定义<br/>
				类& operator ++();//前置<br/>
				类 operator ++(int);//后置<br/>
				//实现<br/>
				类& 类::operator++(){函数体;}<br/>
				类 类::operator++(int){函数体;}<br/>
				//使用<br/>
				++a;<br/>
				a++;<br/>
				非成员函数（友元函数）<br/>
				//定义<br/>
				friend 类& operator ++(类& a);//前置<br/>
				friend 类 operator ++(类& a, int);//后置<br/>
				//实现<br/>
				类& operator++(类& a){函数体;}<br/>
				类 operator++(类& a, int){函数体;}<br/>
				//使用<br/>
				++a<br/>
				a++</p>
			<p>赋值运算符（+=，-=、*=、/=等）<br/>
				类& operator =(const 类& a)//定义
				类& 类::operator=(const 类& a){函数体;}//实现
				a=b;//使用</p>
			<p>重载类型转换符：<br/>
				operator 转换类型();//定义<br/>
				类::operator 转换类型(){函数体;}<br/>
				如 double(a);//将a强制转换成 double 类型</p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3>外部变量和外部函数</h3>
			<p>多个文件时在一个文件中定义的变量或函数想在其他文件中使用，这时就需要将其定义为外部变量或外部函数</p>
			<p>以 extern 关键字作为标识</p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3>命名空间</h3>
			<p>命名空间：c++ 用来避免命名冲突的机制。命名空间相当于一个作用域，在这个作用域里，所有标识符都是唯一的。不同命名空间的名字作用域也不相同。如 using namespace std 就是 c++ 标准库的命名空间。</p>
			<p>自定义命名空间：<br/>
				namespace namespace_name{<br/>
					&nbsp; //变量声明;<br/>
					&nbsp; //函数声明;<br/>
					&nbsp; //类型定义;<br/>
				}<br/>
				其中 namespace 是关键字，namespace_name 标识命名空间的标识符，它唯一标识了命名空间，大括号内是命名空间的作用域</p>
			<p>命名空间成员使用域作用符 :: 访问，如 my::name、my::parent()<br/>
				使用 using 声明后，可直接使用成员而不需要再加 :: 前面的数据，如 usring namespace my; 之后可直接使用 name，parent()<br/>
				using 指定使用命名空间的特定成员，之后使用该成员就不必加前缀了，如 using my::name<br/>
				为命名空间定义别名：namespace self=my; 这时 self 就是 my 的别名，self.name</p>
			<p>命名空间嵌套：在命名空间里定义命名空间，这时嵌套的命名空间成员自动加到外层命名空间并嵌套命名空间前缀，如 my::my1::parent()</p>
			<p>语法：<br/>
				namespace 命名空间名{<br/>
					&nbsp; 函数类型 函数名(形参表);<br/>
				}<br/>
				函数类型 命名空间名::函数名(形参表){<br/>
					&nbsp; //函数体;<br/>
				}
				</p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3>编译预处理</h3>
			<p>将 c++ 代码编译为机器指令之前执行的一个过程</p>
			<p>#include 预处理指令：包含头文件<br/>
			#if...#elif..#else...#endif...：条件编译<br/>
			#if defined()/!defined() 或 #ifdef/ifndef：编辑编译<br/>
			#define/#undef：宏定义或符号定义<br/>
			#line：重新定义当前行和文件<br/>
			#error：产生编译时错误信息<br/>
			#pragma：提供机器专用特性，同时保证与 c++ 的完全兼容</p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3>类的继承</h3>
			<p>继承：从先辈处得到属性和行为；<br/>
				类的继承：新的类从已有类那里得到已有的特性。从另一个角度看，从已有类产生新类的过程就是类的派生。类的继承和派生机制时程序员保持原有类特性基础上进行更具体更详细的修改和扩充。由原有类产生新类时，新类在保持原类特征的同时也可以加入自己所特有的新特征。原有类成为基类或父类，新产生的类称为派生类或子类。</p>
			<p>派生类定义：<br/>
				class 派生类名:继承方式 基类名1,基类名2,...,继承方式 基类名n<br/>
				{<br/>
					//派生类成员声明;<br/>
				}<br/>
				一个派生类同时有多个基类则称为多继承，否则称为单继承。<br/>
				直接派生出新类的基类称为该新类的直接基类，基类的基类或更高的基类则称为间接基类。<br/>
				继承方式：public、protected、private 分别表示公有继承、保护继承、私有继承。系统默认私有继承。</p>
			<p>派生类的生成过程：<br/>
				1.吸收基类成员：继承后，派生类继承基类中除构造函数和析构函数外的所有成员<br/>
				2.改造基类成员：派生类的同名属性或行为与基类不同特性时，在派生类中重新声明或定义，这样就隐藏了基类中的同名成员，这称为同名隐藏<br/>
				3.添加新成员：添加派生类新的数据成员</p>
			<p>继承成员的访问控制：<br/>
				1.公有继承：基类中公有和保护成员访问属性在派生类中不变，而基类的私有成员不可直接访问<br/>
				2.私有继承：基类中公有和保护成员到派生类中访问属性都变为私有成员，而基类的私有成员不可直接访问<br/>
				3.保护继承：基类的公有和保护成员继承到派生类中访问属性都为保护成员，而基类的私有成员不可直接访问</p>
			<p>派生类的构造函数和析构函数：<br/>
				class A{<br/>
					&nbsp; int a;<br/>
					&nbsp; int b;<br/>
					&nbsp; int c;<br/>
				public:<br/>
					&nbsp; A(int _a,int _b,int _c):a(_a),b(_b),c(_c){}<br/>
					&nbsp; ~A(){}<br/>
					&nbsp; int geta(){return a;}<br/>
				};<br/>
				class B:public A{<br/>
					&nbsp; int d;<br/>
				public:<br/>
					&nbsp; B(int _b,int _c,int _d):A("A",_b,_c),d(_d){}<br/>
					&nbsp; ~B(){}<br/>
					&nbsp; int getd(){return d;}<br/>
				};<br/>
				构造函数是先基类再派生类；析构函数是先派生类再基类。</p>
			<p>向上转型：派生类是从它的直接和间接基类继承而来，它保持了基类的所有特性。因此，在语法上，一个公有派生类的对象总是可以用来充当一个基类的对象。繁殖却不可以，因为派生类在继承的基础上有所发展，具有了基类所不具有的新的属性和特征<br/>
				具体来说，一个公有派生类对象的指针值额可以赋值给（或初始化）一个基类指针，一个公有派生类对象可以初始化一个基类引用，派生类对象也可以赋值给一个基类对象。利用这样的指针或引用，只能访问派生类对象中从基类继承过来的成员，无法访问派生类的自有成员（派生类中重定义的虚函数除外）</p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3>多继承</h3>
			<p>同名隐藏：一个派生类的多个基类具有同名成员，并且派生类也声明了同名成员，这时访问同名成员时访问的时派生类中的，基类中的就会被隐藏（单继承也是一样）</p>
			<p>域作用符：派生对象和基类具有同名成员时想访问基类成员则需要使用域作用符“::”，如：<br/>
				基类名::成员名;<br/>
				基类名::函数名(参数);</p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3>虚基类</h3>
			<p>重复继承：可能会出现一个派生类中同时拥有成员的两份拷贝，这样会增加内存开销。如：<br/>
				class B{int value;}<br/>
				class X:public B{}<br/>
				class Y:public B{}<br/>
				class Z:public X,public Y{}<br/>
				这时若取值<br/>
				Z z;<br/>
				z.X::value=10;<br/>
				z.Y::value=20;<br/>
				这种就是一个 z 派生类有 value 两个拷贝</p>
			<p>虚基类声明：在继承时加上 virtual 关键字，语法：class 派生类名:virtual 继承方式 基类名<br/>
				如上面的重复继承可改成：<br/>
				class B{int value;}<br/>
				class X:virtual public B{}<br/>
				class Y:virtual public B{}<br/>
				class Z:public X,public Y{}<br/>
				这样就能保证在派生类 Z 的对象中保存基类 B 中同名成员 value 的唯一拷贝了</p>
			<p>若虚基类有非默认形式（带形参的）构造函数，并且没有声明默认构造函数，注意这时在整个继承关系中，直接或间接继承虚基类的所有派生类都必须在构造函数的成员初始化表中对虚拟基类进行初始化<br/>
				class A{<br/>
					&nbsp; int all;int a;<br/>
				public:<br/>
					&nbsp; A(int _all,int _a):all(_all),a(_a){}<br/>
				};<br/>
				class B:virtual public A{<br/>
					&nbsp; int b;<br/>
				public:<br/>
					&nbsp; B(int _all,int _a,int _b):A(_all,_a),b(_b){}<br/>
				};<br/>
				class C:virtual public A{<br/>
					&nbsp; int c;<br/>
				public:<br/>
					&nbsp; C(int _all,int _a,int _c):A(_all,_a),b(_c){}<br/>
				};<br/>
				class D:public B,public C{<br/>
					&nbsp; int d;<br/>
				public:<br/>
					&nbsp; D(int _all,int _a,int _b,int _c,int _d):A(_all,a),B(_all,_a,_b),C(_all,_a,_c),d(_d){}<br/>
				};
				</p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3>多态</h3>
			<p>多态：指操作接口具有表现多种形态的能力，即能根据操作环境的不同采用不用的处理方式<br/>
				如 + 可实现两整数相加，也可完成两实数相加。使得不同但又具有共同属性的对象不但再一定程度上共享代码，还能共享接口，提高系统的一致性、灵活性、可维护性</p>
			<p>多态性按实现的时机分为：编译时的多态性、运行时的多态性<br/>
				编译时多态性：如函数重载和模板，有关操作所针对的具体目标（函数或类）的确定多数在编译时完成的。其实现机制称为静态绑定（静态联编）<br/>
				运行时的动态多态性：如虚函数</p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3>虚函数</h3>
			<p>虚函数：是 c++ 实现动态、多态性的机制，通过虚函数可使基类和派生类中的同名函数具有不同功能</p>
			<p>在成员函数前加 virtual 修饰即把该函数声明为虚函数。使用时需注意两点：1.virtual 只能用于类体中；2.虚函数不能是静态函数</p>
			<p>虚函数语法：<br/>
				virtual 函数类型 函数名(形参表){函数体;}<br/>
				基类的指针或引用访问派生类中的覆盖函数，必须将基类中的同名函数声明为虚函数
				<form>
				<fieldset>
				<legend>** <b>基类指针或引用访问派生类覆盖函数</b> **</legend>
				class A{<br/>
				public:<br/>
					&nbsp; int a,b;<br/>
					&nbsp; virtual void outall(){printf((char *)"this is A,a=%d\n",a);}<br/>
				};<br/>
				class B:public A{<br/>
				public:<br/>
					&nbsp; int b;<br/>
					&nbsp; B(int _b):b(_b){}<br/>
					&nbsp; void outall(){printf((char *)"this is B,b=%d\n",b);}<br/>
				};<br/>
				class C:public A{<br/>
				public:<br/>
					&nbsp; int c;<br/>
					&nbsp; C(int _c):c(_c){}<br/>
					&nbsp; void outall(){printf((char *)"this is C,c=%d\n",c);}<br/>
				};<br/>
				int main(){<br/>
					&nbsp; B b(10);<br/>
					&nbsp; C c(20);<br/>
					&nbsp; //基类的指针或引用访问派生类中的覆盖函数，必须将基类中的同名函数声明为虚函数<br/>
					&nbsp; A *x = &amp;b;<br/>
					&nbsp; A &y = c;<br/>
					&nbsp; x->outall();//B<br/>
					&nbsp; y.outall();//C<br/>
					&nbsp; return 0;<br/>
				}</fieldset>
				</form>
				</p>
			<p>在派生类中可以重新定义从基类继承下拉的虚函数，从而形成该函数在派生类中的专门版本。<br/>
				在派生类中也可以不重新定义虚函数，在这种情况下，继承下拉的虚函数仍然保持其在基类中的定义，业绩派生类和基类共用同一个函数版本。<br/>
				虚函数在派生类中被重定义后，重定义的函数仍然是一个虚函数，可在更下一层次的派生类中再次被重定义<br/>
				注意，在派生类中重定义虚函数时，无论是否用 virtual 修饰都函数虚函数。当然，最好还是保留 virtual 修饰，以增强可读性。</p>
			<p>一个基类指针（或引用）可以用于指向它的子类对象。通过这个指针（或引用）调用虚函数时，被调用的是该指针（或引用）实际指向的对象类的那个重定义版本。类中的其他成员函数也可以调用虚函数，这时通过指针调用虚函数的一种特殊情况：即通过 this 指针来调用虚函数，只不过在调用格式中一般省略前缀 this-></p>
			<p>构造函数不能声明为虚函数，在构造函数中可以调用虚函数，但由于在构造函数执行过程中，派生类对象的一些部分（非继承部分，包括虚函数表）尚未形成，这种情况将被处理为静态绑定，被调用的总是所在类的那个虚函数版本</p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			
			<h3>虚析构函数</h3>
			<p>c++ 中虽然不能声明虚构造函数，但可以声明虚析构函数。注意：1.重定义函数就是派生类的析构函数，不要求同名；2.一个虚析构函数的版本被调用执行后，接着就要调用执行其基类版本，依此类推，直到调用执行了派生序列的最开始的哪个虚析构函数版本为止</p>
			<p>一般来说，若一个派生类包含了对析构函数的专门声明（而不是采用默认的析构函数），而且该类对象有可能作为多态对象使用，则其基类的析构函数通常应答是一个虚析构函数。</p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<h3>纯虚函数</h3>
			<p>带有纯虚函数的类就是抽象类，注意抽象类不能实例化，也就是不能用抽象类声明对象。但可以声明抽象类的指针或引用，通过指针和引用可以指向并访问派生类的对象，进入访问派生类成员，实现运行过程中的多态。</p>
			<p>纯虚函数定义语法：virtual 函数类型 函数名(参数表) = 0;<br/>
				这样可在基类中只定义函数的原型，具体的功能实现可在派生类中根据派生类的具体要求分别实现</p>
			<p>在派生类中实现一个纯虚函数后，即成为一般的虚函数。若一抽象类的派生没有实现来自基类的某个纯虚函数，则该函数在派生类中仍然是纯虚函数，这使得该派生类也成为抽象类。</p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3>重载 &lt;&lt; 和 &gt;&gt;</h3>
			<p>&lt;&lt;：插入运算符，语法为 ostream &operator &lt;&lt;(ostream &os,&lt;类名>&obj);<br/>
				&gt;&gt;：提取运算符，语法为 istream &operator &gt;&gt;(istream &is,&lt;类名>&obj);<br/>
				其中 ostream 的第二个参数也可以是 const &lt;类名>&obj。</p>
			<p>举例：<br/>
				class A{};<br/>
				//定义<br/>
				ostream &operator &lt;&lt;(ostream &os, const A &a);<br/>
				istream &operator &gt;&gt;(istream &is, A &a);<br/>
				//实现<br/>
				ostream &operator &lt;&lt;(ostream &os, const A &a){}<br/>
				istream &operator &gt;&gt;(istream &is, A &a){}<br/>
				//使用<br/>
				A x;<br/>
				cout&lt;&lt;x&lt;&lt;endl;
				</p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3>容错和异常处理</h3>
			<p>抛出异常 throw 语法：throw 表达式<br/>
				throw 的操作数表示异常类型，语法和 return 语句的操作数相似，若干程序中多处要抛出异常，应该用不同的操作数类型来相互区分，操作数的值不能用来区分不同的异常。</p>
			<p>捕获异常：try 和 catch。try 用来捕获异常，catch 用来异常处理。语法如下：<br/>
				try<br/>
					&nbsp; 复合语句<br/>
				catch (异常类型声明)<br/>
					&nbsp; 复合语句<br/>
				catch (异常类型声明)<br/>
					&nbsp; 复合语句<br/>
				......
				</p>
			<p>举例：<br/>
				函数类型 函数名1(形参表){<br/>
					&nbsp; ...<br/>
					&nbsp; throw xx;//xx 可以是 int、char *、类名()等<br/>
				}<br/>
				函数类型 函数名2(形参表){<br/>
					&nbsp; try{<br/>
						&nbsp; &nbsp; 函数名1(形参表);<br/>
					&nbsp; }<br/>
					&nbsp; catch (xxx){//xxx 可以为 int、int a、char *b、类名 c（复制）、类名 &d（引用）等<br/>
						&nbsp; &nbsp; 异常处理;<br/>
					&nbsp; }<br/>
					&nbsp; catch (xxx){<br/>
						&nbsp; &nbsp; 异常处理;<br/>
					&nbsp; }<br/>
					&nbsp; catch(...){// ... 表示无论是何异常都会进入此异常处理<br/>
						&nbsp; &nbsp; 异常处理;<br/>
					&nbsp; }<br/>
				}
				</p>
			<p></p>
			</div><hr/>
		<div>
			<h3>线性群体</h3>
			<p>线性群体：也可称为线性表，元素按一定次序排列。线性表中有且只有一个元素没有之间前驱称为头元素；有且只有一个元素没有后继称为尾元素；其他的都有前驱和后继。<br/>
				按存区方式分为直接存取类（数组，直接下标获取）、顺序存取类（链表，指针索引）、广义索引类</p>
			<p>链表的每个元素是一个结点，每个节点存储了元素数据以及指向下一个元素的指针。<br/>
				如果每个节点只有一个指向后继节点的指针，则称该链表为单链表；<br/>
				如果每个节点中右两个指针分别指向其前驱和后继，则称为双向链表；<br/>
				若干链表的尾结点和头结点之间用指针连接，则构成了循环链表。</p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3>栈和队列</h3>
			<p>栈：先进后出，有栈空、栈满和一般状态。栈也是一种线性表（仅在一端进行插入删除操作）<br/>
				队列：先进先出，有队空、队满和一般状态。队列也是一种线性表（只能在一端删除元素，在另一端添加元素），在队列中允许插入的一端称为队尾，允许删除的一端称为对头。多用于操作系统中作业调度和文件输入/输出的管理。</p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3></h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3></h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3></h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3></h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3></h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3></h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3></h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3></h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3></h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3></h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3></h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3></h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3></h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3></h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3></h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			</div><hr/>
		<div>
			<h3>实例</h3>
			<form>
			<fieldset>
				<legend>** <b>Student 示例</b>**</legend>
#include &lt;iostream><br>
using namespace std; //命名空间<br>
class Student{<br>
private:<br>
	&nbsp; string name;//对象属性<br>
	&nbsp; unsigned long index;<br>
	&nbsp; int score;<br>
	&nbsp; char *gender;<br>
public:<br>
	&nbsp; Student(){//构造函数，类声明时若为初始化则使用此默认值作为缺省值<br>
		&nbsp; &nbsp; name="Bob";//实则时 this->name = xx，下面的也是<br>
		&nbsp; &nbsp; index=1;<br>
		&nbsp; &nbsp; score=90;<br>
		&nbsp; &nbsp; gender="female";<br>
	&nbsp; }<br>
	&nbsp; Student(string newname,unsigned long newindex,int newscore,char *newgender):<br>
		&nbsp; &nbsp; name(newname),index(newindex),score(newscore),gender(newgender){}//构造函数，定义类的时候就初始化<br>
	&nbsp; Student(char *newname,unsigned long newindex,int newscore,char *newgender){//构造函数，使用 c 语言中的 char * 来表示字符串<br>
		&nbsp; &nbsp; name=newname;<br>
		&nbsp; &nbsp; index=newindex;<br>
		&nbsp; &nbsp; score=newscore;<br>
		&nbsp; &nbsp; gender=newgender;}<br>
	&nbsp; Student(char *newgender);//构造函数<br>
	&nbsp; Student(Student &cp);//拷贝构造函数<br>
	&nbsp; ~Student(){//析构函数<br>
		&nbsp; &nbsp; if(gender != NULL)<br>
			&nbsp; &nbsp; &nbsp; delete []gender;<br>
		&nbsp; &nbsp; if(!name.empty())<br>
			&nbsp; &nbsp; &nbsp; name.erase();}<br>
	&nbsp; string getname(){return name;}//对象行为或功能<br>
	&nbsp; unsigned long getindex(){return index;}<br>
	&nbsp; int getscore(){return score;}<br>
	&nbsp; char *getgender(){return gender;}<br>
	&nbsp; void setname(string newname){name = newname;}<br>
	&nbsp; void setindex(unsigned long newid){index = newid;}<br>
	&nbsp; void setscore(int newscore){score = newscore;}<br>
	&nbsp; void setgender(char *newgender){gender=newgender;}<br>
};<br>
Student::Student(char *newgender){//构造函数进行拷贝<br>
	&nbsp; int n=strlen(newgender);<br>
	&nbsp; gender=new char[n+1];<br>
	&nbsp; strcpy(gender,newgender);<br>
}<br>
Student::Student(Student &cp){//拷贝构造函数进行拷贝<br>
	&nbsp; int n=strlen(cp.getgender());<br>
	&nbsp; gender=new char[n+1];<br>
	&nbsp; strcpy(gender,cp.getgender());<br>
	&nbsp; name=cp.getname();<br>
	&nbsp; index=cp.getindex();<br>
	&nbsp; score=cp.getscore();<br>
}<br>
int main()<br>
{<br>
	&nbsp; Student stu("Lisa",2,80,"female");<br>
	&nbsp; cout<<"name is "<&lt;stu.getname()<<"\nindex is "<&lt;stu.getindex()<<"\ncredit is "<&lt;stu.getscore()<&lt;endl;<br>
	&nbsp; Student stu1[3]={//对象数组<br>
		&nbsp; &nbsp; {"Bob",1,90,"male"},<br>
		&nbsp; &nbsp; {"Lisa",2,80,"female"},<br>
		&nbsp; &nbsp; {"Tom",3,76,"male"}<br>
		&nbsp; &nbsp; };<br>
	&nbsp; /*Student stu1[3]={//不能和拷贝构造函数共存，所以只能用前面一个初始化对象数组<br>
		&nbsp; &nbsp; Student("Bob",1,90,"male"),<br>
		&nbsp; &nbsp; Student("Lisa",2,80,"female"),<br>
		&nbsp; &nbsp; Student("Tom",3,76,"male")};*/<br>
	&nbsp; cout<<"name is "<&lt;stu1[0].getname()<<"\nindex is "<&lt;stu1[0].getindex()<<"\ncredit is "<&lt;stu1[0].getscore()<&lt;endl;<br>
	&nbsp; cout<<"name is "<&lt;stu1[1].getname()<<"\nindex is "<&lt;stu1[1].getindex()<<"\ncredit is "<&lt;stu1[1].getscore()<&lt;endl;<br>
	&nbsp; cout<<"name is "<&lt;stu1[2].getname()<<"\nindex is "<&lt;stu1[2].getindex()<<"\ncredit is "<&lt;stu1[2].getscore()<&lt;endl;<br>
	&nbsp; int size;<br>
	&nbsp; Student *list;//对象指针<br>
	&nbsp; string _name;<br>
	&nbsp; unsigned long _index;<br>
	&nbsp; int _score;<br>
	
	&nbsp; cout<<"please you input number:";<br>
	&nbsp; cin>>size;<br>
	&nbsp; list=new Student[size];<br>
	&nbsp; for(int i=0; i < size; i++){<br>
		&nbsp; &nbsp; cout<<"input your name: ";<br>
		&nbsp; &nbsp; cin>>_name;<br>
		&nbsp; &nbsp; cout<<"input your index: ";<br>
		&nbsp; &nbsp; cin>>_index;<br>
		&nbsp; &nbsp; cout<<"input your score: ";<br>
		&nbsp; &nbsp; cin>>_score;}<br>
	&nbsp; cout<<"--------end---------"<&lt;endl;<br>
	&nbsp; system("pause");<br>
	&nbsp; return 0;
				</fieldset>
			</form>
			<p></p>
			</div><hr/>
		<div>
			<h3></h3>
			<p>cin&gt;&gt;isample&gt;&gt;oct&gt;&gt;osample&gt;&gt;hex&gt;&gt;hsample;输入十进制、八进制、十六进制形式</p>
			<p>cout&lt;&lt;isample&lt;&lt;';'&lt;&lt;oct&lt;&lt;osample&lt;&lt;hex&lt;&lt;hsample&lt;&lt;endl;输出十进制、八进制、十六进制形式</p>
			<p></p>
			</div><hr/>
	</div>
</body>
</html>
