<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
	<link rel="shortcut icon" href="../../../picture/favicon.ico" type="image/x-icon">
	<title>C++</title>
	<link rel="stylesheet" type="text/css" href="../../../home/all.css" >
	<style>
		.main_body a{text-decoration:none}
		.main_body p{line-height:25px;}
	</style>
</head>
<body>
	<div class="menu_body">
		<a href="../../../home.html">首页</a>
		<a href="../../study.html">学习</a>
		<a href="../../../工具/tools.html">工具</a>
		<a href="../../../阅读/read.html">阅读</a>
		<a href="../../../娱乐/play.html">娱乐</a>
	</div>
	<div class="left_body">
		<ul>
			<li><a href="../c/c.html">c</a></li>
			<li><a href="./c++.html">c++</a></li>
			<li><a href="../css/css.html">css</a></li>
			<li><a href="../html/html.html">html</a></li>
			<li><a href="../协议/http/http.html">http</a></li>
			<li><a href="../java/java.html">java</a></li>
			<li><a href="../javascript/javascript.html">javascript</a></li>
			<li><a href="../python/python.html">python</a></li>
			<li><a href="../sql/sql.html">Sql</a></li>
			<li><a href="../php/php.html">php</a></li>
			<li><a href="../photoshop/photoshop.html">PS</a></li>
			<li><a href="../cad/cad.html">CAD</a></li>
			<li><a href="../硬件/硬件.html">硬件</a></li>
			<li><a href="../语言/语言.html">语言</a></li>
			<li><a href="../系统/系统.html">系统</a></li>
		</ul>
	</div>
	<div class="table_body">
		<a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br>
		<a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br>
		<a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br>
		<a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br>
		<a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br>
		<a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br>
	</div>
	<div class="main_body">
		<div>
			<h3>简介</h3>
			<p>C++ 是 C 的扩展，向下兼容 C，也就是，C 编写的程序可完全直接在 C++ 上运行<br/>C++ 是面向对象的程序语言，面向对象的三要素为封装、继承、多态<br/>
			封装：将数据和处理数据的方法封装在一起成为一个类，类的实体是对象，对象一旦定义就可看出一个完全封装的实体，使用类，使类的成员外部不可见，但是可以提供接口供外部设置或读取<br/>
			继承：一个始位保留了另一种始位的全部特征并具有自身独有的特征。子类从父类（基类）中继承内部成员与成员函数，新类型从现有类型中派生出来的称为派生类<br/>
			多态：多种事物继承同一事物时，同一种操作在它们之间表现不同的行为<p>
			<p>基本字符：字母（大小写 a-z ）、数字（0-9）、特殊符号（+ - * / = , . _ : ; ? \ " ' ~ | ! # % & ( ) [ ] { } ^ < > 空格）</p>
			<p>标识符：字母、数字、下划线组成，其中数字不能作为开头，不能和关键字同名，区分大小写，有一定长度（一般有效长度 32 字节，超出将被截断）</p>
			<p>常量：整个程序运行过程中不可变的值，符号常量和文字常量，如 PI 3.14157 这里 PI 符号常量（标识符），3.14157 文字常量（值）<p>
			<p>变量：整个程序运行过程中会被改动，未初始化的变量是全局变量则默认为 0，局部变量则是随机的值<p>
			<p>语句：标号语句、表达式语句、复合语句、选择语句、循环语句、跳转语句、声明语句等。<br/>
				声明语句：对变量名、函数原型、类名、对象名进行声明的语句。<br/>
				表达式语句：在表达式末尾添加一个分号就构成了表达式语句，如 a=a+3;<br/>
				复合语句：执行两条或两条以上的语句序列，这时使用复合语句来替代单条语句，复合语句由花括号括起来。<p>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			</div><hr/>
		<div>
			<h3>关键字</h3>
			<table border="1">
				<tr><td>auto</td><td>bool</td><td>break</td><td>case</td><td>catch</td><td>char</td><td>class</td></tr>
				<tr><td>const</td><td>const_cast</td><td>continue</td><td>default</td><td>delete</td><td>do</td><td>double</td><td></td></tr>
				<tr><td>dynamic_cast</td><td>else</td><td>enum</td><td>explicit</td><td>extern</td><td>false</td><td>float</td></tr>
				<tr><td>for</td><td>friend</td><td>goto</td><td>if</td><td>inline</td><td>int</td><td>long</td></tr>
				<tr><td>mutable</td><td>namespace</td><td>new</td><td>operator</td><td>private</td><td>protected</td><td>public</td></tr>
				<tr><td>register</td><td>reinterpret_cast</td><td>return</td><td>short</td><td>signed</td><td>sizeof</td><td>static</td></tr>
				<tr><td>static_cast</td><td>struct</td><td>switch</td><td>template</td><td>this</td><td>throw</td><td>true</td></tr>
				<tr><td>try</td><td>typedef</td><td>typeid</td><td>typename</td><td>union</td><td>unsigned</td><td>using</td></tr>
				<tr><td>virtual</td><td>void</td><td>volatile</td><td>while</td><td></td><td></td><td></td></tr>
			</table>
			<p><p>
			</div><hr/>
		<div>
			<h3>数据类型</h3>
			<p>整型：int、short int（int 可省略）、long int（int 可省略）、signed（可省略）、unsign、char（字符也可作为整型）<br/>
				整型形式：十进制（0-9）、八进制（0-7,0 开头）、十六进制（0-9、A-F，0x 开头）、长整型可用后缀 L/l，无符号可用 U/u<br/>
				整型最值：在 climits.h 头文件中一系列宏定义表示，如 SHRT_MIN/MAX 短整型最大小值、INT_MIN/MAX 整型最大小值、LONG_MIN/MAX 长整型最大小值、USHRT_MAX 无符号短整型最大值、UINT_MAX 无符号整型最大值、ULONG_MAX 无符号长整型<p>
			<p>浮点型：float（单精度）、double（双精度）、long double（扩展精度）<br/>
				一般形式：12.5、-12.5<br/>指数形式：12.5E+3（12.5 * 10的三次方）、.123e-1（0.123 * 10的负一次方）、12.e-3（12.0 * 10的负三次方）<br/>
				注意：浮点文字量之间不能出现空格<br/>
				默认 double，若需要为 float 则需加后缀 F/f，long double 需加后缀 L/l<p>
			<p>字符型：一个字符使用单引号括起来<br/>
				转义字符：\n（换行符）、\t（水平制表符）、\v（垂直制表符）、\b（退格符）、\r（回车键）、\f（换页符）、\a（响铃符）、\\（反斜杠）、\?（问号）、\'（单引号）、\"（双引号）、一般的转义序列（\xx，xx 表示八进制序列，如 \7 响铃符、\14 换行符、\0 空、\062 即 '2'）<br/>
				以数组存放 C 风格的字符串，如 char str[]="hello!";<br/>
				string 类型字符串：需要引用 string.h 头文件，可使用处理方式由字符串的复制、拼接、比较、查找、插入、求子串、求串长度等<p>
			<p>字符串型：c 语言的字符串类型和 c++ 的 String 类，在 c++ 中基本数据类型中没有字符串型的变量，只有 c 的字符串常量，但可以用数组存放字符串。<br/>
				字符串赋值最后会加一个'\0'作为结束符<p>
			<p>布尔型：bool，只有 true 和 false 两个值，常用于关系、相等的比较或逻辑运算的结果<p>
			<p>引用类型：主要作为函数的参数使用，可实现参数的双向传递，从语法上看就是一个变量的别名<br/>
				引用必须在声明的时候进行初始化，一经初始化就不能改变（指的是引用关系不可变，也就是在程序运行过程中一个引用只能始终作为同一变量的别名，当然可以通过引用改变它代表的变量），比如<br/>
				int a=10; int &b=a;//这里就是用 a 初始化了引用 b，这样 b 就成为变量 a 的别名，也就是引用 b 和变量名 a 的变量地址是一样的<br/>
				这时 b 和 a 相等（值），&b 和 &a 相等（地址）。<br/>
				用引用作为函数的参数可以实现形参和实参相结合，使形参成为实参变量的引用。这样在被调函数中就可以通过引用访问主调函数中的实参变量，如：<br/>
				void swap(int &a,int &b){int t; t=a;a=b;b=t;}<br/>
				int main{int x(5),y(10);swap(x,y);return 0;}<br/>
				在我看来这和常规的函数没有什么区别。指针也可以实现传值。<p>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			</div><hr/>
		<div>
			<h3>运算</h3>
			<p>算术运算：++（前后置的自增）、--（前后置的自减）、+、-、*、/、%。<br/>
				&nbsp;优先级为：（后置-- 和后置++）&gt;（前置-- 和前置++）&gt;（* / %）&gt; （+ -）<p>
			<p>赋值运算：符号 =，将其右边的表达式值赋给左边的对象。<br/>
				&nbsp;复合赋值运算符：*=、/=、%=、+=、-=、&gt;&gt;=、&lt;&lt=、&=、^=、|=。优先级高于逗号运算符低于其他运算符。<p>
			<p>逗号运算符：逗号表达式是一系列由逗号分开的表达式，从左到右计算，逗号表达式的结果是最右边表达式的值。如：<br/>
				&nbsp;bool a = true;<br/>&nbsp;int b, c;<br/>&nbsp;a ? b=1, c=b : c=2, b=b;<br/>&nbsp;结果是 a=true，b=1，c=1<p>
			<p>关系运算符：用于比较数据大小关系，返回 true 或 false，关系运算符优先级相同，运算次序自左向右，运算符有： &lt;、&lt;=、&gt;、&gt;=、==、!=<p>
			<p>逻辑运算符：将多个关系表达式和相等表达式组合起来构成复杂的逻辑判断，优先级为 逻辑非(!) &gt; && 和 ||<p>
			<p>sizeof 运算：返回一个对象或类型的字节长度，有三种形式：sizeof(类型名称)、sizeof(表达式)、sizeof(对象)。<br/>
				&nbsp;如：sizeof(short)<p>
			<p>位运算：按位非(~ ，0 和 1 的翻转)，左移(&lt;&lt;)、右移(&gt;&gt;)、按位与(&)、按位异或(^)、按位或(|)、<p>
			<p>类型转换：隐式转换和显示转换，其中隐式转换包括混合算术运算、将值赋给另一类型的变量、函数参数传递、函数返回返回值<br/>
				混合算术运算是将低精度转换高精度类型，从低到高 char->short->int>unsigned int->long->unsigned long->float->double<br/>
				显示转换时一种强制转换，如 类型说明符(表达式) 或 (类型说明符)表达式，前面是 c++ 强制转换方式，后面是 c 转换方式<p>
			<p><p>
			<p>运算符优先级：<ol>
			<li>::作用域解析符</li>
			<li>[]、()、.(对象型成员调用)、->(指针型成员调用)、--(后置)、++(后置)</li>
			<li>++(前置)、--(后置)、sizeof、&(取值指针)、*(指针取值)、+(正号)、-(负号)、~(按位取反)、!(逻辑取反)</li>
			<li>(强制类型转换)</li>
			<li>->*(类指针成员引用)、.*(类对象成员引用)</li>
			<li>*(乘)、/、%</li>
			<li>+(加)、-(减)</li>
			<li>&lt;、&gt;、&lt;=、&gt;=</li>
			<li>==、!=</li>
			<li>&</li>
			<li>^</li>
			<li>|</li>
			<li>&&</li>
			<li>||</li>
			<li>?:</li>
			<li>=、*=、/=、%=、+=、-=、&lt;&lt;=、&gt;&gt;=、&=、^=、|=</li>
			<li>,</li>
			<li></li>
			<li></li>
			<p>
			</div><hr/>
		<div>
			<h3>条件语句</h3>
			<p>if()...else if()...else...：用于条件判断<p>
			<p>switch()...case x:...case xx:...default:...：用于选择判断<p>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			</div><hr/>
		<div>
			<h3>循环语句</h3>
			<p>while()...：判断是否为 true，是则进入<p>
			<p>do...while();：先执行，再判断是否为 true，是则再执行<p>
			<p>for(;;)...：<p>
			<p>break：退出循环，多层循环只会跳出最里面一层循环，可用于循环和 switch 语句<p>
			<p>continue：执行下次循环，只用于循环语句<p>
			<p>注意:循环嵌套时，break和continue只影响包含它们的最内层循环，与外层循环无关。<p>
			<p><p>
			<p><p>
			<p><p>
			</div><hr/>
		<div>
			<h3>goto语句</h3>
			<p>执行到此语句是会强制跳转到指定的位置去继续执行，不提倡使用，使用不当可能会造成死循环<p>
			<p>goto xxx;...xxx:...：从 goto 直接跳转到 xxx: 而不会执行中间的语句<p>
			<p><p>
			<p><p>
			</div><hr/>
		<div>
			<h3>数组</h3>
			<p>数组是具有一定顺序关系的若干对象的集合体，组成数组的对象称为该数组的元素，数组元素用数组名与带方括号的下标表示，同一数组的各元素具有相同的类型。数组可由除 void 型以外的任何类型构成。一维数组用于储存和表示线性序列，二维数组可存储和表示数学中的矩阵<p>
			<p>一维数组：声明语法形式 T Name[size]，其中 T 类型名（如 float），Name 数组名，size常量表达式（数组大小），如 int a[5]={0,1,2,3,4}; 定义的同时为数组分配内存空间并对数组进行初始化，数组元素通过下标访问，下标从 0 开始，下标最大值 数组个数-1。注意：切勿数组越界<p>
			<p>多维数组：声明语法形式 T Name[size1][size2]...，其中size1 和 size2 等为常量表达式，分别对应各维度大小，如：<br/>
				int a[3][5]={{0,1,2,3,4},{1,2,3,4,5},{5,4,3,2,1}} 或 a[3][5]={0,1,2,3,4,5,6,7,8,9,5,4,3,2,1}，显式的行列并赋初值<br/>
				int a[][5]={1,2,3,4,5,5,4,3,2,1}，全部初始化，省略一维大小<br/>
				int a[3][5]={1,2,3,4,5,6,7} //只初始化部分元素的值，另一部分未初始化的值默认被初始化为 0<br/>
				int a[3][5]={{1},{2},{3}} //值初始化每行首元素的值<p>
			<p>数组拷贝实现：<br/>
				void swap(char a[],char b[],int len){for(int i=0;i<len;i++){b[i]=a[i];}}<br/>
				int main(){char x[3]={'1','2','3'},y[4]={'3','2','1','0'};swap(x,y,sizeof(x));printf("x=%s,y=%s",x,y);return 0;}<br/>
				参数的双向传递，前面的引用类型中也可实现传值。<p><p>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			</div><hr/>
		<div>
			<h3>指针</h3>
			<p>变量取地址需要使用取地址符(&)，如 a=1; 取 a 的地址为 &a，通过地址运算可以得到变量在内存中的地址<p>
			<p>一维数组在内存中是连续存储的，若访问的数组下标越界，则会访问到其他内存单元得到错误的值，地址之间相差的字节数由定义的数组类型决定，如 int 类型的一般是 4 字节，多维数组可通过循环嵌套得到每个对应的值和地址，如 a[i][j] 和 &a[i][j]，数组名即首地址，即 int a[5] 的首地址为 a 或 &a[0]<p>
			<p>指针语法形式 T *Name;，其中 T 为类型（指针所指对象的类型），* 表明此变量为指针，Name 定制指针的名称。声明指针后必须先赋值才可以引用。<p>
			<p>指针赋初值：1.声明的同时赋值；2.声明后使用赋值表达式语句为指针赋值。<br/>
				注意：赋给指针变量的值必须是地址常量（如数组名）或地址变量，不能是非0的整数<br/>
				若给一个指针变量赋值为0表示该指针是一个空指针，不指向任何地址。建议初始化时不需要赋值时赋值为 0，因为声明时没有赋值则会是一个没有确定的地址值，即随机值，若不小心误用作为地址访问内存单元则会造成不可预见的错误。<p>
			<p>数组和指针示例：<br/>
				int a[5]={1,2,3,4,5}<br/>
				int *p= a;<p>
			<p>指针函数：<br/>
				void swap(int *a,int *b){int t; t=*a;*a=*b;*b=t;}<br/>
				int main{int x(5),y(10);swap(&x,&y);return 0;}<br/>
				参数的双向传递，前面的引用类型中也可实现传值。<p>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			</div><hr/>
		<div>
			<h3>new 和 free</h3>
			<p>c++ 可通过 new 和 free 对动态内存进行分配和释放<p>
			<p>new：动态内存分配，或称动态创建堆对象。<br/>
				动态分配单个变量的语法形式为 new T(初值列表);<br/>
				动态分配一维数组的语法形式为 new T[元素个数];，其中 T 是类型名（将新申请的内存空间作为什么类型的变量使用），new 运算的结果值为新分配空间的起始地址，若分配失败则 new 结果为 0，动态分配的数值无法显式的指定元素的初始值。<br/>
				动态分配二维数组的语法形式为 new T[列数][行数];，使用指针赋值可这样用 int (*p)[3];//指向一维数组的指针 p=new int[2][3];//指针的指针指向二维数组的首地址，访问方式可为 p[i][j]，也可以是指针 (*(*(p+i)+j))<br/>
				运行时动态分配的内存空间不能命名，也就不能通过变量名来访问，只能通过new得到的地址进行操作。<p>
			<p>delete：用来删除由new创建的对象，释放指针所指向的内存空间，释放单个变量空间的语法形式 delete 指针名;，释放动态数组空间的语法形式 delete []指针名; <p>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			</div><hr/>
		<div>
			<h3>string 类字符串</h3>
			<p>可进行字符串的复制、拼接、比较、查找、插入、求子串、求串长等，在头文件 string.h 里<p>
			<p>语法形式为 string Name="xx"; 定义 string 类的字符串，字符串名称 Name，字符串初始化值 xx<br/>初始化还可以为 string Name2(Name); 这个的前提是 Name 已定义好了<p>
			<p>构造函数如下：<br/>
				string(); //默认构造函数，建立长度为 0 的串<br/>
				string(const string &rhs); //拷贝构造函数<br/>
				string(const char *s); //用指针 s 所指向的字符串初始化 string 对象<br/>
				string(const ctring &rhs,unsigned int pos,unsigned int n); //将对象 rhs 中的串从位置 pos 开始取 n 个字符，用来初始化 string 对象<br/>
				string(const char *s,unsigned int n); //用指针 s 所指向的字符串中的前 n 个字符串初始化 string 对象<br/>
				string(unsigned int n,char c); //在 string 对象中填充 n 个字符 c<p>
			<p>成员函数如下：<br/>
				//访问字符串大小<br/>
				size(); //字符串长度的 lenght()，如 Name.size();<br/>
				resize(); //重新分配 string 的大小<br/>
				capacity(); //返回 string 不需要重新分配内存空间的容量<br/>
				reserve(); //将字符串逆序<br/>
				empty(); //返回 string 的状态是否为空<br/>
				//对字符串进行修改<br/>
				append(); //将字符串添加到本串尾部，相当于 += 操作，如 Name1.append(Name);<br/>
				assign(); //将字符串复制给本对象，相当于 = 操作，如 Name1.assign(Name);<br/>
				insert(); //将提供的字符串插入到当前字符串的某个位置前，如 Name.insert(3,"hhh");<br/>
				substr(); //取子串，取所需要的子串，返回新的 string<br/>
				clear();  //清空所有内容<br/>
				erase();  //删除提供的字符<br/>
				//用于查找<br/>
				find(); //查找出现某个字符（串）的第一个位置<br/>
				rfind(); //逆向查找出现某个字符的第一个位置<br/>
				find_first_of(); //查找所提供字符串中字符出现的第一个位置，如 int value=Name.find_first_of("the");<br/>
				find_last_of(); //查找所提供字符串中字符出现的最后一个位置<br/>
				find_first_not_of(); //查找不是所提供字符串中字符出现的第一个位置<br/>
				find_last_not_of(); //查找不是所提供字符串中字符出现的最后一个位置<br/>
				//比较<br/>
				compare(); //比较大小，大于返回正数，小于返回负数，相等返回 0，如 int value=Name1.compare(Name);<br/>
				以上操作一般具有多种重载形式，具体重载形式可参考 string 类的定义，另外 string 类还重载了许多运算符（重载运算符，string 类有 +、=、+=、==、!=、&lt;、&lt;=、&gt;、&gt;=、[]），具体参考重载运算符一章<p>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			</div><hr/>
		<div>
			<h3>枚举</h3>
			<p>声明形式为 enum 枚举类型名 {变量值列表};<p>
			<p><p>
			<p><p>
			<p><p>
			</div><hr/>
		<div>
			<h3>函数</h3>
			<p>语法如下：<br/>
			函数返回类型 函数名(参数列表)<br/>
			{<br/>
				&nbsp; //函数体<br/>
			}<br/>
			函数返回值：使用 return 对函数进行返回，从被调函数传递给主调函数，若没有则表示函数没有返回值，此时函数返回类型必须为 void<br/>
			函数名：自定义名称，作为函数标识<br/>
			参数列表：形式参数，即形参。函数要处理的数据，或处理方法的定制需求。形参只有再函数被调用时才会为形参分配存储单元并以实参的值初始化形参，形参结合的方式有传值、传引用、传地址<br/>
			函数体：函数功能的具体实现代码<p>
			<p>缺省参数值：设置了缺省值的参数可以在调用时不给实参，使用缺省值来初始化形参。<br/>
				省略参数：如 printf() 这个函数就是一个典型的省略参数，即无法列出传递给函数的所有实参的类型和数目，使用省略号指定函数参数表<p>
			<p>递归函数：函数在计算的过程中调用自己。递归由递推和回归两个过程构成。递推式由未知到已知过程，回归就是退出递归调用的点，否则会无限循环造成死循环<p>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			</div><hr/>
		<div>
			<h3></h3>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			</div><hr/>
		<div>
			<h3></h3>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			</div><hr/>
		<div>
			<h3></h3>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			</div><hr/>
		<div>
			<h3></h3>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			</div><hr/>
		<div>
			<h3></h3>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			</div><hr/>
		<div>
			<h3></h3>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			</div><hr/>
		<div>
			<h3></h3>
			<p><p>
			<p><p>
			<p><p>
			<p><p>
			</div><hr/>
		<div>
			<h3></h3>
			<p><p>
			</div><hr/>
		<div>
			<h3></h3>
			<p><p>
			</div><hr/>
		<div>
			<h3></h3>
			<p>cin&gt;&gt;isample&gt;&gt;oct&gt;&gt;osample&gt;&gt;hex&gt;&gt;hsample;输入十进制、八进制、十六进制形式<p>
			<p>cout&lt;&lt;isample&lt;&lt;';'&lt;&lt;oct&lt;&lt;osample&lt;&lt;hex&lt;&lt;hsample&lt;&lt;endl;输出十进制、八进制、十六进制形式<p>
			<p><p>
			</div><hr/>
	</div>
</body>
</html>
