<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
	<title>标准库</title>
	<link rel="stylesheet" type="text/css" href="../../../home/all.css" >
	<link rel="shortcut icon" href="../../../picture/favicon.ico" type="image/x-icon">
	<style>
		.main_body li{line-height:25px;}
		a{text-decoration:none;}
	</style>
</head>
<body>
	<div class="menu_body">
		<a href="../../../home.html">首页</a>
		<a href="../../study.html">学习</a>
		<a href="../../../工具/tools.html">工具</a>
		<a href="../../../阅读/read.html">阅读</a>
		<a href="../../../娱乐/play.html">娱乐</a>
	</div>
	<div class="left_body">
		<ul>
			<li><a href="./c.html">c</a></li>
			<li><a href="../c++/c++.html">c++</a></li>
			<li><a href="../css/css.html">css</a></li>
			<li><a href="../html/html.html">html</a></li>
			<li><a href="../协议/http/http.html">http</a></li>
			<li><a href="../java/java.html">java</a></li>
			<li><a href="../javascript/javascript.html">javascript</a></li>
			<li><a href="../python/python.html">python</a></li>
			<li><a href="../sql/sql.html">Sql</a></li>
			<li><a href="../php/php.html">php</a></li>
			<li><a href="../photoshop/photoshop.html">PS</a></li>
			<li><a href="../cad/cad.html">CAD</a></li>
			<li><a href="../硬件/硬件.html">硬件</a></li>
			<li><a href="../语言/语言.html">语言</a></li>
			<li><a href="../系统/系统.html">系统</a></li>
		</ul>
	</div>
	<div class="table_body">
		<a href="#stdio">stdio.h</a><br><a href="#ctype">ctype.h</a><br><a href="#assert">assert.h</a><br><a href="#time">time.h</a><br><a href="#"></a><br>
		<a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br><a href="#"></a><br>
		<a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br><a href="#"></a><br>
		<a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br><a href="#"></a><br>
		<a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br><a href="#"></a><br>
		<a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br><a href="#"></a><br>
	</div>
	<div class="main_body">
		<div id="stdio">
			<h3>stdio.h</h3>
			<ol>
			<li>int printf(const char *format, ...)：将内容输出到屏幕，成功返回输出的字符数，失败返回负值。
				<ul>
				<li>%d：十进制有符号整数</li>
				<li>%u：十进制无符号整数</li>
				<li>%f：浮点数</li>
				<li>%s：字符串</li>
				<li>%c：单个字符</li>
				<li>%x/%X：十六进制</li>
				<li>%p：输出指针类型自身的值，也就是指针指向的地址值，十六进制形式</li>
				<li>%e：指数形式的浮点数</li>
				<li>%o：无符号以八进制表示的整数</li>
				<li>%g：把输出的值按照%e或者%f类型中输出长度较小的方式输出</li>
				<li>%lu：32位无符号整数</li>
				<li>%llu：64位无符号整数</li>
				<li>%ld/%lf：输出长整型，双精度浮点型 double</li>
				<li>其他：\n 换行；\f 清屏并换页；\r 回车；\t 制表符；\xhh 表示用十六进制显示 ascii</li>
				</ul>
				注意：<br/>
				1.可在 % 和字母之间加入数字表示最大场宽，若有小数点，小数点后的数为小数位数，小数点前面的数为小数点后数+小数点+小数前的整数部分<br/>
				2.若字符串长度或整数位数超过场宽则按实际长度输出<br/>
				3.浮点数的整数部分超过场宽按实际输出，小数部分超过则四舍五入<br/>
				4.若想用0补齐则 % 后数字前加 0 即可<br/>
				5.如果用非浮点数表示字符或整型量的输出格式，小数点后的数字代表最大宽度，小数点前的数字代表最小宽度，小数点后的数表示全部数据大于此时以后的数据内容将被删除<br/>6.控制左对齐或右对齐，即在 % 和字母之间加个 - 减号即可表示左对齐，否则右对齐<br/>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					int main(){<br/>
						&nbsp; printf("start......\n");<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int fprintf(FILE *fp, const char *format, ...)：输出到流文件<br/>
				fp：指向 FILE 对象的指针<br/>
				format：字符串，包含写入参 1 的文本<br/>
				第一个printf类似，只不过第一个是将流数据打印到屏幕，而这里是将流数据写入参 1 指定的文件中，直到遇到‘\0’为止。其中 format 参数代替值格式为 %[flags][width][.precision][length]specifier，具体如下：<br/>
				specifier：说明符
				<ul>
				<li>c：字符</li>
				<li>d/i：有符号十进制整数</li>
				<li>e/E：科学记数法</li>
				<li>f：浮点数</li>
				<li>g/G：自动选择 %e/%E 或 %f 合适的表示法</li>
				<li>o：有符号八进制</li>
				<li>s：字符的字符串</li>
				<li>u：无符号十进制整数</li>
				<li>x/X：无符号十六进制整数</li>
				<li>p：指针地址</li>
				<li>n：无输出</li>
				<li>%：两个 % 即转义的 % 字符</li>
				</ul>
				flags：标识
				<ul>
				<li>-：左对齐（默认右对齐）</li>
				<li>+：强制在结果前加入符号位（默认情况只有负数有显示 - 号符号位，而正数忽略）</li>
				<li>(space)：没有写入任何符号，插入空格</li>
				<li>#：与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X；与 e、E 和 f 一起使用时，会强制输出包含一个小数点，即使后边没有数字时也会显示小数点。默认情况下，如果后边没有数字时候，不会显示显示小数点；与 g 或 G 一起使用时，结果与使用 e 或 E 时相同，但是尾部的零不会被移除</li>
				<li>0：在指定填充 padding 的数字左边放置零（0），而不是空格</li>
				</ul>
				width：宽度
				<ul>
				<li>(number)：要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充。如果输出的值长于该数，结果不会被截断</li>
				</ul>
				.precision：精度
				<ul>
				<li>.number：对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符；对于 e、E 和 f 说明符：要在小数点后输出的小数位数；对于 g 和 G 说明符：要输出的最大有效位数；对于 s: 要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符；对于 c 类型：没有任何影响；当未指定任何精度时，默认为 1。如果指定时不带有一个显式值，则假定为 0</li>
				<li>.*：精度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前</li>
				</ul>
				length：长度
				<ul>
				<li>h：参数被解释为短整型或无符号短整型（仅适用于整数说明符：i、d、o、u、x 和 X）</li>
				<li>l：参数被解释为长整型或无符号长整型，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）</li>
				<li>L：参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。</li>
				</ul>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;fcntl.h><br/>
					int main(){<br/>
						&nbsp; FILE *fp;<br/>
						&nbsp; fp=fopen("./main.c","a+");<br/>
						&nbsp; fprintf(fp,"this is project...\n");<br/>
						&nbsp; fclose(fp);<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int sprintf(char *str, const char *format, ...)：把格式化的数据写入某个字符串缓冲区<br/>
				str：指向字符数组的指针<br/>
				format：格式化字符串，包含了要被写入到字符串 str 的文本，格式化方式和fprintf类似，会自动在末尾加上空字符'\0'<br/>
				返回值：成功返回写入的字符总数，不包括字符串追加在末尾的空字符，失败返回负数
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					int main(){<br/>
						&nbsp; char buff[255];<br/>
						&nbsp; sprintf(buff,"start......\n");<br/>
						&nbsp; printf("%s",buff);//将 buff 打印出来<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int snprintf(char *str, size_t size, const char *format, ...)：按 size 大小输出到字符串str<br/>
				size：截取的字符串长度，包括 '\0‘，即 size=实际长度+1<br/>
				其他值参考如上 sprintf
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					int main(){<br/>
						&nbsp; char buff[255];<br/>
						&nbsp; snprintf(buff,6,"start......\n");//包括 \0<br/>
						&nbsp; printf("%s",buff);//将 start 打印出来<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int vsprintf(char *str, const char *format, va_list arg)：使用参数列表发送格式化输出到字符串
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;stdarg.h><br/>
					char buff[1024];<br/>
					int printff(char *format,...){<br/>
						&nbsp; int n;<br/>
						&nbsp; va_list ap;<br/>
						&nbsp; va_start(ap,format);<br/>
						&nbsp; n = vsprintf(buff,format,ap);<br/>
						&nbsp; va_end(ap);<br/>
						&nbsp; return n;<br/>
					}<br/>
					int main(){<br/>
						&nbsp; printff("start......\n");<br/>
						&nbsp; printf("%s",buff);<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>FILE *fopen(char *filename, char *mode)：打开文件<br/>
				filename：文件名，包括文件路径，两个反斜杠中第一个反斜杠为转义字符。<br/>
				mode：打开方式。<br/>
				<ul><li>r：只读，并且文件必须已存在；</li>
				<li>b：二进制文件</li>
				<li>t：文本文件</li>
				<li>w：只写，若打开的文件不存在则以指定的文件名创建该文件，若文件已存在则将该文件删除重新创建新文件</li>
				<li>a：追加，若文件不存在则尝试创建该文件</li>
				<li>+：读写</li></ul>
				返回值：成功返回为FILE 类型的结构体变量的地址（获取文件信息，包括文件名、文件状态、当前读写位置等信息），若返回为NULL，则表示打开失败
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					int main(){<br/>
						&nbsp; FILE *fp=fopen("main.c","a+");<br/>
						&nbsp; if(fp == NULL)<br/>
						&nbsp; {<br/>
							&nbsp; &nbsp; printf("open fail.\n");<br/>
						&nbsp; }<br/>
						&nbsp; fclose(fp);<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>void setbuf(FILE *fp, char *buffer)：主要用于打开和关闭缓冲机制。<br/>
				fp：标识一个打开的流<br/>
				buffer：分配给用户的缓存，为 NULL 表示关闭缓存
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					int main(){<br/>
						&nbsp; char buff[BUFSIZ];//长度至少为 BUFSIZ，否则存在缓冲溢出可能<br/>
						&nbsp; setbuf(stdout,buff);<br/>
						&nbsp; printf("start......\n");<br/>
					}<br/>
					或<br/>
					#include &lt;stdio.h><br/>
					int main(){<br/>
						&nbsp; char *buff = NULL<br/>
						&nbsp; FILE *fp=fopen("main.c","a+");<br/>
						&nbsp; setbuf(fp,buff);//不使用流缓冲<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>char *fgets(char *str, int n, FILE *fp)：从指定的流中读取数据，每次读取一行，读取的数据放入 str 中。<br/>
				str：指向数组的指针，数组存储读取的字符串<br/>
				n：读取的最大字符数，包括最后的控制阀，若未到此值遇到换行符或已到达文件末尾则会停止<br/>
				fp：指向 FILE 对象的指针<br/>
				返回值：成功返回相同的 str ，若到文件末尾或者没有读取到任何字符，str 的内容不变，返回一个空指针。发生错误，返回空指针。<br/>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					int main(){<br/>
						&nbsp; char buff[1024];<br/>
						&nbsp; FILE *fp;<br/>
						&nbsp; char *p;<br/>
						&nbsp; fp=fopen("main.c","r");<br/>
						&nbsp; if(fp == NULL){<br/>
							&nbsp; &nbsp; printf("file open fail.\n");<br/>
							&nbsp; &nbsp; return 0;<br/>
						&nbsp; }<br/>
						&nbsp; while(1){<br/>
							&nbsp; &nbsp; p=fgets(buff,1024,fp);<br/>
							&nbsp; &nbsp; if((p == NULL)||(buff == NULL))<br/>
								&nbsp; &nbsp; &nbsp; break;<br/>
							&nbsp; &nbsp; printf("%s",p);<br/>
						&nbsp; }<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int fclose( FILE *fp )：关闭一个流并刷新所有缓冲区。可以把缓冲区内最后剩余的数据输出到内核缓冲区，并释放文件指针和有关的缓冲区。<br/>
				fp：指向 FILE 对象的指针<br/>
				返回值：成功返回 0，失败返回 EOF（-1）<br/>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					int main(){<br/>
						&nbsp; FILE *fp;<br/>
						&nbsp; fp=fopen("main.c","r");<br/>
						&nbsp; if(fp == NULL){<br/>
							&nbsp; &nbsp; printf("file open fail.\n");<br/>
						&nbsp; }<br/>
						&nbsp; else{<br/>
							&nbsp; &nbsp; printf("file is open.\n");<br/>
							&nbsp; &nbsp; if(fclose(fp) == EOF)<br/>
								&nbsp; &nbsp; &nbsp; printf("file close fail.\n");<br/>
						&nbsp; }<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>void perror(const char *str)：将上一个函数发生错误原因输出到标准设备，str 会先打印出来，然后再加上冒号和空格，最后加上错误原因（依据 errno 输出错误原因）<br/>
				str：自定义消息，输出再错误消息之前<br/>
				即输出为：str: error（每个 error 指对应一个错误的字符串信息）<br/>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					int main(){<br/>
						&nbsp; FILE *fp;<br/>
						&nbsp; fp=fopen("main1.c","r");//并没有 main1.c 这个文件<br/>
						&nbsp; if(fp == NULL){<br/>
							&nbsp; &nbsp; perror("file open fail");//除了输出这段，还会打印后面的错误信息<br/>
						&nbsp; }<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int vprintf(const char *format, va_list arg)：使用参数列表发送格式化输出到标准输出 stdout<br/>
				format：包含了要被写入到标准输出 stdout 的文本，format 标签属性是 %[flags][width][.precision][length]specifier，具体 format 请参考 fprintf 函数。<br/>
				arg：可变参数列表的对象<br/>
				返回值：成功返回字节数，失败返回负数
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;stdarg.h><br/>
					int printff(char *format,...){<br/>
						&nbsp; int n;<br/>
						&nbsp; va_list ap;<br/>
						&nbsp; va_start(ap,format);<br/>
						&nbsp; n = vprintf(format,ap);<br/>
						&nbsp; va_end(ap);<br/>
						&nbsp; return n;<br/>
					}<br/>
					int main(){<br/>
						&nbsp; printff("start......\n");<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int vfprintf(FILE *fp, const char *format, va_list arg)：使用参数列表发送格式化输出到流 fd 中<br/>
				fp：文件标识符，可以是 fopen 打开的文件<br/>
				format：包含了要被写入到流 stream 中的文本，format 标签属性是 %[flags][width][.precision][length]specifier，具体请参考 fprintf 函数<br/>
				arg：可变参数列表的对象<br/>
				返回值：成功返回字节数，失败返回负数<br/>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;stdarg.h><br/>
					FILE *fp;<br/>
					int printff(char *format,...){<br/>
						&nbsp; int n;<br/>
						&nbsp; va_list ap;<br/>
						&nbsp; va_start(ap,format);<br/>
						&nbsp; n = vfprintf(fp,format,ap);//保存到 fp 文件流中<br/>
						&nbsp; va_end(ap);<br/>
						&nbsp; return n;<br/>
					}<br/>
					int main(){<br/>
						&nbsp; fp=fopen("main.c","a+");<br/>
						&nbsp; if(fp == NULL){<br/>
							&nbsp; &nbsp; perror("open fail");<br/>
							&nbsp; &nbsp; return 0;<br/>
						&nbsp; }<br/>
						&nbsp; printff("this is project.");<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>long ftell(FILE *fp)：用于得到文件位置指针当前位置相对于文件首的偏移字节数。<br/>
				fp：文件标识符，可以是 fopen 打开的文件<br/>
				返回值：返回位置标识符的当前值。如果发生错误，则返回 -1L<br/>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					int main(){<br/>
						&nbsp; FILE *fp;<br/>
						&nbsp; char buff[1024];<br/>
						&nbsp; fp=fopen("socket_test.c","a+");<br/>
						&nbsp; if(fp == NULL){<br/>
							&nbsp; &nbsp; perror("open fail");<br/>
							&nbsp; &nbsp; return 0;<br/>
						&nbsp; }<br/>
						&nbsp; printf("file curret position is %ld\n",ftell(fp));<br/>
						&nbsp; fgets(buff,1024,fp);<br/>
						&nbsp; printf("file curret position is %ld\n",ftell(fp));<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int fseek(FILE *fp,long offset,int from)：设置 fp 的文件位置为给定的偏移 offset<br/>
				fp：文件标识符<br/>
				offset：相对 from 的偏移量，以字节为单位<br/>
				from：开始添加偏移 offset 的位置，值如下：<br/>
				&nbsp; SEEK_SET：文件的开头<br/>
				&nbsp; SEEK_CUR：文件指针的当前位置<br/>
				&nbsp; SEEK_END：文件的末尾<br/>
				返回值：成功返回 0，失败返回非 0<br/>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					int main(){<br/>
						&nbsp; FILE *fp;<br/>
						&nbsp; char buff[1024];<br/>
						&nbsp; fp=fopen("socket_test.c","r");<br/>
						&nbsp; fseek(fp,10,SEEK_SET);<br/>
						&nbsp; fgets(buff,1024,fp);<br/>
						&nbsp; printf("%s\n",buff);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li>stdin：c 标准输入流；<br/>
				stdout：c 标准输出流<br/>
				errno：错误，可使用 strerror(errno) 获取对应的错误输出</li>
			<li></li>
			</ol>
			</div><hr/>
		<div id="ctype">
			<h3>ctype.h</h3>
			<ol>
			<li>int toupper(int c)：把小写字母转换为大写字母<br/>
				c：字符<br/>
				返回值：如果 c 有相对应的大写字母，则该函数返回 c 的大写字母，否则 c 保持不变。<br/>
				举例：char a='c';printf("%c\n",toupper(a));</li>
			<li>int tolower(int c)：把给定的字母转换为小写字母<br/>
				c：字符<br/>
				返回值：如果 c 有相对应的小写字母，则该函数返回 c 的小写字母，否则 c 保持不变。<br/>
				举例：char a='C';printf("%c",tolower(a));</li>
			<li>int isxdigit(int c)：检查所传的字符是否是十六进制数字，十六进制一般用数字 0 到 9 和字母 A 到 F（或 a~f）<br/>
				c：传入的数值<br/>
				返回值：成功返回非 0，失败返回 0<br/>
				举例：int a='C';printf("%d\n",isxdigit(a));</li>
			<li>int isupper(int c)：检查所传的字符是否是大写字母<br/>
				c：字符<br/>
				返回值：成功返回非 0，失败返回 0<br/>
				举例：int a='C';printf("%d\n",isupper(a));</li>
			<li>int islower(int c)：检查所传的字符是否是小写字母<br/>
				c：字符<br/>
				返回值：成功返回非 0，失败返回 0<br/>
				举例：int a='c';printf("%d\n",islower(a));</li>
			<li>int isspace(int c)：检查所传的字符是否是空白字符<br/>
				c：字符<br/>
				返回值：成功返回非 0，失败返回 0<br/>
				空白字符包括：空格符' '、tab水平制表符'\t'、换行符'\n'、tab垂直制表符'\v'、换页符'\f'、回车符'\r'<br/>
				举例：int a=' ';printf("%d\n",isspace(a));</li>
			<li>int ispunct(int c)：检查所传的字符是否是标点符号字符<br/>
				c：字符<br/>
				返回值：成功返回非 0，失败返回 0<br/>
				举例：int a='.';printf("%d\n",ispunct(a));</li>
			<li>int isprint(int c)：检查所传的字符是否是可打印的<br/>
				c：字符<br/>
				返回值：成功返回非 0，失败返回 0<br/>
				举例：int a='.';printf("%d\n",isprint(a));</li>
			<li>int isgraph(int c)：检查所传的字符是否有图形表示法<br/>
				c：字符<br/>
				返回值：成功返回非 0，失败返回 0<br/>
				举例：int a='.';printf("%d\n",isgraph(a));</li>
			<li>int isdigit(int c)：检查所传的字符是否是十进制数字字符<br/>
				c：字符<br/>
				返回值：成功返回非 0，失败返回 0<br/>
				举例：int a='9';printf("%d\n",isdigit(a));</li>
			<li>int iscntrl(int c)：检查所传的字符是否是控制字符<br/>
				c：字符<br/>
				返回值：成功返回非 0，失败返回 0<br/>
				举例：int a='\t';printf("%d\n",iscntrl(a));</li>
			<li>int isalpha(int c)：检查所传的字符是否是字母<br/>
				c：字符<br/>
				返回值：成功返回非 0，失败返回 0<br/>
				举例：int a='t';printf("%d\n",isalpha(a));</li>
			<li>int isalnum(int c)：检查所传的字符是否是字母和数字<br/>
				c：字符<br/>
				返回值：成功返回非 0，失败返回 0<br/>
				举例：int a='t';printf("%d\n",isalnum(a));</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div id="time">
			<h3>time.h</h3>
			<ol>
			<li>int clock_gettime(clockid_t clk_id,struct timespec *tp)：可以根据需要，获取不同要求的精确时间（可以达到纳秒）。lock_gettime 比 gettimeofday 更加精确<br/>
				clk_id：
				<ul><li>CLOCK_MONOTONIC：从系统启动到这一刻起开始即使，不受系统时间被用户改变影响</li>
				<li>CLOCK_REALTIME：系统时钟时间，随系统实时时间改变而改变，从 1970/1/1,0:0:0 开始计时，中间时刻若系统时间被用户改成其他则对应时间相应改变</li>
				<li>CLOCK_PROCESS_CPUTIME_ID：本进程到当前代码系统 CPU 花费的时间</li>
				<li>CLOCK_THREAD_CPUTIME_ID：本线程到当前代码系统 CPU 花费的时间</li></ul>
				timespec：存储当前时间，秒和纳秒<br/>
				返回值：成功返回 0
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;time.h><br/>
					int main(){<br/>
						&nbsp; struct timespec time_value={0,0};<br/>
						&nbsp; int a=clock_gettime(CLOCK_MONOTONIC,&amp;time_value);<br/>
						&nbsp; printf("sec=%lu,nsec=%lu\n",time_value.tv_sec,time_value.tv_nsec);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int nanosleep(const struct timespec *req, struct timespec *rem)：暂停某个进程直到指定的时间后恢复。<br/>
				req：要暂停的时间，req->tv_sec 是以秒为单位，而 req->tv_nsec 以毫微秒为单位<br/>
				rem：剩余微秒时间<br/>
				返回值：成功返回 0，失败返回 -1，剩余微秒数纪录在 rem 中
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;time.h><br/>
					int main(){<br/>
						&nbsp; while(1)<br/>
						&nbsp; {<br/>
							&nbsp; &nbsp; struct timespec rem,req={5,600000};<br/>
							&nbsp; &nbsp; printf("process start...\n");<br/>
							&nbsp; &nbsp; nanosleep(&amp;req,&rem);<br/>
							&nbsp; &nbsp; printf("process ending...\n");<br/>
							&nbsp; &nbsp; break;<br/>
						&nbsp; }<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
				</li>
			<li>time_t time(time_t *timer)：返回自纪元（1970/1/1,00:00:00 UTC）起经过的时间，以秒为单位<br/>
				timer：time_t（为长整数别名）<br/>
				返回值：返回总秒数。
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;time.h><br/>
					int main(){<br/>
						&nbsp; time_t time_value;<br/>
						&nbsp; time_value=time(NULL);//NULL 表示从 1970-1-1 开始计时<br/>
						&nbsp; printf("%ld\n",time_value);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>struct tm *localtime(const time_t *timer)：使用 timer 的值来填充 tm 结构。timer 的值被分解为 tm 结构，并用本地时区表示。<br/>
				timer：指向表示日历时间的 time_t 值的指针。<br/>
				返回值：tm 结构指针<br/>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;time.h><br/>
					int main(){<br/>
						&nbsp; struct tm *tm_value;<br/>
						&nbsp; time_t alltime = time(NULL);<br/>
						&nbsp; tm_value = localtime(&amp;alltime);<br/>
						&nbsp; printf("%d-%d-%d,%d:%d:%d",tm_value->tm_year,tm_value->tm_mon,tm_value->tm_mday,tm_value->tm_hour,tm_value->tm_min,tm_value->tm_sec);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr)：格式化结构体 timeptr 表示的时间，并将值存储在 str 中。<br/>
				str：指向目标数组的指针<br/>
				maxsize：被复制到 str 最大字节数<br/>
				format：格式化字符串，包含了要被写入到字符串，具体格式化如下：<br/>
				<table border="1">
					<tr><th>格式化字符</th><th>描述</th><th>示例</th></tr>
					<tr><td>%a</td><td>缩写的星期</td><td>Sun</td></tr>
					<tr><td>%A</td><td>完整的星期</td><td>Sunday</td></tr>
					<tr><td>%b</td><td>缩写的月份</td><td>Mar</td></tr>
					<tr><td>%B</td><td>完整的月份</td><td>March</td></tr>
					<tr><td>%c</td><td>日期和时间表示法</td><td>Sun Aug 19 09:41:23 2021</td></tr>
					<tr><td>%C</td><td>年份的前 2 个数</td><td>21</td></tr>
					<tr><td>%d</td><td>一月中的第几天（01-31）</td><td>20</td></tr>
					<tr><td>%D</td><td>月/天/年</td><td>05/02/21</td></tr>
					<tr><td>%F</td><td>年-月-日</td><td>21-02-05</td></tr>
					<tr><td>%H</td><td>24小时个数的小时（00-23）</td><td>20</td></tr>
					<tr><td>%l</td><td>12小时个数的小时（01-12）</td><td>10</td></tr>
					<tr><td>%j</td><td>一年中的第几天（001-366）</td><td>100</td></tr>
					<tr><td>%m</td><td>十进制的月份（01-12）</td><td>10</td></tr>
					<tr><td>%M</td><td>分钟（00-59）</td><td>20</td></tr>
					<tr><td>%p</td><td>AM 或 PM 名称</td><td>PM</td></tr>
					<tr><td>%S</td><td>秒针（00-59）</td><td>20</td></tr>
					<tr><td>%U</td><td>一年中的第几周，以第一星期日作为第一周的第一天（00-53）</td><td>20</td></tr>
					<tr><td>%w</td><td>十进制的星期（0-6）</td><td>1</td></tr>
					<tr><td>%W</td><td>一年中的第几周，以第一星期一作为第一周的第一天（00-53）</td><td>20</td></tr>
					<tr><td>%x</td><td>日期表示法</td><td>21/02/05</td></tr>
					<tr><td>%X</td><td>时间表示法</td><td>08:49:32</td></tr>
					<tr><td>%y</td><td>年份（00-99）</td><td>21</td></tr>
					<tr><td>%Y</td><td>年份</td><td>2021</td></tr>
					<tr><td>%Z</td><td>时区名称或缩写</td><td>CDT</td></tr>
					<tr><td>%</td><td></td><td></td></tr>
				</table>
				timeptr：指向 tm 结构的指针<br/>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;time.h><br/>
					int main(){<br/>
						&nbsp; char buff[215];<br/>
						&nbsp; struct tm *tm_value;<br/>
						&nbsp; time_t alltime = time(NULL);<br/>
						&nbsp; tm_value = localtime(&amp;alltime);<br/>
						&nbsp; strftime(buff,215,"%F,%X",tm_value);<br/>
						&nbsp; printf("%s\n",buff);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>clock_t clock(void)：处理器时钟所使用时间，一般用于计时程序或程序某一段的执行时间<br/>
				返回值：时间，clock_t 是长整型<br/>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;time.h><br/>
					int main(){<br/>
						&nbsp; clock_t start,end;<br/>
						&nbsp; start=clock();<br/>
						&nbsp; for(int i=0;i<10000;i++)<br/>
							&nbsp; &nbsp; ;<br/>
						&nbsp; end=clock();<br/>
						&nbsp; printf("%ld",end-start);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>char *asctime(const struct tm *timeptr)：把 timeptr 指向的 tm 结构体中储存的时间转换为字符串<br/>
				timeptr：tm 结构体指针<br/>
				返回值：返回的字符串格式为：Www Mmm dd hh:mm:ss yyyy。其中Www为星期；Mmm为月份；dd为日；hh为时；mm为分；ss为秒；yyyy为年份。
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;time.h><br/>
					int main(){<br/>
						&nbsp; struct tm *tmvalue;<br/>
						&nbsp; time_t alltime = time(NULL);<br/>
						&nbsp; tmvalue = localtime(&amp;alltime);<br/>
						&nbsp; printf("%s",asctime(tmvalue));<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>char *ctime(const time_t *timer)： 把日期和时间转换为字符串<br/>
				timer：包含日历时间的 time_t 指针<br/>
				返回值：返回的字符串格式为：Www Mmm dd hh:mm:ss yyyy 其中，Www 表示星期几，Mmm 是以字母表示的月份，dd 表示一月中的第几天，hh:mm:ss 表示时间，yyyy 表示年份。<br/>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;time.h><br/>
					int main(){<br/>
						&nbsp; time_t curtime;<br/>
						&nbsp; time(&amp;curtime);<br/>
						&nbsp; printf("%s", ctime(&amp;curtime));<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>double difftime(time_t time1, time_t time2)：计算时间差<br/>
				time1：结束时间<br/>
				time2：开始时间<br/>
				返回值：两时间差（time1-time2），以秒为单位
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;time.h><br/>
					#include &lt;unistd.h><br/>
					int main(){<br/>
						&nbsp; time_t start_t, end_t;<br/>
						&nbsp; double diff_t;<br/>
						&nbsp; time(&amp;start_t);<br/>
						&nbsp; sleep(5);<br/>
						&nbsp; time(&amp;end_t);<br/>
						&nbsp; diff_t = difftime(end_t, start_t);<br/>
						&nbsp; printf("diff time is %f\n", diff_t);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form></li>
			<li>struct tm *gmtime(const time_t *timer)：把日期和时间转换成格林威治（GMT）时间<br/>
				timer：长整型<br/>
				返回值：返回转换后的 tm 结构的时间
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;time.h><br/>
					int main(){<br/>
						&nbsp; time_t curtime;<br/>
						&nbsp; struct tm *tmtime;<br/>
						&nbsp; time(&amp;curtime);<br/>
						&nbsp; tmtime = gmtime(&amp;curtime);<br/>
						&nbsp; printf("english:%2d:%02d\n",(tmtime->tm_hour+0)%24, tmtime->tm_min);<br/>
						&nbsp; printf("china:%2d:%02d\n", (tmtime->tm_hour+8)%24, tmtime->tm_min);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>time_t mktime(struct tm *timeptr)：将时间转换为自1970年1月1日以来持续时间的秒数<br/>
				timeptr：tm 结构体<br/>
				返回值：成功返回总秒数，失败返回 -1
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;time.h><br/>
					int main(){<br/>
						&nbsp; time_t curtime,alltime;<br/>
						&nbsp; struct tm *tmtime;<br/>
						&nbsp; time(&amp;curtime);<br/>
						&nbsp; printf("current is %ld\n",curtime);//本地时间（北京东八区+8）<br/>
						&nbsp; tmtime = gmtime(&amp;curtime);<br/>
						&nbsp; alltime=mktime(tmtime);<br/>
						&nbsp; printf("all time is %ld\n",alltime);//格林威治时间<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
			</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li>size_t：无符号整型；<br/>
				clock_t：长整型<br/>
				time_t：长整型<br/>
				tm：存储时间的结构体</li>
			<li>tm：<br/>
				struct tm {<br/>
					&nbsp; int tm_sec; //秒，范围从 0 到 59<br/>
					&nbsp; int tm_min; //分，范围从 0 到 59<br/>
					&nbsp; int tm_hour; //小时，范围从 0 到 23<br/>
					&nbsp; int tm_mday; //一月中的第几天，范围从 1 到 31<br/>
					&nbsp; int tm_mon; //月份，范围从 0 到 11<br/>
					&nbsp; int tm_year; //自 1900 起的年数<br/>
					&nbsp; int tm_wday; //一周中的第几天，范围从 0 到 6<br/>
					&nbsp; int tm_yday; //一年中的第几天，范围从 0 到 365<br/>
					&nbsp; int tm_isdst; //夏令时<br/>
				};</li>
			<li>timespec：<br/>
				struct timespec{<br/>
					&nbsp; __time_t tv_sec; /* Seconds.  */<br/>
					&nbsp; long int tv_nsec; /* Nanoseconds.  */<br/>
				};</li>
			<ol>
			</div><hr/>
		<div>
			<h3>stdarg.h</h3>
			<ol>
			<li>void va_start(va_list ap, last_arg)：初始化 ap 变量，它与 va_arg 和 va_end 宏是一起使用的。last_arg 是最后一个传递给函数的已知的固定参数，即省略号之前的参数。注意这个宏必须在使用 va_arg 和 va_end 之间被调用。</li>
			<li>type va_arg(va_list ap, type)：检索函数参数列表中类型为 type 的下一个参数。它无法判断检索到的参数是否是传给函数的最后一个参数。</li>
			<li>void va_end(va_list ap)：允许使用了 va_start 宏的带有可变参数的函数返回。如果在从函数返回之前没有调用 va_end，则结果为未定义。<br/>
				<form>
				<fieldset>
					<legend>** <b>整体实现</b> **</legend>
				#include &lt;iostream><br/>
				#include &lt;stdarg.h><br/>
				FILE fp;<br/>
				//和 printf 函数一致<br/>
				int printff(char *format,...){<br/>
					&nbsp; int n;<br/>
					&nbsp; va_list ap;<br/>
					&nbsp; va_start(ap,format);//获取可变参数列表第一个参数地址<br/>
					&nbsp; n = vprintf(format,ap);//使用参数列表发送格式化输出到标准输出<br/>
					&nbsp; va_end(ap);//清空va_list可变参数列表<br/>
					&nbsp; return n;<br/>
				}<br/>
				int sum(int num,...){<br/>
					&nbsp; int all=0;<br/>
					&nbsp; va_list ap;<br/>
					&nbsp; va_start(ap,num);<br/>
					&nbsp; for(int i=0;i &lt; num;i++){<br/>
						&nbsp; &nbsp; all += va_arg(ap,int);//获取可变参数的当前参数，返回指定类型并将指针指向下一个参数<br/>
					&nbsp; }<br/>
					&nbsp; va_end(ap);<br/>
					&nbsp; return all;<br/>
				}<br/>
				//打印到屏幕并输出到文件<br/>
				void log(const char *format,...){<br/>
					&nbsp; int p_file;<br/>
					&nbsp; va_list ap;<br/>
					&nbsp; va_start(ap,format);<br/>
					&nbsp; vprintf(format,ap);<br/>
					&nbsp; p_file=ftell(fp);//获取当前位置<br/>
					&nbsp; if(p_file>=1024*10)<br/>
						&nbsp; &nbsp; fseek(fp,0L,SEEK_SET);//将位置移到文件开头的起始位置；0L 为起始位置；100L 为离开头 100 字节位置<br/>
					&nbsp; vfprintf(fp,format,ap);<br/>
					&nbsp; va_end(ap);<br/>
				}<br/>
				int main(){<br/>
					&nbsp; printff("1-9 sum is %d\n",sum(10,0,1,2,3,4,5,6,7,8,9));<br/>
					&nbsp; fp=fopen("test.txt","a+");<br/>
					&nbsp; log("this is log0\n");<br/>
					&nbsp; log("this is log1\n");<br/>
					&nbsp; fclose(fp);<br/>
					&nbsp; fp=fopen("test.txt","a+");//若 a+ 改成 w，则会清空文件里的内容，重新写入<br/>
					&nbsp; log("this is log2\n");<br/>
					&nbsp; log("this is log3\n");<br/>
					&nbsp; fclose(fp);<br/>
					&nbsp; return 0;<br/>
				}</fieldset>
				</form>
				</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li>va_list：<br/>
			#ifdef _M_ALPHA<br/>
				&nbsp; typedef struct {<br/>
				&nbsp; char *a0; /* pointer to first homed integer argument */<br/>
				&nbsp; int offset; /* byte offset of next parameter */<br/>
			} va_list;<br/>
			#else<br/>
			typedef char * va_list;<br/>
			#endif</li>
			<ol>
			</div><hr/>
		<div>
			<h3>fcntl.h</h3>
			<ol>
			<li>int open(const char *pathname,int flags)/int open(const char *pathname, int flags, mode_t mode)：打开文件<br/>
				pathname：要打开或创建的目标文件，比如 /dev/ttyS0（即 COM1）<br/>
				flags：打开文件时，可以传入多个参数选项，用下面的一个或者多个常量进行“或”运算，构成 falgs
				<ul>
					<li>O_RDONLY：只读打开</li>
					<li>O_WRONLY：只写打开</li>
					<li>O_RDWR：读，写打开</li>
				</ul>
				上面三个常量，必须指定一个且只能指定一个
				<ul>
				<li>O_CREAT：若文件不存在，则创建它，需要使用 mode 选项。来指明新文件的访问权限</li>
				<li>O_APPEND：追加写，如果文件已经有内容，这次打开文件所写的数据附加到文件的末尾而不覆盖原来的内容</li>
				<li>O_NOCTTY：如果路径名指向终端设备，不要把这个设备用作控制终端</li>
				<li>O_NONBLOCK：如果路径名指向 FIFO/块文件/字符文件，则把文件的打开和后继 I/O 设置为非阻塞模式</li>
				<li>O_NDELAY：对于串口的打开操作，必须使用 O_NOCTTY 参数，它表示打开的是一个终端设备，程序不会成为该端口的控制终端。如果不使用此标志，任务的一个输入(比如键盘终止信号等)都会影响进程<br/>
					设置了 O_NDELAY 而当前不可写，那么 write 接口会设置 errno 为 EAGAIN，但是 write 接口会返回 0 而不是 -1</li>
				<li>O_TRUNC：如果文件存在，并且以只写/读写方式打开，则清空文件全部内容</li>
				<li>O_EXCL：如果要创建的文件已存在，则返回 -1，并且修改 errno 的值</li>
				<li>O_DSYNC：等待物理 I/O 结束后再 write。在不影响读取新写入的数据的前提下，不等待文件属性更新</li>
				<li>O_RSYNC：读(read)等待所有写入同一区域的写操作完成后再进行</li>
				<li>O_SYNC：等待物理 I/O 结束后再 write，包括更新文件属性的 I/O</li>
				</ul>
				返回值：成功返回新打开的文件描述符，失败返回 -1<br/>
				如目标文件存在，使用两个参数的 open，如果目标文件不存在，需要 open 创建，则第三个参数表示创建文件的默认权限<br/>
				打开的文件描述符一定要记得关闭，否则资源会被大量的占用，导致内存不够<br/>
				fopen 和 open 区别：以可写的方式 fopen 一个文件时，如果文件不存在则会自动创建，而 open 一个文件时必须明确 O_CREAT 才会创建文件，否则文件不存在就出错返回，并且 fopen 打开的是 FILE 文件流，open 打开的是 int
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;fcntl.h><br/>
					#include &lt;string.h><br/>
					#include &lt;unistd.h><br/>
					int main(){<br/>
						&nbsp; int fd=0;<br/>
						&nbsp; char buff[21];<br/>
						&nbsp; memset(buff,0,21);<br/>
						&nbsp; fd=open("./main.c",O_RDWR|O_APPEND);<br/>
						&nbsp; read(fd,buff,20);<br/>
						&nbsp; printf("%s\n",buff);<br/>
						&nbsp; write(fd,"hello,world\n",strlen("hello,world\n"));<br/>
						&nbsp; close(fd);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int fcntl(int fd, int cmd)/int fcntl(int fd, int cmd, long arg)/int fcntl(int fd, int cmd, struct flock *lock)：根据文件描述词来操作文件的特性<br/>
				fd：文件描述符<br/>
				cmd：命令参数
					<ul><li>F_DUPFD：复制一个现有的描述符，返回新的文件描述符，返回值具体描述：<br/>
						最小的大于或等于arg的一个可用的描述符<br/>
						与原始操作符一样的某对象的引用如果对象是文件(file)的话,返回一个新的描述符,这个描述符与arg共享相同的偏移量<br/>
						相同的访问模式(读,写或读/写)<br/>
						相同的文件状态标志(如:两个文件描述符共享相同的状态标志) </li>
					<li>F_GETFD/F_SETFD：获得/设置文件描述符标记，返回相应标志</li>
					<li>F_GETFL/F_SETFL：获得/设置文件状态标记，设置给 arg 描述状态标志。如：<br/>
						fcntl(fd,F_SETFL,0) //设置为阻塞<br/>
						fcntl(fd, F_SETFL, flags | O_NONBLOCK) //设置为非阻塞<br/>
						返回相应标志<br/>
						F_SETFL 设置给 arg 描述符状态标志,可以更改的几个标志是：O_APPEND， O_NONBLOCK，O_SYNC和O_ASYNC</li>
					<li>F_GETOWN/F_SETOWN：获得/设置异步 I/O 所有权，返回一个正的进程 ID 或负的进程组 ID</li>
					<li>F_GETLK/F_SETLK/F_SETLKW：获得/设置记录锁</li></ul>
				arg：状态标志
					<ul><li>O_RDONLY</li>
					<li>O_WRONLY</li>
					<li>O_RDWR</li>
					<li>O_APPEND：强制每次写(write)操作都添加在文件大的末尾</li>
					<li>O_NONBLOCK：非阻塞 I/O。如果 read 调用没有可读取的数据，或者如果 write 操作将阻塞，read 或 write 调用返回 -1 和 EAGAIN 错误</li>
					<li>O_SYNC</li>
					<li>O_ASYNC： 当 I/O 可用的时候，允许 SIGIO 信号发送到进程组，例如：当有数据可以读的时候</li></ul>
				lock：
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;unistd.h><br/>
					#include &lt;fcntl.h><br/>
					#include &lt;errno.h><br/>
					#include &lt;string.h><br/>
					#include &lt;stdlib.h><br/>
					#include &lt;stdio.h><br/>

					int main(void){<br/>
						&nbsp; char buf[10];<br/>
						&nbsp; int n;<br/>
						&nbsp; int flags;<br/>
						&nbsp; int i=0;<br/>
						&nbsp; flags = fcntl(STDIN_FILENO, F_GETFL);//获取当前 flags<br/>
						&nbsp; flags |= O_NONBLOCK;//设置新的 flags，非阻塞<br/>
						&nbsp; if (fcntl(STDIN_FILENO, F_SETFL, flags) == -1)//更新 flags<br/>
						&nbsp; {<br/>
							&nbsp; &nbsp; printf("fcntl error.\n");<br/>
							&nbsp; &nbsp; return 0;<br/>
						&nbsp; }<br/>
					tryagain:<br/>
						&nbsp; n = read(STDIN_FILENO, buf, 10);//读取标准输入的数据<br/>
						&nbsp; if (n &lt; 0)//读取失败<br/>
						&nbsp; {<br/>
							&nbsp; &nbsp; if (errno == EAGAIN)<br/>
							&nbsp; &nbsp; {<br/>
								&nbsp; &nbsp; &nbsp; if (i++ > 10)<br/>
									&nbsp; &nbsp; &nbsp; &nbsp; return 0;<br/>
								&nbsp; &nbsp; &nbsp; sleep(1);<br/>
								&nbsp; &nbsp; &nbsp; write(STDOUT_FILENO, "try again\n",strlen("try again\n"));<br/>
								&nbsp; &nbsp; &nbsp; goto tryagain;<br/>
							&nbsp; &nbsp; }<br/>
							&nbsp; &nbsp; printf("read stdin error.\n");<br/>
						&nbsp; }<br/>
						&nbsp; write(STDOUT_FILENO, buf, n);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li>struct flock{<br/>
				short int l_type; //锁定状态<br/>
				short int l_whence; //偏移量的起始位置<br/>
				off_t l_start; //锁定区域开头位置<br/>
				off_t l_len; //锁定区域的大小<br/>
				pid_t l_pid; //锁定动作的进程<br/>
				};<br/>
				l_type 取值有：1.F_RDLCK：建立一个供读取用的锁定（共享锁）；2.F_WRLCK：建立一个供写入用的锁定（互斥锁）；3.F_UNLCK：删除之前建立的锁定（解锁）<br/>
				l_whence 取值有：1.SEEK_SET 以文件开头为锁定的起始位置；2.SEEK_CUR：以目前文件读写位置为锁定的起始位置；3.SEEK_END：以文件结尾为锁定的起始位置<br/>
				l_start：相对 l_whence 位置的偏移量，两者一起确定锁定区域的开始位置<br/>
				l_len：锁定区域的长度，如果为 0 表示从起点(由 l_whence 和 l_start 决定的开始位置)开始直到最大可能偏移量为止。<br/>
				注意：为了锁整个文件，需要将 l_whence、l_start、l_len 都设置为0
			</li>
			<ol>
			</div><hr/>
		<div>
			<h3>unistd.h</h3>
			<ol>
			<li>int close(int fd)：关闭一个已经打开的文件/套接字，参数是需要关闭的文件描述符<br/>
				fd：文件描述符<br/>
				返回值：成功返回 0，失败返回 -1 并设置 errno
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;fcntl.h><br/>
					#include &lt;unistd.h><br/>
					int main(){<br/>
						&nbsp; int fd=0;<br/>
						&nbsp; fd=open("./main.c",O_RDWR|O_APPEND);<br/>
						&nbsp; close(fd);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form></li>
			<li>ssize_t write(int fd, const void *buf, size_t nbyte)：将 buf 数据写入 fd 指定的文件中<br/>
				fd：文件描述符；<br/>
				buf：指定的缓冲区，即指针，指向一段内存单元；<br/>
				nbyte：要写入文件指定的字节数；<br/>
				返回值：写入文档的字节数（成功）；-1（出错）
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;fcntl.h><br/>
					#include &lt;unistd.h><br/>
					int main(){<br/>
						&nbsp; int fd=0;<br/>
						&nbsp; fd=open("./main.c",O_RDWR|O_APPEND);<br/>
						&nbsp; write(fd,"hello,world\n",strlen("hello,world\n"));<br/>
						&nbsp; close(fd);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form></li>
			<li>ssize_t read(int fd, void *buf, size_t count)：将 fd 指定文件中的数据读取到 buf<br/>
				fd：文件描述符<br/>
				buf：缓冲区<br/>
				count：请求读取的字节数<br/>
				返回值：成功返回读取的字节数，失败返回 -1 并设置 errno，若在调用read前已到达文件末尾则返回 0
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;fcntl.h><br/>
					#include &lt;string.h><br/>
					#include &lt;unistd.h><br/>
					int main(){<br/>
						&nbsp; int fd=0;<br/>
						&nbsp; char buff[21];<br/>
						&nbsp; memset(buff,0,21);<br/>
						&nbsp; fd=open("./main.c",O_RDWR|O_APPEND);<br/>
						&nbsp; read(fd,buff,20);<br/>
						&nbsp; printf("%s\n",buff);<br/>
						&nbsp; close(fd);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int access(const char* pathname, int mode)：判断指定的文件或目录是否存在，已存在的文件或目录是否有可读/写/执行<br/>
				pathname：文件路径名，包括文件名<br/>
				mode：模式
				<ul><li>F_OK：值为0，判断文件是否存在</li>
					<li>X_OK：值为1，判断对文件是可执行权限</li>
					<li>W_OK：值为2，判断对文件是否有写权限</li>
					<li>R_OK：值为4，判断对文件是否有读权限</li></ul>
				返回值：成功为 0，失败为 -1
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;unistd.h><br/>
					int main(){<br/>
						&nbsp; int ok;<br/>
						&nbsp; ok = access("./main.c",0);<br/>
						&nbsp; if(ok == 0)<br/>
							&nbsp; &nbsp; printf("file ok\n");<br/>
						&nbsp; else<br/>
							&nbsp; &nbsp; printf("file error\n");<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>unsigned sleep(unsigned seconds)：执行挂起指定的秒数<br/>
				seconds：挂起时间，单位秒<br/>
				返回值：成功返回 0，失败返回剩余秒数<br/>
				sleep()是在库函数中实现的，它是通过alarm()来设定报警时间。具体例子请看 usleep 函数</li>
			<li>void usleep(int micro_seconds)：进程挂起指定的时间<br/>
				micro_seconds：挂起时间，单位微秒（1000000us=1s，1000us=1ms）<br/>
				返回值：成功返回 0，失败返回剩余秒数。
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;unistd.h><br/>
					int main(){<br/>
						&nbsp; printf("one\n");<br/>
						&nbsp; usleep(1000000);//微秒<br/>
						&nbsp; printf("two\n");<br/>
						&nbsp; usleep(1000);<br/>
						&nbsp; printf("three\n");<br/>
						&nbsp; usleep(5000000);<br/>
						&nbsp; printf("four\n");<br/>
						&nbsp; sleep(5);//秒<br/>
						&nbsp; printf("five\n");<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)：允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定时间后才唤醒。<br/>
				nfds：指定待测描述符 +1 个数<br/>
				readfds：select 监视的可读文件描述符集合，即是否可以从这些文件中读取数据了，如果这个集合中有一个文件可读，select 就会返回一个大于 0 的值<br/>
				writefds：select 监视的可写文件描述符集合<br/>
				exceptfds：监视的异常文件描述符集合<br/>
				timeout：select 超时时间，为 NULL 无限等待，仅在有描述符就绪或信号中断才返回（就绪条件：1.接收缓冲区 >= 接收缓冲区低水位标记的大小；2.接收到 FIN 的 TCP 连接；3.监听套接字并已完成的连接数不为0；4.套接字上有个错误待处理）；tv_sec=0 并且 tv_usec=0 不等待（轮询）检测描述符后立即返回<br/>
				返回值：当超时或其中一个/多个文件描述符发生变化时，此函数将返回，成功返回准备就绪的描述符个数，执行出错返回 -1，超时返回 0 并将时间结构体清空<br/>
				fd_set 类型的相关宏：<br/>
				&nbsp; FD_ZERO(fd_set *fdset)：清空 fdset 与所有文件描述符的联系<br/>
				&nbsp; FD_SET(int fd, fd_set *fdset)：建立文件描述符 fd 与 fdset 的联系<br/>
				&nbsp; FD_CLR(int fd, fd_set *fdset)：清除文件描述符 fd 与 fdset 的联系<br/>
				&nbsp; FD_ISSET(int fd, fd_set *fdset)：检查 fdset 联系的文件描述符 fd 是否被置位，返回 0 表示失败，非 0 表示成功<br/>
				原理如下：<br/><img src="./data/socket原理.jpg" alt="socket基本原理"/>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;unistd.h><br/>
					#include &lt;sys/time.h><br/>
					#include &lt;stdio.h><br/>
					#include &lt;string.h><br/>
					#include &lt;sys/ioctl.h><br/>
					#include &lt;fcntl.h><br/>

					#define RECV_AT_MAX_LEN 1024<br/>
					int main(void){<br/>
						&nbsp; struct timeval select_timeouts = {0, 1};<br/>
						&nbsp; fd_set readset;<br/>
						&nbsp; int n = 0 ,ret = 0;<br/>

						&nbsp; select_timeouts.tv_sec = 0;<br/>
						&nbsp; select_timeouts.tv_usec = 0;<br/>

						&nbsp; int fd = open("main.c",O_RDWR | O_NOCTTY | O_NDELAY);<br/>

						&nbsp; if (fd &lt; 0){<br/>
							&nbsp; &nbsp; printf("no this file\n");<br/>
						&nbsp; }else{<br/>
							&nbsp; &nbsp; ioctl(fd, (('R'&lt;&lt;8)|1|(0x4004&lt;&lt;16)), 0x400);<br/>
							&nbsp; &nbsp; ioctl(fd, (('R'&lt;&lt;8)|4|(0x4004&lt;&lt;16)), 0);//从设备驱动层读取数据<br/>
						
							&nbsp; &nbsp; FD_ZERO(&amp;readset);//清空 fdset 与所有文件描述符的联系<br/>
							&nbsp; &nbsp; FD_SET(fd, &amp;readset);//建立文件描述符 fd 与 readset 的联系<br/>
							&nbsp; &nbsp; ret = select(fd+1, &amp;readset, NULL, NULL, &amp;select_timeouts);<br/>

							&nbsp; &nbsp; if(ret > 0)<br/>
							&nbsp; &nbsp; {<br/>
								&nbsp; &nbsp; &nbsp; if(FD_ISSET(fd, &amp;readset))//检查 readset 联系的文件描述符 fd 是否被置位<br/>
								&nbsp; &nbsp; &nbsp; {<br/>
									&nbsp; &nbsp; &nbsp; &nbsp; char data[RECV_AT_MAX_LEN+1];<br/>
									&nbsp; &nbsp; &nbsp; &nbsp; memset(data,0,RECV_AT_MAX_LEN+1);<br/>
									&nbsp; &nbsp; &nbsp; &nbsp; n=read(fd,data,RECV_AT_MAX_LEN);<br/>
									&nbsp; &nbsp; &nbsp; &nbsp; if(n>0){<br/>
										&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("len:%d,data:%s",n,data);<br/>
										&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;<br/>
									&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
								&nbsp; &nbsp; &nbsp; }<br/>
							&nbsp; &nbsp; }<br/>
						&nbsp; }<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li>STDIN_FILENO：标准输入<br/>
				STDOUT_FILENO：标准输出<br/>
				STDERR_FILENO：标准错误<br/>
				对比 c 标准库中的标准输入输出错误 stdin、stdout、stderr<br/>
				使用 stdin 的函数主要有：fread、fwrite、fclose等；使用 STDIN_FILENO 的函数有：read、write、close等</li>
			<ol>
			</div><hr/>
		<div>
			<h3>string.h</h3>
			<ol>
			<li>char *strstr(const char *haystack, const char *needle)：在参 1 中查找第一次出现参 2 的位置，不包含终止符‘\0’<br/>
				haystack：要被检索的字符串<br/>
				needle：在第一个参数内搜索的字符<br/>
				返回值：成功返回参 2 第一次在参 1 中出现的位置，失败返回 null
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;string.h><br/>
					#include &lt;stdio.h><br/>
					int main(){<br/>
						&nbsp; char buff[15]="hello,world!";<br/>
						&nbsp; char *p;<br/>
						&nbsp; printf("%s\n",buff);<br/>
						&nbsp; p=strstr(buff,",");<br/>
						&nbsp; printf("%s\n",p);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>void *memset(void *s, int ch, size_t n)：将某一块内存中的内容全部设置为指定的值， 这个函数通常为新申请的内存做初始化工作。<br/>
				s：指向要填充的内存块<br/>
				ch：填充设置的值<br/>
				n：填充的字符数<br/>
				返回值：成功返回指向存储区s的指针
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;string.h><br/>

					int main(void){<br/>
						&nbsp; char data[]="hello,world";<br/>
						&nbsp; memset(data,0x35,sizeof(data));<br/>
						&nbsp; printf("data:%s\n",data);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>void *memcpy(void *dest, const void *src, size_t n)：从源内存地址的起始位置开始拷贝若干个字节到目标内存地址中<br/>
				dest：指向用于存储复制内容的目标数组，类型强制转换为 void* 指针<br/>
				src：指向要复制的数据源，类型强制转换为 void* 指针<br/>
				n：要被复制的字节数<br/>
				返回值：指向目标存储区的指针
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;string.h><br/>

					int main(void){<br/>
						&nbsp; char data[]="hello,world";<br/>
						&nbsp; memcpy(data,"hello,children",strlen("hello,children"));<br/>
						&nbsp; printf("data:%s\n",data);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>size_t strlen(const char *str)：计算字符串长度，直到碰到第一个字符串结束符'\0'为止<br/>
				str：要计算的字符串<br/>
				返回值：返回字符串长度，不包括结束符 NULL（‘\0’）
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;string.h><br/>

					int main(void){<br/>
						&nbsp; char data[]="hello,world";<br/>
						&nbsp; printf("len:%d\n", strlen("hello,children"));<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form></li>
			<li>int memcmp(const void *s1, const void *s2, size_t n)：把存储区 s1 和存储区 s2 的前 n 个字节进行比较（按字节比较 ascii 值）。<br/>
				s1：指向内存块的指针<br/>
				s2：指向内存块的指针<br/>
				n：要被比较的字节数<br/>
				返回值：s1&gt;s2 返回正数；s1&lt;s2 返回负数；s1=s2 返回 0
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;string.h><br/>

					int main(void){<br/>
						&nbsp; char a[]="hello,world",b[12]="hello,world";<br/>
						&nbsp; printf("memcmp1=%d\n",memcmp(a,b,11));<br/>
						&nbsp; printf("memcmp2=%d\n",memcmp(a,b,12));<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int strcmp(const char *s1, const char *s2)：比较两个字符串并根据比较结果返回整数。直到出现不同的字符或遇'\0'为止。<br/>
				s1：指向字符串的指针<br/>
				s2：指向字符串的指针<br/>
				返回值：s1&gt;s2 返回正数；s1&lt;s2 返回负数；s1=s2 返回 0
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;string.h><br/>
					int main(void){<br/>
						&nbsp; char a[]="hello,world",b[12]="hello,world";<br/>
						&nbsp; printf("strcmp=%d\n",strcmp(a,b));<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>void bzero(void *s, int n)：置字节字符串前 n 个字节为零且包括‘\0’。<br/>
				s：要置零的数据的起始地址<br/>
				n：要置零的数据字节个数
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;string.h><br/>
					int main(void){<br/>
						&nbsp; char a[]="hello,world",b[12]="hello,world";<br/>
						&nbsp; bzero(b,12);<br/>
						&nbsp; printf("strcmp=%d\n",strcmp(a,b));<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int strncmp(const char *s1, const char *s2, size_t n)：比较 s1 和 s2 的前 n 个字节<br/>
				s1：要比较的字符串<br/>
				s2：要比较的字符串<br/>
				n：要比较的长度<br/>
				返回值：s1&gt;s2 返回正数；s1&lt;s2 返回负数；s1=s2 返回 0
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;string.h><br/>
					int main(void){<br/>
						&nbsp; char a[]="hello,world",b[12]="hello,world";<br/>
						&nbsp; printf("strncmp=%d\n",strncmp(a,b,12));<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>char *strerror(int errnum)：通过标准错误的标号，获得错误的描述字符串 ，将单纯的错误标号转为字符串描述。<br/>
				errnum：最新的错误标号<br/>
				返回值：指向错误信息的指针
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;string.h><br/>
					#include &lt;errno.h><br/>
					int main(void){<br/>
						&nbsp; FILE *fp;<br/>
						&nbsp; fp=fopen("main0.c","r");<br/>
						&nbsp; if(fp==NULL)<br/>
							&nbsp; &nbsp; printf("error:%s\n",strerror(errno));<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>char *strcpy(char* dest, const char *src)：将 src 数据拷贝到 dest 里面<br/>
				src：要复制的数据<br/>
				dest：存储复制内容的数据
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;string.h><br/>
					int main(void){<br/>
						&nbsp; char a[]="hello",b[12]="hello,world";<br/>
						&nbsp; strcpy(a,b);<br/>
						&nbsp; printf("a:%s\n",a);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>char *strcat(char *dest, const char *src)：把 src 指向的字符串追加到 dest 指向的字符串结尾。<br/>
				dest：指向目标数组<br/>
				src：指向要追加的字符串<br/>
				返回值：返回一个指向最终目标字符串 dest 的指针
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;string.h><br/>
					int main(void){<br/>
						&nbsp; char a[]="hello",b[12]="hello,world";<br/>
						&nbsp; strcat(a,b);<br/>
						&nbsp; printf("a:%s\n",a);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>char *strncpy(char *dest, const char *src, size_t n)：把 src 所指向的字符串复制到 dest，最多复制 n 个字符<br/>
				dest：指向目标数组<br/>
				src：指向要追加的字符串<br/>
				n：要被拷贝的字节数<br/>
				返回值：
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;string.h><br/>
					int main(void){<br/>
						&nbsp; char a[]="hello",b[12]="hello,world";<br/>
						&nbsp; strncpy(a,b,7);<br/>
						&nbsp; printf("a:%s\n",a);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>char *strchr(const char *str, int c)：在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置<br/>
				str：要被检索的字符串<br/>
				c：在 str 中要搜索的字符<br/>
				返回值：返回一个指向该字符串中第一次出现的字符的指针，如果字符串中不包含该字符则返回NULL空指针
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;string.h><br/>
					int main(void){<br/>
						&nbsp; char a[12]="hello,world";<br/>
						&nbsp; char *b = strchr(a,',');<br/>
						&nbsp; printf("a:%s\nb:%s\n",a,b);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>stdlib.h</h3>
			<ol>
			<li>int system(const char *command)：把参数指定的命令名称或程序名称传给要被命令处理器（window下的dos，linux下的shell）执行的主机环境，并在命令完成后返回<br/>
				command：命令名<br/>
				返回值：成功返回 0，失败返回 -1<br/>
				比如 system("pause") 在 window 下是暂停 cmd 命令界面<br/>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdlib.h><br/>
					int main(){<br/>
						&nbsp; char buff[1024]="echo 1 > ./touch";//将 1 写入到此文件<br/>
						&nbsp; //char buff[1024]="ls";//打印当前目录里的文件或目录<br/>
						&nbsp; //char buff[1024]="./xx";//直接执行当前目录下的 xx 文件<br/>
						&nbsp; system(buff);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int atoi(const char *str)：把字符串转换成整型数（会跳过前面空白符）<br/>
				str：要转换成整数的字符串<br/>
				返回值：成功返回转换后的整数，失败或空字符返回 0<br/>
				举例：int a = atoi("123");</li>
			<li>void exit(int status)：立即终止进程<br/>
				status：返回给父进程的状态值<br/>
				举例：exit(0)正常退出；exit(x)异常退出（x 不为 0）</li>
			<li>void *malloc(size_t size)：分配动态内存空间<br/>
				size：内存块大小，以字节为单位<br/>
				返回值：成功返回一个指针，指向已分配大小的内存，失败返回 NULL<br/>
				举例：详见 free 函数</li>
			<li>void free(void *ptr)：释放调用 calloc、malloc 或 realloc 分配的内存空间<br/>
				ptr：指针指向一个要释放的内存块
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;stdlib.h><br/>
					#include &lt;string.h><br/>
					int main(void){<br/>
						&nbsp; char *a, *b;<br/>
						&nbsp; a = malloc(20);<br/>
						&nbsp; if(a == NULL){<br/>
							&nbsp; &nbsp; printf("malloc fail\n");<br/>
							&nbsp; &nbsp; return 0;<br/>
						&nbsp; }<br/>
						&nbsp; b = calloc(20, sizeof(char));<br/>
						&nbsp; if(b == NULL){<br/>
							&nbsp; &nbsp; printf("calloc fail\n");<br/>
							&nbsp; &nbsp; free(a);<br/>
							&nbsp; &nbsp; return 0;<br/>
						&nbsp; }<br/>
						&nbsp; memcpy(a, "01234567899876543210", 20);<br/>
						&nbsp; memcpy(b, "01234567899876543210", 20);<br/>
						&nbsp; printf("a:%s\nb:%s\n", a, b);<br/>
						&nbsp; a = realloc(a, 30);<br/>
						&nbsp; if(a == NULL){<br/>
							&nbsp; &nbsp; printf("calloc fail\n");<br/>
							&nbsp; &nbsp; free(a);<br/>
							&nbsp; &nbsp; free(b);<br/>
							&nbsp; &nbsp; return 0;<br/>
						&nbsp; }<br/>
						&nbsp; strcat(a, "0123456789");<br/>
						&nbsp; printf("a:%s\nb:%s\n", a, b);<br/>
						&nbsp; free(a);<br/>
						&nbsp; free(b);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>void *calloc(size_t nitems, size_t size)：动态分配内存空间<br/>
				nitems：要被分配的元素个数<br/>
				size：元素大小，一般可用 sizeof(元素的变量类型，如 int) 获取<br/>
				返回值：成功返回一个指针，指向已分配大小的内存，失败返回 NULL<br/>
				举例：详见 free 函数</li>
			<li>void *realloc(void *ptr, size_t size)：重新调整调用 malloc 或 calloc 分配的 ptr 所指向的内存块大小<br/>
				ptr：指针指向一个要重新分配内存的内存块，该内存块之前是通过调用 malloc、calloc 或 realloc 进行分配内存的。如果为空指针，则会分配一个新的内存块，且函数返回一个指向它的指针<br/>
				size：内存块新的大小，以字节为单位<br/>
				返回值：成功返回一个指针，指向重新分配大小的内存，失败返回 NULL<br/>
				举例：详见 free 函数</li>
			<li>void srand (usigned int see)：设置 rand() 产生随机数时的随机数种子<br/>
				see：整型，可使用 time(0)/time(NULL) 或 getpid(0) 的返回值作为此值<br/>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;stdlib.h><br/>
					#include &lt;time.h><br/>
					int main(void){<br/>
						&nbsp; srand(time(0));//随机种子<br/>
						&nbsp; int num = 0;<br/>
						&nbsp; for(int i=0; i&lt;5; i++){<br/>
							&nbsp; &nbsp; num = rand()%(100-50+1)+50;//取值范围，公式(n-m+1)+m，范围[m,n]<br/>
							&nbsp; &nbsp; printf("rand:%d\n", num);<br/>
						&nbsp; }<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int rand(void)：产生随机数，内部实现是用线性同余法实现的，是伪随机数，由于周期较长，因此在一定范围内可以看成是随机的<br/>
				返回值：0-RAND_MAX 之间的伪随机数<br/>
				注意：在调用 rand()函数之前，可以使用 srand()函数设置随机数种子，如果没有设置随机数种子，rand() 函数在调用时，自动设计随机数种子为 1。随机种子相同，每次产生的随机数也会相同
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;stdlib.h><br/>
					#include &lt;time.h><br/>
					int main(void){<br/>
						&nbsp; srand(1);//默认，程序每次启动值一样，需配合 rand，rand 返回值才是最终的随机值<br/>
						&nbsp; for(int i=0; i&lt;5; i++){<br/>
							&nbsp; &nbsp; printf("rand:%d\n", rand());<br/>
						&nbsp; }<br/>
						&nbsp; srand(time(0));//随机，两次 srand 设置时间不能小于1s，否则也会重复<br/>
						&nbsp; for(int i=0; i&lt;5; i++){<br/>
							&nbsp; &nbsp; printf("rand:%d\n", rand());<br/>
						&nbsp; }<br/>
						&nbsp; //时间短于1s，会和上面的重复<br/>
						&nbsp; srand(time(NULL));//随机，两次 srand 设置时间不能小于1s，否则也会重复<br/>
						&nbsp; for(int i=0; i&lt;5; i++){<br/>
							&nbsp; &nbsp; printf("rand:%d\n", rand());<br/>
						&nbsp; }<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li>RAND_MAX：随机值的最大值</li>
			<ol>
			</div><hr/>
		<div>
			<h3>sys/ioctl.h</h3>
			<ol>
			<li>int ioctl(int fd, ind cmd, …)：对设备的I/O通道进行管理的函数，驱动层函数。<br/>
				fd：文件描述符（由 socket 或 open 创建）<br/>
				cmd：用户程序对设备的控制命令<br/>
				...（省略号）：可变参数，一般最多一个，依赖 cmd 指定长度及类型<br/>
				返回值：成功返回 0，失败返回 -1 并设置 errorno<br/>
				cmd 格式：<br/><sub>----------------------------------------</sub><br/>
				| dir &nbsp;| size &nbsp;| type&nbsp;|&nbsp;nr &nbsp;|<br/>
				----------------------------------<br/>
				| 2 bit | 14 bit | 8 bit | 8 bit |<br/><sup>----------------------------------------</sup><br/>
				&nbsp; dir：命令访问模式，具体如下：<br/>
					&nbsp; &nbsp; 1._IOC_NONE：值为 0，无数据传输<br/>
					&nbsp; &nbsp; 2._IOC_READ：值为 1，从设备驱动读取数据<br/>
					&nbsp; &nbsp; 3._IOC_WRITE：值为 2，往设备驱动写入数据<br/>
					&nbsp; &nbsp; 4._IOC_READ | _IOC_WRITE：值为 3，双向数据传输<br/>
				&nbsp; size：指定可变参数的数据类型和长度，通常忽略该参数<br/>
				&nbsp; type：设备类型，魔幻数，可以为任意 char 字符<br/>
				&nbsp; nr：命令编号/序号，取值范围 0-255<br/>
				如下 linux 内核已定义 cmd，可直接传入 size、type、size 即可：<br/>
				&nbsp; _IO(type,nr) //没有参数的命令<br/>
				&nbsp; _IOR(type,nr,size) //该命令是从驱动读取数据<br/>
				&nbsp; _IOW(type,nr,size) //该命令是从驱动写入数据<br/>
				&nbsp; _IOWR(type,nr,size) //双向数据传输<br/>
				如下从命令中提取 cmd、type、size、nr：<br/>
				&nbsp; _IOC_DIR(cmd) //从命令中提取方向<br/>
				&nbsp; _IOC_TYPE(cmd) //从命令中提取幻数<br/>
				&nbsp; _IOC_NR(cmd) //从命令中提取序数<br/>
				&nbsp; _IOC_SIZE(cmd) //从命令中提取数据大小<br/>
				&nbsp; SIOCGIFADDR：获取 PA 地址<br/>
				可变参数：1.整数，如改变偏移量；2.指针，必须先检验指针的安全性（检验方式：1.需要使用的时候再检验；2.一开始就检验）<br/>
				作用：设备在运行的时候可能要求数据的写入是连续的，如果这个时候仍然用WRITE函数去写指令的话，就有可能导致数据的不连续，比如声卡放音乐卡顿，电影播放不流畅等等的情况，为了解决这种情况，就有了IOCTL函数，此函数专门向驱动层发送或者接收指令。
				<form>
				<fieldset>
					<legend>** <b>获取 IP</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;string.h><br/>
					#include &lt;errno.h><br/>
					#include &lt;sys/socket.h><br/>
					#include &lt;sys/ioctl.h><br/>
					#include &lt;unistd.h><br/>
					#include &lt;net/if.h><br/>
					#include &lt;arpa/inet.h><br/>
					int main(void){<br/>
						&nbsp; struct ifreq ifr;<br/>

						&nbsp; int s=socket(AF_INET,SOCK_DGRAM,0);<br/>
						&nbsp; if(s == -1){<br/>
							&nbsp; &nbsp; printf("error: %s\n", strerror(errno));<br/>
						&nbsp; }<br/>
						&nbsp; strncpy(ifr.ifr_name, "lo", IFNAMSIZ);<br/>
						&nbsp; ifr.ifr_name[IFNAMSIZ - 1] = 0;<br/>
						  
						&nbsp; if (ioctl(s, SIOCGIFADDR, &ifr) &lt; 0){<br/>
							&nbsp; &nbsp; //若找不到设备，可使用 ifconfig 命令在 linux 命令行中查询具体有那些设备<br/>
							&nbsp; &nbsp; printf("ioctl error: %s\n", strerror(errno));<br/>
							&nbsp; &nbsp; close(s);<br/>
							&nbsp; &nbsp; return 0;<br/>
						&nbsp; }<br/>
						&nbsp; printf("ip:%s\n",inet_ntoa(((struct sockaddr_in*)&amp;(ifr.ifr_addr))->sin_addr));<br/>
						&nbsp; close(s);<br/>
						&nbsp; return 0;<br/>
					}
					</fieldset>
				</form>
				<form>
				<fieldset>
					<legend>** <b>写入 文件 或 串口设备</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;sys/ioctl.h><br/>
					#include &lt;string.h><br/>
					#include &lt;fcntl.h><br/>
					#include &lt;unistd.h><br/>
					int main(){<br/>
						&nbsp; int fd;<br/>
						&nbsp; fd=open("./test.txt",O_RDWR | O_NOCTTY | O_NDELAY);//串口使用 /dev/ttyS0<br/>
						&nbsp; if(fd < 0)<br/>
						&nbsp; {<br/>
							&nbsp; &nbsp; printf("file error.\n");<br/>
							&nbsp; &nbsp; return 0;<br/>
						&nbsp; }<br/>
					/* R 值为 0x52，即 0101 0010，左移 8 bit<br/>
					0101 0010 0000 0000<br/>
					位与 1<br/>
					0101 0010 0000 0001<br/>
					位与（0x4004 左移 16 bit）<br/>
					0100 0000 0000 0100 0101 0010 0000 0001<br/>
					01（1） 是dir；后面 14bit（4） 是 size；之后 8bit（R） 是 type；最后 8bit（1） 是 nr*/<br/>
						&nbsp; ioctl(fd,(('R'<<8)|1|(0x4004<<16)),0);<br/>
						&nbsp; write(fd,"ATI\r\n",strlen("ATI\r\n"));<br/>
						&nbsp; close(fd);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li>SIOCGIFADDR：</li>
			<ol>
			</div><hr/>
		<div>
			<h3>pthread.h</h3>
			<ol>
			<li>int pthread_create(pthread_t *restrict tidp,const pthread_attr_t *restrict_attr,void*（*start_rtn)(void*),void *restrict arg)：创建线程。<br/>
				tidp：指向线程标识符的指针，线程 id<br/>
				restrict_attr：设置线程属性<br/>
				void*（*start_rtn)(void*)：线程运行函数的起始地址<br/>
				arg：运行函数的参数，若不止一个参数，则需要将全部参数放入结构体中<br/>
				返回值：成功为 0，失败返回 -1 并设置 errorno 值<br/>
				注意：由于 pthread 非默认库，需要在末尾加上 -lpthread 以调用静态链接库，如 gcc -o aa ./main.c -lpthread<br/>
				举例：详见 pthread_cond_signal 函数</li>
			<li>int pthread_mutex_destroy(pthread_mutex_t *mutex)：销毁互斥锁<br/>
				mutex：指向要销毁的互斥锁的指针<br/>
				返回值：成功返回 0，失败返回错误码<br/>
				举例：详见 pthread_cond_signal 函数</li>
			<li>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr)：初始化互斥锁<br/>
				mutex：指向要初始化的互斥锁的指针<br/>
				attr：指向属性对象的指针，为 NULL 则使用默认的属性<br/>
				成功返回 0，失败返回错误码<br/>
				举例：详见 pthread_cond_signal 函数</li>
			<li>int pthread_cond_destroy(pthread_cond_t *cond)：销毁条件变量<br/>
				cond：指向 pthread_cond_t 结构的指针<br/>
				返回值：函数成功返回0；否则错误<br/>
				注意：只有在没有线程在该条件变量上等待时才能注销此条件变量，否则返回 EBUSY<br/>
				举例：详见 pthread_cond_signal 函数</li>
			<li>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr)：初始化条件变量（动态创建）<br/>
				cond：条件变量<br/>
				attr：一般为 NULL<br/>
				返回值：函数成功返回0；否则错误<br/>
				注意：1.此为动态创建，静态创建为 pthread_cond_t cond=PTHREAD_COND_INITIALIZER//宏为常量；2.使用 pthread_mutex_destroy 注销条件变量；3.一般 attr 值为 NULL<br/>
				举例：详见 pthread_cond_signal 函数</li>
			<li>int pthread_mutex_lock(pthread_mutex_t *mutex)：互斥锁上锁<br/>
				mutex：互斥对象<br/>
				返回值：成功返回 0，失败返回非 0 值<br/>
				注意：此函数和 pthread_mutex_unlock 成对出现<br/>
				举例：详见 pthread_cond_signal 函数</li>
			<li>int pthread_mutex_unlock(pthread_mutex_t *mutex)：互斥锁解锁<br/>
				mutex：互斥对象<br/>
				返回值：成功返回 0，失败返回非 0 值<br/>
				举例：详见 pthread_cond_signal 函数</li>
			<li>int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)：无条件等待<br/>
				注意：必须放在 pthread_mutex_lock 和 pthread_mutex_unlock 之间<br/>
				举例：详见 pthread_cond_signal 函数</li>
			<li>int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime)：计时等待<br/>
				abstime：与 time() 系统调用相同意义的绝对时间形式出现，0 表示格林尼治时间 1970 年 1 月 1 日 0 时 0 分 0 秒<br/>
				返回值：倒是未满足条件则返回 ETIMEOUT 结束等待<br/>
				注意：必须和一个互斥锁配合，以防止多个线程同时请求 pthread_cond_wait()（或 pthread_cond_timedwait()）的竞争条件。mutex 互斥锁必须是普通锁（PTHREAD_MUTEX_TIMED_NP）或者适应锁（PTHREAD_MUTEX_ADAPTIVE_NP），且在调用 pthread_cond_wait() 前必须由本线程加锁。</li>
			<li>pthread_cond_signal(pthread_cond_t *cond)：发送一个信号给另外一个正在处于阻塞等待状态的线程，使其脱离阻塞状态，继续执行<br/>
				返回值：如果没有线程处在阻塞等待状态，pthread_cond_signal 也会成功返回<br/>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
						#include &lt;stdio.h><br/>
						#include &lt;pthread.h><br/>
						#include &lt;unistd.h><br/>
						#include &lt;string.h><br/>
						#include &lt;errno.h><br/>
						#include &lt;fcntl.h><br/>
						pthread_mutex_t mux_data;<br/>
						pthread_cond_t cond_ready;<br/>
						int fd;<br/>
						char exit_flag;<br/>
						void recvmsgdata(void){<br/>
							&nbsp; char stMsg[1024]={0};<br/>
							&nbsp; int count = 0;<br/>
							&nbsp; pthread_mutex_init(&amp;mux_data, NULL);//互斥锁初始化<br/>
							&nbsp; pthread_cond_init(&amp;cond_ready, NULL);//信号量初始化<br/>
							&nbsp; while(1){<br/>
								&nbsp; &nbsp; pthread_mutex_lock(&amp;mux_data);//获取锁<br/>
								&nbsp; &nbsp; while((read(fd, stMsg, 1024)) &lt; 0)//获取数据<br/>
								&nbsp; &nbsp; {<br/>
									&nbsp; &nbsp; &nbsp; pthread_cond_wait(&amp;cond_ready, &amp;mux_data);//等待信号到来，必须处于获取和释放锁之间<br/>
								&nbsp; &nbsp; }<br/>
								&nbsp; &nbsp; //有数据了<br/>
								&nbsp; &nbsp; printf("get data:%s\n", stMsg);<br/>
								&nbsp; &nbsp; pthread_mutex_unlock(&amp;mux_data);//释放锁<br/>
								&nbsp; &nbsp; if((count++) > 100){<br/>
									&nbsp; &nbsp; &nbsp; exit_flag = 1;<br/>
									&nbsp; &nbsp; &nbsp; break;//退出<br/>
								&nbsp; &nbsp; }<br/>
							&nbsp; }<br/>
						}<br/>
						void sendmsgdata(void){<br/>
							&nbsp; int count = 0;<br/>
							&nbsp; char stMsg[1024]={0};<br/>
							&nbsp; while(1){<br/>
								&nbsp; &nbsp; pthread_mutex_lock(&amp;mux_data);<br/>
								&nbsp; &nbsp; sprintf(stMsg, "count:%d\n", count++);<br/>
								&nbsp; &nbsp; write(fd, stMsg, strlen(stMsg));//写入数据<br/>
								&nbsp; &nbsp; pthread_cond_signal(&amp;cond_ready);//通知信号到来<br/>
								&nbsp; &nbsp; pthread_mutex_unlock(&amp;mux_data);<br/>
								
								&nbsp; &nbsp; if(count>100){<br/>
									&nbsp; &nbsp; &nbsp; exit_flag = 1;<br/>
									&nbsp; &nbsp; &nbsp; break;<br/>
								&nbsp; &nbsp; }<br/>
							&nbsp; }<br/>
						}<br/>
						int main(void){<br/>
							&nbsp; int ret = 0;<br/>
							&nbsp; pthread_t recv_id,send_id;<br/>
							&nbsp; fd= open( "test.txt", O_RDWR|O_NOCTTY );<br/>
							&nbsp; if(fd==-1){<br/>
								&nbsp; &nbsp; printf("file error:%s\n",strerror(errno));<br/>
								&nbsp; &nbsp; return 0;<br/>
							&nbsp; }<br/>
							
							&nbsp; ret = pthread_create(&amp;recv_id, NULL, (void *)recvmsgdata, NULL);<br/>
							&nbsp; if(ret!=0){<br/>
								&nbsp; &nbsp; printf("recv pthread error:%s\n",strerror(errno));<br/>
								&nbsp; &nbsp; return 0;<br/>
							&nbsp; }<br/>
							&nbsp; usleep(20000);<br/>

							&nbsp; ret = pthread_create(&amp;send_id, NULL, (void *)sendmsgdata, NULL);<br/>
							&nbsp; if(ret!=0){<br/>
								&nbsp; &nbsp; printf("send pthread error:%s\n",strerror(errno));<br/>
								&nbsp; &nbsp; return 0;<br/>
							&nbsp; }<br/>
							&nbsp; usleep(200000);<br/>
							
							&nbsp; while(1){<br/>
								&nbsp; &nbsp; if(exit_flag){<br/>
									&nbsp; &nbsp; &nbsp; pthread_mutex_destroy(&amp;mux_data);//销毁互斥锁<br/>
									&nbsp; &nbsp; &nbsp; pthread_cond_destroy(&amp;cond_ready);//销毁信号量<br/>
									&nbsp; &nbsp; &nbsp; printf("exit main\n");<br/>
									&nbsp; &nbsp; &nbsp; break;<br/>
								&nbsp; &nbsp; }<br/>
							}<br/>
							return 0;<br/>
						}
					</fieldset>
				</form>
				</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>sys/socket.h</h3>
			<ol>
			<li>int socket(int af, int type, int protocol)：创建套接字。<br/>
				af：地址族（AF_INET；AF_INET6）<br/>
				type：数据传输方式或套接字类型（SOCK_STREAM：TCP连接；SOCK_DGRAM：UDP连接）<br/>
				protocol：传输协议（IPPROTO_TCP：TCP；IPPROTO_UDP：UDP，在头文件 netinet/in.h 里面），一般设置为 0<br/>
				返回值：成功返回套接字描述符，失败返回 -1<br/>
				举例：详见 TCP Client 例子</li>
			<li>int bind(int s,struct sockaddr *addr, int addrlen)：服务器绑定端口信息<br/>
				s：socket 描述符<br/>
				addr：sockaddr 结构体，服务器参数<br/>
				addrlen：大小，可使用 sizeof 获取<br/>
				返回值：成功返回 0，失败返回 -1<br/>
				举例：详见 TCP Server 例子</li>
			<li>int listen(int s， int backlog)：服务器端监听连接<br/>
				s：socket 描述符<br/>
				返回值：成功返回 0，失败返回 -1<br/>
				举例：请看 bind 函数<br/>
				举例：详见 TCP Server 例子</li>
			<li>int accept(int s, void *addr, int *addrlen)：服务器端连接请求<br/>
				s：socket 描述符<br/>
				addr：目标地址信息<br/>
				addrlen：目标地址长度<br/>
				返回值：成功返回已连接的 socket 描述符，失败返回 -1<br/>
				举例：请看 bind 函数<br/>
				举例：详见 TCP Server 例子</li>
			<li>int connect(int s, struct sockaddr *addr,int addrlen)：建立连接<br/>
				s：socket 描述符<br/>
				addr：目标地址信息<br/>
				addrlen：目标地址长度<br/>
				返回值：成功返回 0，失败返回 -1<br/>
				举例：详见 TCP Client 例子</li>
			<li>int sendto(int s, const void *buf, int len, unsigned int flags, const struct sockaddr *to, int tolen)：UDP 发送数据<br/>
				s：socket 描述符<br/>
				buf：数据报缓存地址<br/>
				len：数据报长度<br/>
				flags：该参数一般为0<br/>
				to：struct sockaddr_in 类型，指明目标 ip 信息<br/>
				tolen：对方地址长度，一般为：sizeof(struct sockaddr_in)<br/>
				返回值：成功返回发送的字节数，失败返回 -1，错误原因在 errno 中<br/>
				举例：详见 UDP Server 例子</li>
			<li>int recvfrom(int s, void *buf, int len, unsigned int flags, struct sockaddr *from, int *fromlen)：UDP 接收数据<br/>
				s：socket 描述符<br/>
				buf：数据报缓存地址<br/>
				len：数据报长度<br/>
				flags：该参数一般为0<br/>
				<ul><li>MSG_DONTWAIT：操作不会被阻塞</li>
				<li>MSG_PEEK：指示数据接收后，在接收队列中保留原数据，不将其删除，随后的读操作还可以接收相同的数据</li>
				<li>MSG_TRUNC：返回封包的实际长度，即使它比所提供的缓冲区更长， 只对 packet 套接字有效</li>
				<li>MSG_WAITALL：要求阻塞操作，直到请求得到完整的满足</li>
				<li>MSG_EOR：指示记录的结束，返回的数据完成一个记录</li>
				<li>MSG_TRUNC：指明数据报尾部数据已被丢弃，因为它比所提供的缓冲区需要更多的空间</li>
				<li>MSG_CTRUNC：指明由于缓冲区空间不足，一些控制数据已被丢弃</li></ul>
				from：struct sockaddr_in 类型，指明目标 ip 信息<br/>
				fromlen：对方地址长度，一般为：sizeof(struct sockaddr_in)<br/>
				返回值：成功返回接收的字节数，失败返回 -1，错误原因在 errno 中<br/>
				举例：详见 UDP Server 例子</li>
			<li>int send(int s, const void *buf, int len, int flags)：TCP 发送数据<br/>
				s：socket 描述符<br/>
				buf：发送数据的缓冲区<br/>
				len：数据长度<br/>
				flags：该参数一般为 0
				<ul><li>MSG_NOSIGNAL：禁止 send 向系统发送消息（注意：linux 下当连接断开但还发数据时，send 函数会有反应并向系统发送一个异常消息，而不做处理系统会出 BrokePipe 导致程序退出）</li>
				</ul>
				返回值：成功返回发送的字节数，失败返回 -1，错误原因在 errno 中<br/>
				举例：详见 TCP Server 例子</li>
			<li>int recv(int s,void *buf,int len,unsigned int flags)：TCP 接收数据<br/>
				s：socket 描述符<br/>
				buf：接收数据的缓冲区<br/>
				len：数据长度<br/>
				flags：该参数一般为 0<br/>
				返回值：成功返回发送的字节数，失败返回 -1，错误原因在 errno 中<br/>
				举例：详见 TCP Server 例子</li>
			<li>int shutdown(int s,int howto)：禁止在一个套接口上进行数据的接收与发送。之后再使用 close 关闭套接字。<br/>
				s：socket 描述符<br/>
				howto：断开方式
				<ul><li>SHUT_RD：断开输入流。套接字无法接收数据（即使输入缓冲区收到数据也被抹去），无法调用输入相关函数</li>
				<li>SHUT_WR：断开输出流。套接字无法发送数据，但如果输出缓冲区中还有未传输的数据，则将传递到目标主机</li>
				<li>SHUT_RDWR：同时断开 I/O 流。相当于分两次调用 shutdown()，其中一次以 SHUT_RD 为参数，另一次以 SHUT_WR 为参数</li>
				</ul>
				返回值：成功返回 0，失败返回 -1<br/>
				举例：详见 TCP Client 例子</li>
			<li>int getsockname(int s,struct sockaddr* localaddr,socklen_t *addrlen)：获取一个已捆绑或已连接的套接字的名字，即服务器端可通过它获取相关客户端地址（accept 之后），而客户端可通过它得到当前已连接成功的服务器地址（connect 之后）<br/>
				s：socket 描述符，此为已捆绑或已连接的套接字<br/>
				localaddr：接收套接口的地址（名字），本地协议地址<br/>
				addrlen：地址缓冲区长度<br/>
				返回值：成功返回 0，失败返回 SOCKET_ERROR<br/>
				注意：TCP 连接不进行 bind 指定 ip 和端口时只有在调用 connect 连接成功后此函数才会正确获取当前正在通信的 IP 和端口；而 UDP 始终无法获取到正确 IP （为 0），端口正确。<br/>
				getpeername 和 getsockname 比较：<br/>
				&nbsp; （令服务器为 127.0.0.1:10000，客户端无）<br/>
				&nbsp; 客户端 connect 之后：getpeername -> 127.0.0.1:10000；getsockname -> 127.0.0.1:4983<br/>
				&nbsp; 服务器端 accept 之后：getpeername -> 127.0.0.1:4983；getsockname -> 127.0.0.1:10000<br/>
				举例：详见 TCP Client 例子</li>
			<li>int getpeername(int s, struct sockaddr *peeraddr, socklen_t *addrlen)：获取与套接口相连的端地址，accept 成功后，获取当前连接的客户端的 IP 地址和端口号<br/>
				peeraddr：外地协议地址<br/>
				返回值：成功返回 0，失败返回 -1<br/>
				注意：虽然 accept 之后就已经可以获取到地址了，但是此函数随时可用，多个客户端时尤为重要<br/>
				举例：详见 TCP Client 例子</li>
			<li>int getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)：获取一个套接口选项。<br/>
				s：套接字描述符<br/>
				level：协议层次
					<ul><li>SOL_SOCKET：套接字层</li>
					<li>IPPROTO_IP：ip 层</li>
					<li>IPPROTO_TCP：tcp 层</li></ul>
				optname：选项名称
					<ul>
					<li>SO_ACCEPTCONN：套接字是否处于监听模式（SOL_SOCKET）</li>
					<li>SO_BROADCAST：是否允许发送广播信息（SOL_SOCKET）</li>
					<li>SO_CONNECT_TIME：返回套接字建立连接的时间，以秒为单位，如尚未连接，返回0xffffffff（SOL_SOCKET）</li>
					<li>SO_DEBUG：是否允许调试（SOL_SOCKET）</li>
					<li>SO_REUSEADDR：是否允许重复使用本地地址</li>
					<li>SO_DONTROUTE：不查找路由（SOL_SOCKET）</li>
					<li>SO_ERROR：获得套接字错误（SOL_SOCKET）</li>
					<li>SO_KEEPALIVE：保持连接（SOL_SOCKET）</li>
					<li>SO_LINGER：延迟关闭连接（SOL_SOCKET）</li>
					<li>SO_OOBINLINE：带外数据放入正常数据流（SOL_SOCKET）</li>
					<li>SO_RCVBUF：接收缓冲区大小（SOL_SOCKET），对于客户端，SO_RCVBUF选项必须在connect之前设置；对于服务器，SO_RCVBUF选项必须在listen前设置。</li>
					<li>SO_SNDBUF：发送缓冲区大小（SOL_SOCKET）</li>
					<li>SO_RCVLOWAT：接收缓冲区下限（SOL_SOCKET）</li>
					<li>SO_SNDLOWAT：发送缓冲区下限（SOL_SOCKET）</li>
					<li>SO_RCVTIMEO：接收超时（SOL_SOCKET）</li>
					<li>SO_SNDTIMEO：发送超时（SOL_SOCKET）</li>
					<li>SO_REUSERADDR：允许重用本地地址和端口（SOL_SOCKET）</li>
					<li>SO_TYPE：获得套接字类型（SOL_SOCKET）</li>
					<li>SO_BSDCOMPAT：与BSD系统兼容（SOL_SOCKET）</li>
					<li>IP_HDRINCL：在数据包中包含IP首部（IPPROTO_IP）</li>
					<li>IP_OPTINOS：IP首部选项（IPPROTO_IP）</li>
					<li>IP_TOS：服务类型（IPPROTO_IP）</li>
					<li>IP_TTL：生存时间（IPPROTO_IP）</li>
					<li>TCP_MAXSEG：TCP最大数据段的大小（IPPROTO_TCP）</li>
					<li>TCP_NODELAY：不使用Nagle算法（IPPROTO_TCP）</li>
					<li>TCP_INFO：查看当前 TCP 信息（IPPROTO_TCP）</li></ul>
				optval：选项值，optname 获取的返回值<br/>
				optlen：选项值长度<br/>
				返回值：成功为 0，失败为 -1 并设置 errno<br/>
				errno 值如下
				<ul><li>EBADF：s 描述符无效；</li>
					<li>EFAULT：optval 指向内存是无效进程空间</li>
					<li>EINVAL：在调用 setsockopt() 时，optlen 无效</li>
					<li>ENOPROTOOPT：指定的协议层不能识别选项</li>
					<li>ENOTSOCK：sock描述的不是套接字</li>
					</ul>
				当 level 为 IPPROTO_TCP，optname 为 TCP_INFO，时，optval 的值可获取当前 TCP 连接状态，如 ooptval 值为 tcp_info sock_info 时，sock_info.tcpi_state 获取的就是状态，可为 TCP_ESTABLISHED（已建立连接）<br/>
				SO_RCVTIMEO/SO_SNDTIMEO 会导致 read/write 函数返回 EAGAIN（即 errno == EAGAIN）<br/>
				举例：详见 TCP Client 例子</li>
			<li>int setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)：设置套接字选项<br/>
				参数：和上面 getsockopt 获取套接字选项类似<br/>
				返回值：成功返回 0，失败返回 -1<br/>
				举例：详见 TCP Client 例子</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li>
			<form>
			<fieldset>
				<legend>** <b>TCP Client 举例</b> **</legend>
				#include &lt;stdio.h><br/>
				#include &lt;sys/socket.h><br/>
				#include &lt;arpa/inet.h><br/>
				#include &lt;string.h><br/>
				#include &lt;unistd.h><br/>
				#include &lt;netinet/tcp.h><br/>
				int main(void){<br/>
					&nbsp; char buff[1024];<br/>
					&nbsp; int len, buff_len, connect_flag;<br/>
					&nbsp; //keepAlive：保活开关；keepIdle：连接在60s无数据来往则进行探测；keepInterval：探测是发包时间间隔；keepCount：探测尝试次数。设置后若断开则 socket 读写时立即失败并返回 ETIMEDOUT 错误
					&nbsp; int keepAlive=1, keepIdle=60, keepInterval=5, keepCount=9, ch_opt=1;<br/>
					&nbsp; struct timeval timeout_recv = {60, 0};<br/>
					&nbsp; struct sockaddr_in s_add;<br/>
					&nbsp; struct hostent *hptr;<br/>
					&nbsp; struct tcp_info s_info;<br/>
						
					&nbsp; int s=socket(AF_INET, SOCK_STREAM, 0);<br/>
					&nbsp; if(s==-1){<br/>
						&nbsp; &nbsp; printf("socket creat fail\n");<br/>
						&nbsp; &nbsp; return 0;<br/>
					&nbsp; }<br/>
					&nbsp; //设置套接字选项<br/>
					&nbsp; setsockopt(s, 1, 9, (void *)&amp;keepAlive, sizeof(keepAlive));<br/>
					&nbsp; setsockopt(s, 6, 4, (void*)&amp;keepIdle, sizeof(keepIdle));<br/>
					&nbsp; setsockopt(s, 6, 5, (void *)&amp;keepInterval, sizeof(keepInterval));<br/>
					&nbsp; setsockopt(s, 6, 6, (void *)&amp;keepCount, sizeof(keepCount));<br/>
					&nbsp; setsockopt(s, IPPROTO_TCP, TCP_NODELAY, (void *)&amp;ch_opt, sizeof(ch_opt));<br/>
					&nbsp; setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, (char *)&amp;timeout_recv, sizeof(struct timeval));<br/>
					&nbsp; //服务器参数<br/>
					&nbsp; bzero(&amp;s_add,sizeof(struct sockaddr_in));<br/>
					&nbsp; s_add.sin_family=AF_INET;<br/>			
					&nbsp; s_add.sin_port=htons(10000);<br/>
					&nbsp; s_add.sin_addr.s_addr = inet_addr("127.0.0.1");<br/>
					&nbsp; //域名解析<br/>
					&nbsp; /*<br/>
					&nbsp; hptr = gethostbyname((char *)"www.baidu.com");<br/>
					&nbsp; if(hptr == NULL){<br/>
							&nbsp; &nbsp; printf("DNS is fail\n");<br/>
					&nbsp; }else<br/>
							&nbsp; &nbsp; s_add.sin_addr = *((struct in_addr *)hptr->h_addr);<br/>
					&nbsp; */<br/>
					&nbsp; connect_flag=connect(s,(struct sockaddr *)(&amp;s_add), sizeof(struct sockaddr));<br/>
					&nbsp; if(connect_flag < 0)<br/>
							&nbsp; &nbsp; printf("connect fail\n");<br/>
					&nbsp; else{<br/>
						&nbsp; &nbsp; printf("connect ok\n");<br/>
						&nbsp; &nbsp; len = sizeof(s_info);<br/>
						&nbsp; &nbsp; getsockopt(s, IPPROTO_TCP, TCP_INFO, &amp;s_info, (socklen_t *)&len);<br/>
						&nbsp; &nbsp; if(s_info.tcpi_state == TCP_ESTABLISHED)//已连接<br/>
						&nbsp; &nbsp; {<br/>
							&nbsp; &nbsp; &nbsp; struct sockaddr_in serv, guest;<br/>
							&nbsp; &nbsp; &nbsp; socklen_t serv_len = sizeof(serv);<br/>
							&nbsp; &nbsp; &nbsp; socklen_t guest_len = sizeof(guest);<br/>
							&nbsp; &nbsp; &nbsp; getsockname(s, (struct sockaddr *)&amp;guest, &amp;guest_len);<br/>
							&nbsp; &nbsp; &nbsp; getpeername(s, (struct sockaddr *)&amp;serv, &amp;serv_len);<br/>
							&nbsp; &nbsp; &nbsp; inet_ntop(AF_INET, &amp;guest.sin_addr, guest_ip, sizeof(guest_ip));<br/>
							&nbsp; &nbsp; &nbsp; inet_ntop(AF_INET, &amp;serv.sin_addr, serv_ip, sizeof(serv_ip));<br/>
							&nbsp; &nbsp; &nbsp; printf("host  %s:%d, guest  %s:%dn", serv_ip, ntohs(serv.sin_port), guest_ip, ntohs(guest.sin_port));<br/>
							&nbsp; &nbsp; &nbsp; buff_len=send(s, "hello,world", strlen("hello,world"), 0);<br/>
							&nbsp; &nbsp; &nbsp; printf("send len:%d\n", buff_len);<br/>
							&nbsp; &nbsp; &nbsp; buff_len=recv(s, buff, sizeof(buff), 0);<br/>
							&nbsp; &nbsp; &nbsp; if(buff_len > 0){<br/>
								&nbsp; &nbsp; &nbsp; &nbsp; printf("data:%s", buff);<br/>
							&nbsp; &nbsp; &nbsp; }<br/>
						&nbsp; &nbsp; }<br/>
						&nbsp; &nbsp; else//未连接<br/>
						&nbsp; &nbsp; {<br/>
							&nbsp; &nbsp; &nbsp; shutdown(s, SHUT_RDWR);<br/>
							&nbsp; &nbsp; &nbsp; close(s);<br/>
							&nbsp; &nbsp; &nbsp; bzero(&amp;s_info, sizeof(struct tcp_info));<br/>
						&nbsp; &nbsp; }<br/>
					&nbsp; }<br/>
					&nbsp; return 0;<br/>
				}
			</fieldset>
			</form>
			<form>
			<fieldset>
				<legend>** <b>TCP Server 举例</b> **</legend>
				#include &lt;stdio.h><br/>
				#include &lt;sys/socket.h><br/>
				#include &lt;arpa/inet.h><br/>
				#include &lt;string.h><br/>
				#include &lt;unistd.h><br/>
				#include &lt;errno.h><br/>
				int main(void){<br/>
					&nbsp; struct sockaddr_in s_add;//服务器<br/>
					&nbsp; struct sockaddr_in c_addr;//客户端<br/>
					&nbsp; int len, buff_len, opt, ret, c, s;<br/>
					&nbsp; char buff[1024];<br/>
					&nbsp; fd_set accept_set;<br/>
					&nbsp; struct timeval select_timeouts;<br/>
					
					&nbsp; s = socket(AF_INET, SOCK_STREAM, 0);//创建套接字<br/>
					&nbsp; if(s &lt; 0){<br/>
						&nbsp; &nbsp; printf("socket creat fail\n");<br/>
						&nbsp; &nbsp; return 0;<br/>
					&nbsp; }<br/>
					&nbsp; //设置套接字选项<br/>
					&nbsp; opt = SO_REUSEADDR;<br/>
					&nbsp; setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt) );<br/>
					&nbsp; //设置服务器参数<br/>
					&nbsp; bzero(&amp;s_add, sizeof(struct sockaddr_in));<br/>
					&nbsp; s_add.sin_family = AF_INET;//IPV4<br/>
					&nbsp; s_add.sin_port = htons(10000);<br/>
					&nbsp; s_add.sin_addr.s_addr = inet_addr("127.0.0.1");//回环地址。htonl(INADDR_ANY);本机地址<br/>
					&nbsp; ret = bind(s,(struct sockaddr *)(&amp;s_add), sizeof(struct sockaddr));<br/>
					&nbsp; if(ret &lt; 0){<br/>
						&nbsp; &nbsp; printf("bind fail\n");<br/>
						&nbsp; &nbsp; close(s);<br/>
						&nbsp; &nbsp; return 0;<br/>
					&nbsp; }<br/>
					&nbsp; ret=listen(s,5);<br/>
					&nbsp; if(ret &lt; 0){<br/>
						&nbsp; &nbsp; printf("listen fail\n");<br/>
						&nbsp; &nbsp; close(s);<br/>
						&nbsp; &nbsp; return 0;<br/>
					&nbsp; }<br/>
					&nbsp; while(1){<br/>
						&nbsp; &nbsp; FD_ZERO(&amp;accept_set);<br/>
						&nbsp; &nbsp; FD_SET(s, &amp;accept_set);<br/>
						&nbsp; &nbsp; ret = select(s+1, &amp;accept_set, NULL, NULL, &amp;select_timeouts);<br/>
						&nbsp; &nbsp; if(ret > 0){<br/>
							&nbsp; &nbsp; &nbsp; if(FD_ISSET(s, &amp;accept_set)){<br/>
								&nbsp; &nbsp; &nbsp; &nbsp; len=sizeof(struct sockaddr_in);<br/>
								&nbsp; &nbsp; &nbsp; &nbsp; c = accept(s, (struct sockaddr *)&amp;c_addr, (socklen_t *)&amp;len);<br/>
								&nbsp; &nbsp; &nbsp; &nbsp; if(c > 0){<br/>
									&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buff_len = recv(c, buff, 1024, 0);<br/>
									&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(buff_len > 0){<br/>
										&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("recv ok\n");<br/>
										&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(send(s,buff,buff_len,0)>0)<br/>
											&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("send ok\n");<br/>
									&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
									&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if(buff_len==0 || (buff_len!=EWOULDBLOCK && buff_len!=EINTR))//连接异常，需要关闭<br/>
									&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/>
										&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("disconnect\n");<br/>
										&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; close(c);<br/>
										&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br/>
									&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
								&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
							&nbsp; &nbsp; &nbsp; }<br/>
						&nbsp; &nbsp; }<br/>
					&nbsp; }<br/>
					&nbsp; return 0;<br/>
				}
			</fieldset>
			</form>
			<form>
			<fieldset>
				<legend>** <b>UDP Client 举例</b> **</legend>
				
			</fieldset>
			</form>
			<form>
			<fieldset>
				<legend>** <b>UDP Server 举例</b> **</legend>
				
			</fieldset>
			</form>
			</li>
			<ol>
			</div><hr/>
		<div>
			<h3>arpa/inet.h</h3>
			<ol>
			<li>in_addr_t inet_addr(const char *cp)：将一个点分十进制格式 ip 转换成一个长整数值（网络字节格式）<br/>
				cp：点分十进制 ip地址<br/>
				返回值：成功返回转换后的二进制网络字节序，失败返回 INADDR_NONE<br/>
				举例：inet_addr("192.168.2.80")，若返回的是 INADDR_NONE（255.255.255.255）则表示网络广播地址</li>
			<li>char *inet_ntoa(struct in_addr in)：将整数转换成点分十进制格式表示的 ip 地址字符串<br/>
				in：长整数二进制网络字节序<br/>
				返回值：成功返回点分十进制字符串，失败返回 NULL</li>
			<li>int inet_pton(int family, const char *strptr, void *addrptr)：将点分十进制的 ip 地址转化为用于网络传输的数值格式<br/>
				family：AF_INET 或 AF_INET6<br/>
				strptr：点分十进制<br/>
				addrptr：ip 地址，数值格式<br/>
				返回值：若成功则为1，若输入不是有效的表达式则为0，若出错则为-1</li>
			<li>const char *inet_ntop(int family, const void *addrptr, char *strptr, size_t len)：将数值格式（二进制整数）转化为点分十进制的 ip 地址格式<br/>
				family：AF_INET 或 AF_INET6<br/>
				addrptr：ip 地址，数值格式<br/>
				strptr：点分十进制<br/>
				len：strptr 的长度<br/>
				返回值：成功返回指向结构的指针，失败返回 NULL，如 "127.0.0.1"</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li>struct sockaddr_in{<br/>
				sa_family_t &nbsp; 	sin_family;		//地址族<br/>
				uint16_t &nbsp; &nbsp; sin_port;		//端口号<br/>
				struct in_addr	sin_addr;		//32 位 IP<br/>
				char&nbsp; &nbsp; &nbsp; &nbsp;sin_zero[8];	//暂未使用<br/>
			};<br/>
			注意：此结构体也可包含在 netinet/in.h 头文件里</li>
			<ol>
			</div><hr/>
		<div>
			<h3>sys/msg.h</h3>
			<ol>
			<li>int msgget(key_t key, int msgflg)：创建新的或打开已存在的消息队列，其消息数量受系统限制。<br/>
				key：消息队列对象的关键字，与已有的消息队列对象的关键字进行比较判断是否已创建，即新的或已有的队列 id<br/>
				msgflg：消息队列访问权限<br/>
				&nbsp; 0/IPC_PRIVATE：建立新的消息队列<br/>
				&nbsp; IPC_CREAT：创建新的消息队列，若已存在则打开<br/>
				&nbsp; IPC_EXCL：与 IPC_CREAT 一起使用表示消息队列不存在则创建，若要创建的消息队列已存在则返回错误<br/>
				&nbsp; IPC_NOWAIT：读写消息队列要求无法满足时，不阻塞<br/>
				返回值：失败返回 -1 并设置 error，成功返回 key 命名的消息队列标识符<br/>
				失败的 error 值：<br/>
				&nbsp; EACCESS：拒绝进入，没有权限<br/>
				&nbsp; EEXIST：队列已存在不能创建<br/>
				&nbsp; EIDRM：队列已标记为删除<br/>
				&nbsp; ENOENT：队列不存在<br/>
				&nbsp; ENOMEM：没有足够内存创建队列<br/>
				&nbsp; ENOSPC：超过最大队列限制<br/>
				msgget(key, IPC_CREAT|0600);//这里 |0600 是指第一个 0 表示后面的 600 是个 8 进制数；后面的 600 表示创建用户/用户组/普通用户的权限（类型 chmod 命令）<br/>
				举例：详见“消息队列举例”</li>
			<li>int msgrcv (int msqid, void *msgp, size_t msgsz,long msgtype, int flag)：从消息队列获取消息<br/>
				msqid：消息队列标识符，msgget 函数的返回值<br/>
				msgp：接收消息的缓存区，指向一个长整型数，包括消息类型+消息数据<br/>
				msgsz：接收消息的大小。若返回的消息大于 msgsz，而且在 flag 中设置了 MSG_NOERROR，则该消息被截短（在这种情况下，不通知我们消息截短了）。如果没有设置这一标志，而消息又太长，则出错返回 E2BIG（消息仍留在队列中）<br/>
				msgtype：期望接收的消息类型<br/>
				&nbsp; 0：获取队列中的第一个消息（最早的消息）<br/>
				&nbsp; &gt;0：获取具有相同消息类型的第一个消息（类型为 msgtype 的第一个消息）<br/>
				&nbsp; &lt;0：获取类型小于等于 msgtype 的绝对值的第一个消息<br/>
				flag：控制当队列中没有相应类型的消息可接收时将发生的事件<br/>
				&nbsp; 0: 阻塞式接收消息，没有该类型的消息msgrcv函数一直阻塞等待<br/>
				&nbsp; IPC_NOWAIT：使操作不阻塞。这使得如果没有所指定类型的消息，则 msgrcv 出错返回 ENOMSG。如果没有指定 IPC_NOWAIT，则进程阻塞直至有了指定类型
					的消息，或从系统中删除了此队列（出错返回 EIDRM），或捕捉到一个信号并从信号处理程序返回（出错返回 EINTR）<br/>
				&nbsp; IPC_EXCEPT：与 msgtype 配合使用返回队列中第一个类型不为 msgtype 的消息<br/>
				&nbsp; IPC_NOERROR：如果队列中满足条件的消息内容大于所请求的 size 字节，则把该消息截断，截断部分将被丢弃<br/>
				返回值：成功返回接收缓存区的字节数，失败返回 -1 并设置 error失败的 error 值：<br/>
				&nbsp; E2BIG：消息数据长度大于msgsz而msgflag没有设置IPC_NOERROR<br/>
				&nbsp; EIDRM：标识符为msqid的消息队列已被删除<br/>
				&nbsp; EACCESS：无权限读取该消息队列<br/>
				&nbsp; EFAULT：参数msgp指向无效的内存地址<br/>
				&nbsp; ENOMSG：参数msgflg设为IPC_NOWAIT，而消息队列中无消息可读<br/>
				&nbsp; EINTR：等待读取队列内的消息情况下被信号中断<br/>
				注意：此函数为阻塞函数，接触阻塞条件有：1.消息队列中有了满足条件的消息；2.msqid 代表的消息队列被删除；3.调用 msgrcv() 的进程被信号中断<br/>
				举例：详见“消息队列举例”</li>
			<li>int msgsnd(int msqid, const void *msgp, size_t msgsz, int flag)：将消息添加到消息队列尾端<br/>
				msqid：消息队列标识符，msgget 函数的返回值<br/>
				msgp：发送消息的缓存区，指向一个长整型数，包括消息类型+消息数据<br/>
				msgsz：发送消息的大小，若为 0 则无消息数据<br/>
				flag：事件<br/>
				&nbsp; 0：当消息队列满时，msgsnd 将会阻塞，直到消息能写进消息队列<br/>
				&nbsp; IPC_NOWAIT：类似于文件 I/O 的非阻塞 I/O 标志。若消息队列已满（或者是队列中的消息总数等于系统限制值，或队列中的字节总数等于系统限制值），则指定 IPC_NOWAIT 使得 msgsnd 立即出错返回 EAGAIN。如果没有指定 IPC_NOWAIT，
					则进程阻塞直到有空间可以容纳要发送的消息，或从系统中删除了此队列，或捕捉到一个信号，并从信号处理程序返回。在第二种情况下，返回 EIDRM（“标志符被删除”）。最后一种情况则返回 EINTR。<br/>
				&nbsp; IPC_NOERROR：若发送的消息大于 size 字节，则把该消息截断，截断部分将被丢弃，且不通知发送进程<br/>
				返回值：成功返回 0，失败返回 -1 并设置 error<br/>
				注意：此为阻塞函数，解除阻塞条件有：1.不满足消息队列满或个数满两个条件，即消息队列中有容纳该消息的空间；2.msqid 代表的消息队列被删除；3.调用 msgsnd 函数的进程被信号中断<br/>
				举例：详见“消息队列举例”</li>
			<li>int msgctl(int msqid, int cmd, struct msqid_ds *buf)：设置或获取消息队列属性，与信号量和共享存储有关<br/>
				msqid：消息队列标识符，msgget 函数的返回值<br/>
				cmd：<br/>
				&nbsp; IPC_STAT：取此队列的 msqid_ds 结构，并将其存放在 buf 指向的结构中函数的返回值<br/>
				&nbsp; IPC_SET：按由 buf 指向的结构中的值，设置与此队列相关的结构中的四个字段（msg_perm.uid、msg_perm.gid、msg_perm、mode 和 msg_qbytes）<br/>
				&nbsp; IPC_RMID：从系统中删除该消息队列以及仍在该队列上的所有数据。这种删除立即生效<br/>
				buf：消息队列管理结构体<br/>
				返回值：成功返回 0，失败返回 -1 并设置 error<br/>
				失败的 error 值：<br/>
				&nbsp; EACCESS：无权限读取该消息队列<br/>
				&nbsp; EFAULT：参数 buf 指向无效的内存地址<br/>
				&nbsp; EIDRM：标识符为 msqid 的消息队列已被删除<br/>
				&nbsp; EINVAL：无效的参数 cmd 或 msqid<br/>
				&nbsp; EPERM：参数 cmd 为 IPC_SET 或 IPC_RMID，却无足够的权限执行<br/>
				举例：详见“消息队列举例”</li>
			<li></li>
			<li>
				<form>
				<fieldset>
				<legend>** <b>消息队列举例</b> **</legend>
				#include &lt;stdio.h><br/>
				#include &lt;string.h><br/>
				#include &lt;unistd.h><br/>
				#include &lt;sys/ipc.h><br/>
				#include &lt;sys/msg.h><br/>
				#include &lt;error.h><br/>

				struct msgbuf{<br/>
					&nbsp; long mtype;//固定长整型，指定类型，为后续发送和接收提供标识<br/>
					&nbsp; char mtext[512];<br/>
				};<br/>
				int main(void){<br/>
					&nbsp; int msqid;<br/>
					&nbsp; struct msqid_ds info;<br/>
					&nbsp; struct msgbuf buf;<br/>
					&nbsp; int flag;<br/>
					&nbsp; int sendlen, recvlen;<br/>
					&nbsp; msqid = msgget(IPC_PRIVATE, 0666);//创建新消息队列<br/>
					&nbsp; if(msqid &lt; 0){<br/>
						&nbsp; &nbsp; perror("get ipc_id error");<br/>
						&nbsp; &nbsp; return -1 ;<br/>
					&nbsp; }<br/>
					&nbsp; buf.mtype = 1;<br/>
					&nbsp; strcpy(buf.mtext, "happy new year!");<br/>
					&nbsp; sendlen = sizeof(struct msgbuf)-sizeof(long);<br/>
					&nbsp; flag = msgsnd(msqid, &amp;buf, sendlen, 0);//发送信号消息<br/>
					&nbsp; if(flag &lt; 0){<br/>
						&nbsp; &nbsp; perror("send message error");<br/>
						&nbsp; &nbsp; return -1;<br/>
					&nbsp; }<br/>
					&nbsp; buf.mtype = 3;<br/>
					&nbsp; strcpy(buf.mtext, "good bye!");<br/>
					&nbsp; sendlen = sizeof(struct msgbuf)-sizeof(long);<br/>
					&nbsp; flag = msgsnd(msqid, &amp;buf, sendlen, 0);//发送信号消息<br/>
					&nbsp; if(flag &lt; 0){<br/>
						&nbsp; &nbsp; perror("send message error");<br/>
						&nbsp; &nbsp; return -1 ;<br/>
					&nbsp; }<br/>
					&nbsp; flag = msgctl(msqid, IPC_STAT, &amp;info);<br/>
					&nbsp; if(flag &lt; 0){<br/>
						&nbsp; &nbsp; perror("get message status error");<br/>
						&nbsp; &nbsp; return -1 ;<br/>
					&nbsp; }<br/>
					&nbsp; printf("uid:%d, gid=%d, cuid=%d, cgid=%d\n", info.msg_perm.uid, info.msg_perm.gid, info.msg_perm.cuid, info.msg_perm.cgid);<br/>
					&nbsp; printf("read-write:%03o, cbytes = %lu, qnum = %lu, qbytes= %lu\n", info.msg_perm.mode&amp;0777, info.msg_cbytes, info.msg_qnum, info.msg_qbytes);<br/>
					&nbsp; recvlen = sizeof(struct msgbuf)-sizeof(long);<br/>
					&nbsp; memset(&amp;buf, 0x00, sizeof(struct msgbuf));<br/>
					&nbsp; flag = msgrcv(msqid, &amp;buf, recvlen ,0,0);//倒数第二个为非 3 则获取第一个消息（happy...），为 3 则获取（bye...）
					&nbsp; if(flag &lt; 0){<br/>
						&nbsp; &nbsp; perror("recv message error");<br/>
						&nbsp; &nbsp; return -1;<br/>
					&nbsp; }<br/>
					&nbsp; printf("type=%ld, message=%s\n", buf.mtype, buf.mtext);<br/>
					&nbsp; flag = msgctl(msqid, IPC_RMID, NULL);<br/>
					&nbsp; if(flag &lt; 0){<br/>
						&nbsp; &nbsp; perror("rm message queue error");<br/>
						&nbsp; &nbsp; return -1;<br/>
					&nbsp; }<br/>
					&nbsp; return 0;<br/>
				}
				</fieldset>
				</form>
			</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li>struct msqid_ds{
				&nbsp; struct ipc_perm msg_perm;
				&nbsp; struct msg *msg_first;      /* first message on queue,unused  */
				&nbsp; struct msg *msg_last;       /* last message in queue,unused */
				&nbsp; __kernel_time_t msg_stime;  /* last msgsnd time */
				&nbsp; __kernel_time_t msg_rtime;  /* last msgrcv time */
				&nbsp; __kernel_time_t msg_ctime;  /* last change time */
				&nbsp; unsigned long  msg_lcbytes; /* Reuse junk fields for 32 bit */
				&nbsp; unsigned long  msg_lqbytes; /* ditto */
				&nbsp; unsigned short msg_cbytes;  /* current number of bytes on queue */
				&nbsp; unsigned short msg_qnum;    /* number of messages in queue */
				&nbsp; unsigned short msg_qbytes;  /* max number of bytes on queue */
				&nbsp; __kernel_ipc_pid_t msg_lspid;   /* pid of last msgsnd */
				&nbsp; __kernel_ipc_pid_t msg_lrpid;   /* last receive pid */
				};</li>
			<ol>
			</div><hr/>
		<div>
			<h3>termios.h</h3>
			<ol>
			<li>int tcgetattr(int fd, struct termios *termios_p)：获取终端参数（如虚拟终端、串口、显示器、键盘等）<br/>
				fd：文件描述符，如 open 返回的 fd 值。<br/>
				termios_p：获取的参数保存在此结构体中，结构体如下：<br/>
				struct termios<br/>
				{<br/>
					&nbsp; unsigned short c_iflag; /* 输入模式标志 */<br/>
					&nbsp; unsigned short c_oflag; /* 输出模式标志 */<br/>
					&nbsp; unsigned short c_cflag; /* 控制模式标志，包括波特率、校验位等*/<br/>
					&nbsp; unsigned short c_lflag; /* 本地模式标志 */<br/>
					&nbsp; unsigned char c_line; /* 线路规程 */<br/>
					&nbsp; unsigned char c_cc[NCC]; /* 控制特性 */<br/>
					&nbsp; speed_t c_ispeed; /* 输入速度 */<br/>
					&nbsp; speed_t c_ospeed; /* 输出速度 */<br/>
				};<br/>
				其中 c_iflag 输入模式标志，控制终端输入模式，值如下：<br/>
				&nbsp; IGNBRK：忽略 BREAK 键输入<br/>
				&nbsp; BRKINT：如果设置了 IGNBRK，BREAK 键输入将被忽略<br/>
				&nbsp; IGNPAR：忽略奇偶校验错误<br/>
				&nbsp; PARMRK：标识奇偶校验错误<br/>
				&nbsp; INPCK：奇偶校验使能<br/>
				&nbsp; ISTRIP：去除字符的第 8 个比特<br/>
				&nbsp; INLCR：将输入的 NL（换行）转换成 CR（回车）<br/>
				&nbsp; IGNCR：忽略输入的回车<br/>
				&nbsp; ICRNL：将输入的回车转化成换行（如果 IGNCR 未设置的情况下）<br/>
				&nbsp; IUCLC：将输入的大写字符转换成小写字符（非 POSIX）<br/>
				&nbsp; IXON：允许输出时对 XON/XOFF 流进行控制<br/>
				&nbsp; IXANY：输入任何字符将重启停止的输出<br/>
				&nbsp; IXOFF：允许输入时对 XON/XOFF 流进行控制<br/>
				&nbsp; IMAXBEL：当输入队列满的时候开始响铃<br/>
				c_oflag 输出模式标志，控制终端输出模式，值如下：<br/>
				&nbsp; OPOST：处理后输出<br/>
				&nbsp; OLCUC：将输入的小写字符转换成大写字符（非 POSIX）<br/>
				&nbsp; ONLCR：将输入的 LF（换行）转换成 CR（回车）<br/>
				&nbsp; OCRNL：将输入的 CR（回车）转换成 LF（换行）<br/>
				&nbsp; ONOCR：第一行不输出回车符<br/>
				&nbsp; ONLRET：不输出回车符<br/>
				&nbsp; OFILL：发送填充字符以延迟终端输出<br/>
				&nbsp; OFDEL：以 ASCII 码的 DEL 作为填充字符，如果未设置该参数，填充字符为 NUL<br/>
				&nbsp; NLDLY：换行输出延时，可以取 NL0（不延迟）或 NL1（延迟0.1s）<br/>
				&nbsp; CRDLY：回车延迟，取值范围为：CR0、CR1、CR2和 CR3<br/>
				&nbsp; TABDLY：水平制表符输出延迟，取值范围为：TAB0、TAB1、TAB2 和 TAB3<br/>
				&nbsp; BSDLY：空格输出延迟，可以取 BS0 或 BS1<br/>
				&nbsp; VTDLY：垂直制表符输出延迟，可以取 VT0 或 VT1<br/>
				&nbsp; FFDLY：换页延迟，可以取 FF0 或 FF1<br/>
				c_cflag：控制模式标志，指定终端硬件控制信息，值如下：<br/>
				&nbsp; CBAUD：波特率（4+1位）（非 POSIX），如 B9600 是 9600 波特率；B115200 是 115200波特率<br/>
					&nbsp; &nbsp; cfsetospeed(&newtios,B9600);cfsetispeed(&newtios,B9600);//设置波特率<br/>
				&nbsp; CBAUDEX：附加波特率（1位）（非 POSIX）<br/>
				&nbsp; CSIZE：字符长度，如 CS5 是 5 个数据位；CS8 是 8 个数据位，如：<br/>
					&nbsp; &nbsp; tios.c_cflag &= ~CSIZE;tios.c_cflag |= CS8;// 8 位数据位，8 改成 7 就是 7bit<br/>
				&nbsp; CSTOPB：设置 2 个停止位，不设则是 1 个停止位，如：<br/>
					&nbsp; &nbsp; tios.c_cflag &= ~CSTOPB;// 1bit 停止位<br/>
					&nbsp; &nbsp; tios.c_cflag |= CSTOPB;// 2bit 停止位<br/>
				&nbsp; CREAD：接收使能<br/>
				&nbsp; PARENB：奇偶校验使能，如：<br/>
					&nbsp; &nbsp; tios.c_iflag |= IGNPAR;tios.c_cflag &= ~PARENB;//NONE，忽略奇偶校验错误<br/>
					&nbsp; &nbsp; tios.c_iflag |= IGNPAR;tios.c_cflag |= PARENB;tios.c_cflag |= PARODD;//ODD<br/>
					&nbsp; &nbsp; tios.c_iflag |= IGNPAR;tios.c_cflag |= PARENB;tios.c_cflag &= ~PARODD;//EVEN<br/>
					&nbsp; &nbsp; 或<br/>
					&nbsp; &nbsp; tios.c_cflag &= ~PARENB;tios.c_cflag &= ~INPCK;//NONE，奇偶校验不使能<br/>
					&nbsp; &nbsp; tios.c_cflag |= (PARENB | PARODD);tios.c_cflag |= INPCK;//ODD。奇偶校验使能<br/>
					&nbsp; &nbsp; tios.c_cflag |= PARENB;tios.c_cflag &= ~PARODD;tios.c_cflag |= INPCK;//EVEN<br/>
				&nbsp; PARODD：对输入使用奇偶校验，对输出使用偶校验<br/>
				&nbsp; HUPCL：关闭设备时挂起<br/>
				&nbsp; CLOCAL：忽略调制解调器线路状态，本地连接<br/>
				&nbsp; CRTSCTS：使用 RTS/CTS 流控制，硬件流控<br/>
				c_lflag：本地模式标志，控制终端编辑功能，值如下：<br/>
				&nbsp; ISIG：当输入INTR、QUIT、SUSP或DSUSP时，产生相应的信号<br/>
				&nbsp; ICANON：使用标准输入模式<br/>
				&nbsp; XCASE：在 ICANON 和 XCASE 同时设置的情况下，终端只使用大写。<br/>
				&nbsp; ECHO：显示输入字符<br/>
				&nbsp; ECHOE：如果 ICANON 同时设置，ERASE 将删除输入的字符<br/>
				&nbsp; ECHOK：如果 ICANON 同时设置，KILL 将删除当前行<br/>
				&nbsp; ECHONL：如果 ICANON 同时设置，即使 ECHO 没有设置依然显示换行符<br/>
				&nbsp; ECHOPRT：如果 ECHO 和 ICANON 同时设置，将删除打印出的字符（非 POSIX）<br/>
				&nbsp; TOSTOP：向后台输出发送 SIGTTOU 信号<br/>
				c_cc[NCCS]：控制字符，用于保存终端驱动程序中的特殊字符，如输入结束符等。值如下：<br/>
				&nbsp; VINTR：Interrupt 字符，中断控制字符（ctrl+c）<br/>
				&nbsp; VEOL：附加的 End-of-file 字符，附加行结束符（CR）<br/>
				&nbsp; VQUIT：Quit 字符，退出操作符（ctrl+z）<br/>
				&nbsp; VTIME：非规范模式读取时的超时时间，单位百毫秒，不能超过 cc_t<br/>
				&nbsp; VERASE：Erase 字符，删除操作符（Backspace 键）<br/>
				&nbsp; VSTOP：Stop 字符<br/>
				&nbsp; VKILL：Kill 字符，删除行符<br/>
				&nbsp; VSTART：Start 字符<br/>
				&nbsp; VEOF：End-of-file 字符，文件结尾符<br/>
				&nbsp; VSUSP：Suspend 字符<br/>
				&nbsp; VMIN：非规范模式读取时的最小字符数<br/>
				返回值：成功返回 0，失败返回非 0 并设置 errno 错误标识<br/>
				VTIME 和 VMIN 属性设置的作用：映像 read 函数的返回<br/>
				&nbsp; 1.VTIME 是等待时间，VMIN 是等待的最小字节数，可以为 0<br/>
				&nbsp; 2.VTIME 为 0，VMIN 定义等待读取最小字节数时，read 只有在读取了 VMIN 个字节数或收到一个信号时才返回<br/>
				&nbsp; 3.VMIN 为 0，VTIME 定义即使没有数据也可读取，read 返回前要等待 VTIME 时间，这时 read 不需要遇到文件结束标志才返回 0<br/>
				&nbsp; 4.若 VMIN 和 VTIME 都是 0，则计时读不到数据，read 也会立即返回，同时，返回值为 0 表示 read 函数不需要等待文件结束标志就返回了<br/>
				&nbsp; 5.若 VMIN 和 VTIME 都非 0，VTIME 定义接收到第一个字节数据后开始计算等待时间，若调用 read 可得到数据则马上开始计时，若调用 read 后还没数据则等接收第一个字节后计时。read 可能会在读取到 VMIN 个字节后返回，也可能在计时完毕后返回。</li>
			<li>void cfmakeraw (struct termios *termios-p)：将中断设置为原始模式，该模式下所有的输入数据以字节为单位被处理<br/>
				termios-p：可以先用 tcgetattr 获取参数，然后使用 tcgetattr 里面的 termios-p</li>
			<li>int cfsetospeed(struct termios *termptr, speed_t speed)：配合 cfsetispeed 函数实现设置波特率<br/>
				termptr：指向 termios 结构的指针<br/>
				speed：输出的波特率<br/>
				返回值：成功返回 0，失败返回 -1<br/>
				如：cfsetospeed(&tios,B115200);cfsetispeed(&tios,B115200);</li>
			<li>int cfsetispeed(struct termios *termptr, speed_t speed)：配合 cfsetospeed 函数实现设置波特率<br/>
				termptr：指向 termios 结构的指针<br/>
				speed：输入的波特率<br/>
				返回值：成功返回 0，失败返回 -1</li>
			<li>speed_t cfgetispeed(const struct termios *termios_p)：配合 cfgetospeed 实现获取波特率<br/>
				termios_p：指向 termios 的结构体指针<br/>
				返回值：成功返回输入波特率，失败返回 -1</li>
			<li>speed_t cfgetospeed(const struct termios *termios_p)：配合 cfgetispeed 实现获取波特率<br/>
				termios_p：指向 termios 的结构体指针<br/>
				返回值：成功返回输出波特率，失败返回 -1</li>
			<li>int tcflush(int fd, int queue_selector)：清空串口 buffer 中的数据<br/>
				fd：文件描述符<br/>
				queue_selector：对缓存区的操作，值如下<br/>
				&nbsp; TCIFLUSH：清除/刷新正收到的数据，且不会读取出来<br/>
				&nbsp; TCOFLUSH：清除/刷新正写入的数据，且不会发送至终端<br/>
				&nbsp; TCIOFLUSH：清除/刷新所有正在发生的 I/O 数据，即将输出缓冲区和输入缓存区清空<br/>
				返回值：成功返回 0，失败返回 -1 并设置 errno 错误</li>
			<li>int tcsetattr(int fd, int optional_actions, const struct termios *termios_p)：设置终端参数<br/>
				fd：文件描述符<br/>
				optional_actions：参数生效时间<br/>
				&nbsp; TCSANOW：不等数据传输完毕就立即改变属性<br/>
				&nbsp; TCSADRAIN：等待所有数据传输结束才改变属性<br/>
				&nbsp; TCSAFLUSH：等待所有数据传输结束，清空输入输出缓冲区才改变属性<br/>
				termios_p：指向 termios 的结构体指针<br/>
				返回值：成功返回 0，失败返回 -1 并设置 errno 错误</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>netdb.h</h3>
			<ol>
			<li>struct hostent *gethostbyname(const char *name)：用域名或主机名获取 ip 地址<br/>
				name：指向主机名，如 "www.baidu.com"<br/>
				返回值：window 下返回对应于给定主机名的主机信息；linux 下成功返回非空，失败返回空并设置 errno<br/>
				window 下的头文件是 winsock2.h<br/>
				struct hostent<br/>
				{<br/>
					&nbsp; char *h_name; //主机的规范名<br/>
					&nbsp; char ** h_aliases; //主机的别名<br/>
					&nbsp; short h_addrtype; //主机 ip 地址类型，ipv4（AF_INET）或 ipv6（AF_INET6）<br/>
					&nbsp; short h_length; //主机 ip 地址长度<br/>
					&nbsp; char ** h_addr_list;//主机 ip 地址，以网络字节序存储，打印 ip 时需调用 inet_ntop()<br/>
				};<br/>
				可用于判断是否为域名：if( (hptr = gethostbyname("www.baidu.com") ) == NULL )//不是域名</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>netinet/in.h</h3>
			<ol>
			<li>IPPROTO_UDP：udp 协议</li>
			<li>sockaddr_in：<br/>
			struct  sockaddr_in {<br/>
				&nbsp; short int sin_family; /* Address family */<br/>
				&nbsp; unsigned short int sin_port; /* Port number */<br/>
				&nbsp; struct in_addr sin_addr; /* Internet address */<br/>
				&nbsp; unsigned char sin_zero[8]; /*to make same size as struct sockaddr */<br/>
			};</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li>in_addr_t s_addr：无符号长整形</li>
			<ol>
			</div><hr/>
		<div>
			<h3>cstddef.h</h3>
			<ol>
			<li>size_t：unsigned 类型，为了适应多个平台，增强可移植性。32 位是 unsigned，64 位是 long unsigned int</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>sys/types.h</h3>
			<ol>
			<li>ssize_t：signed 类型，表示可以被执行读写操作的数据块大小，表示的是 signed size_t 类型</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>sys/time.h</h3>
			<ol>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li>struct timeval<br/>
				{<br/>
					time_t      tv_sec;     /* seconds */<br/>
					suseconds_t tv_usec;    /* microseconds */<br/>
				};</li>
			<ol>
			</div><hr/>
		<div>
			<h3>netinet/tcp.h</h3>
			<ol>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li>SO_DEBUG<br/>
				SO_DONTROUTE<br/>
				SO_KEEPALIVE<br/>
				SO_LINGER<br/>
				SO_OOBINLINE<br/>
				SO_RECVBUF<br/>
				SO_RCVLOWAT<br/>
				SO_SNDBUF<br/>
				SO_SNDLOWAT<br/>
				TCP_MAXSEG<br/>
				TCP_NODELAY</li>
			<ol>
			</div><hr/>
		<div>
			<h3>.h</h3>
			<ol>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li>struct tcp_info {<br/>
				&nbsp; __u8	tcpi_state;		   //tcp state: TCP_SYN_SENT,TCP_SYN_RECV,TCP_FIN_WAIT1,TCP_CLOSE 等<br/>
				&nbsp; __u8	tcpi_ca_state;     //congestion state：<br/>
				&nbsp; __u8	tcpi_retransmits;  //重传数，表示当前待重传的包数，这个值在重传完毕后清零<br/>
				&nbsp; __u8	tcpi_probes;		///* 持续定时器或保活定时器发送且未确认的段数*/<br/>
				&nbsp; __u8	tcpi_backoff;		//用来计算持续定时器的下一个设计值的指数退避算法指数，在传送超时是会递增。<br/>
				&nbsp; __u8	tcpi_options;		//tcp头部选项是否包含：扩展因子、时间戳、MSS等内容<br/>
				&nbsp; __u8	tcpi_snd_wscale : 4, tcpi_rcv_wscale : 4; //扩展因子数值<br/>
				&nbsp; __u8	tcpi_delivery_rate_app_limited:1;  //限速标志<br/>

				&nbsp; __u32	tcpi_rto;		//重传超时时间，这个和RTT有关系，RTT越大，rto越大<br/>
				&nbsp; __u32	tcpi_ato;		//用来延时确认的估值，单位为微秒. <br/>
				&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //在收到TCP报文时，会根据本次与上次接收的时间间隔来调整改制，在设置延迟确认定时器也会根据<br/>
				&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //条件修改该值<br/>
				&nbsp; __u32	tcpi_snd_mss;	// 本端的MSS<br/>
				&nbsp; __u32	tcpi_rcv_mss;	// 对端的MSS<br/>

				&nbsp; __u32	tcpi_unacked;	//未确认的数据段数<br/>
				&nbsp; __u32	tcpi_sacked;    //2个含义：server端在listen阶段，可以接收连接的数量；收到的SACK报文数量<br/>
				&nbsp; __u32	tcpi_lost;		//本端在发送出去被丢失的报文数。重传完成后清零<br/>
				&nbsp; __u32	tcpi_retrans;   //重传且未确认的数据段数<br/>
				&nbsp; __u32	tcpi_fackets;

				&nbsp; /* Times. */<br/>
				&nbsp; __u32	tcpi_last_data_sent;	//当前时间-最近一个包的发送时间，单位是毫秒<br/>
				&nbsp; __u32	tcpi_last_ack_sent;     //未使用<br/>
				&nbsp; __u32	tcpi_last_data_recv;	//当前时间-最近接收数据包的时间，单位是毫秒<br/>
				&nbsp; __u32	tcpi_last_ack_recv;     //当前时间-最近接收ack的时间，单位是毫秒<br/>

				&nbsp; /* Metrics. */<br/>
				&nbsp; __u32	tcpi_pmtu;			//最后一次更新的路径MTU<br/>
				&nbsp; __u32	tcpi_rcv_ssthresh;   //当前接收窗口的大小<br/>
				&nbsp; __u32	tcpi_rtt;			//smoothed round trip time,微妙<br/>
				&nbsp; __u32	tcpi_rttvar;		//描述RTT的平均偏差，该值越大，说明RTT抖动越大<br/>
				&nbsp; __u32	tcpi_snd_ssthresh;  //拥塞控制慢开始阈值<br/>
				&nbsp; __u32	tcpi_snd_cwnd;		//拥塞控制窗口大小<br/>
				&nbsp; __u32	tcpi_advmss;		//本端的MSS上限<br/>
				&nbsp; __u32	tcpi_reordering;	//没有丢包时，可以重新排序的数据段数<br/>

				&nbsp; __u32	tcpi_rcv_rtt;		// 作为接收端，测出的RTT值，单位为微秒. 这个值不是对方计算并传送过来的rtt，而是作为接收端，在没发送数据的情况下<br/>
				&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 通过接收发送端发送的数据的情况计算得到的rtt值。在数据发送方，如果不接受数据，这个值一般情况下为0。<br/>
				&nbsp; __u32	tcpi_rcv_space;		//当前接收缓存的大小<br/>

				&nbsp; __u32	tcpi_total_retrans;  //统计总重传的包数，持续增长。<br/>

				&nbsp; __u64	tcpi_pacing_rate;		//发送速率<br/>
				&nbsp; __u64	tcpi_max_pacing_rate;	//最大发送速率，默认是unlimited，可以通过SO_MAX_PACING_RATE来设置<br/>
				&nbsp; __u64	tcpi_bytes_acked;    //RFC4898 tcpEStatsAppHCThruOctetsAcked<br/>
				&nbsp; __u64	tcpi_bytes_received; //RFC4898 tcpEStatsAppHCThruOctetsReceived<br/>
				&nbsp; __u32	tcpi_segs_out;	     //RFC4898 tcpEStatsPerfSegsOut<br/>
				&nbsp; __u32	tcpi_segs_in;	     //RFC4898 tcpEStatsPerfSegsIn<br/>

				&nbsp; __u32	tcpi_notsent_bytes;<br/>
				&nbsp; __u32	tcpi_min_rtt;<br/>
				&nbsp; __u32	tcpi_data_segs_in;	//RFC4898 tcpEStatsDataSegsIn<br/>
				&nbsp; __u32	tcpi_data_segs_out;	//RFC4898 tcpEStatsDataSegsOut<br/>

				&nbsp; __u64   tcpi_delivery_rate;<br/>

				&nbsp; __u64	tcpi_busy_time;      //me (usec) busy sending data<br/>
				&nbsp; __u64	tcpi_rwnd_limited;   //Time (usec) limited by receive window<br/>
				&nbsp; __u64	tcpi_sndbuf_limited; //Time (usec) limited by send buffer<br/>
			};<br/>
			tcpi_state 状态：<br/>
				&nbsp; CLOSED：表示初始状态。对服务端和C客户端双方都一样。<br/>
				&nbsp; LISTEN：表示监听状态。服务端调用了listen函数，可以开始accept连接了。<br/>
				&nbsp; SYN_SENT：表示客户端已经发送了SYN报文。当客户端调用connect函数发起连接时，首先发SYN给服务端，然后自己进入SYN_SENT状态，并等待服务端发送ACK+SYN。<br/>
				&nbsp; SYN_RCVD：表示服务端收到客户端发送SYN报文。服务端收到这个报文后，进入SYN_RCVD状态，然后发送ACK+SYN给客户端。<br/>
				&nbsp; ESTABLISHED：表示连接已经建立成功了。服务端发送完ACK+SYN后进入该状态，客户端收到ACK后也进入该状态。<br/>
				&nbsp; FIN_WAIT_1：表示主动关闭连接。无论哪方调用close函数发送FIN报文都会进入这个这个状态。<br/>
				&nbsp; FIN_WAIT_2：表示被动关闭方同意关闭连接。主动关闭连接方收到被动关闭方返回的ACK后，会进入该状态。<br/>
				&nbsp; TIME_WAIT：表示收到对方的FIN报文并发送了ACK报文，就等2MSL后即可回到CLOSED状态了。如果FIN_WAIT_1状态下，收到对方同时带FIN标志和ACK标志的报文时，可以直接进入TIME_WAIT状态，而无须经过FIN_WAIT_2状态。<br/>
				&nbsp; CLOSING：表示双方同时关闭连接。如果双方几乎同时调用close函数，那么会出现双方同时发送FIN报文的情况，此时就会出现CLOSING状态，表示双方都在关闭连接。<br/>
				&nbsp; CLOSE_WAIT：表示被动关闭方等待关闭。当收到对方调用close函数发送的FIN报文时，回应对方ACK报文，此时进入CLOSE_WAIT状态。<br/>
				&nbsp; LAST_ACK：表示被动关闭方发送FIN报文后，等待对方的ACK报文状态，当收到ACK后进入CLOSED状态。<br/>
			</li>
			<ol>
			</div><hr/>
		<div>
			<h3>net/if.h</h3>
			<ol>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li>struct ifreq{<br/>
				#define IFHWADDRLEN 6<br/>
					&nbsp; union{<br/>
						&nbsp; &nbsp; char ifrn_name[IFNAMSIZ];//Interface name, e.g. "en0".<br/>
					&nbsp; } ifr_ifrn;<br/>
				 
					&nbsp; union {<br/>
						&nbsp; &nbsp; struct sockaddr ifru_addr;<br/>
						&nbsp; &nbsp; struct sockaddr ifru_dstaddr;<br/>
						&nbsp; &nbsp; struct sockaddr ifru_broadaddr;<br/>
						&nbsp; &nbsp; struct sockaddr ifru_netmask;<br/>
						&nbsp; &nbsp; struct  sockaddr ifru_hwaddr;<br/>
						&nbsp; &nbsp; short ifru_flags;<br/>
						&nbsp; &nbsp; int ifru_ivalue;<br/>
						&nbsp; &nbsp; int ifru_mtu;<br/>
						&nbsp; &nbsp; struct ifmap ifru_map;<br/>
						&nbsp; &nbsp; char ifru_slave[IFNAMSIZ];<br/>
						&nbsp; &nbsp; char ifru_newname[IFNAMSIZ];<br/>
						&nbsp; &nbsp; void __user * ifru_data;<br/>
						&nbsp; &nbsp; struct if_settings ifru_settings;<br/>
					&nbsp; }ifr_ifru;<br/>
				};
				</li>
			<ol>
			</div><hr/>
		<div>
			<h3>sys/type.h</h3>
			<ol>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li>key_t：长整型</li>
			<ol>
			</div><hr/>
		<div>
			<h3>syslog.h</h3>
			<ol>
			<li>void openlog (char *ident, int option, int facility)：打开系统日志记录程序的连接，打开之后就可以用 syslog 或 vsyslog 函数向系统日志里添加信息了<br/>
				ident：固定地加在每行日志的前面以标识这个日志，通常就写成当前程序的名称以作标记<br/>
				option：<br/>
				&nbsp; LOG_CONS：直接写入系统控制台，如果有一个错误，同时发送到系统日志记录<br/>
				&nbsp; LOG_NDELAY：立即打开连接（通常，打开连接时记录的第一条消息）<br/>
				&nbsp; LOG_NOWAIT：不要等待子进程，因为其有可能在记录消息的时候就被创建了（GNU C 库不创建子进程，所以该选项在 Linux 上没有影响。）<br/>
				&nbsp; LOG_ODELAY：延迟连接的打开直到 syslog 函数调用（这是默认值，无需指定）<br/>
				&nbsp; LOG_PERROR：（不在 SUSv3 情况下）同时输出到 stderr（标准错误文件）<br/>
				&nbsp; LOG_PID：包含每个消息的 PID（进程号）<br/>
				facility：指定程序的类型<br/>
				&nbsp; LOG_AUTH：安全/认证<br/>
		        &nbsp; LOG_AUTHPRIV：安全/认证（私有）<br/>
		        &nbsp; LOG_CRON：cron 和 at<br/>
		        &nbsp; LOG_DAEMON：daemon 系统守护进程，如 inetd、routed 等<br/>
		        &nbsp; LOG_FTP：FTP 守护进程<br/>
		        &nbsp; LOG_KERN：内核产生的消息<br/>
		        &nbsp; LOG_LOCAL0-7：保留供本地使用<br/>
		        &nbsp; LOG_LPR：行式打印机系统，如 lpd、lpc 等<br/>
		        &nbsp; LOG_MAIL：邮件系统<br/>
		        &nbsp; LOG_NEWS：新闻系统<br/>
		        &nbsp; LOG_SYSLOG：syslogd 内部生成的消息，syslogd 守护进程本身<br/>
		        &nbsp; LOG_USER (default)：通用用户级消息<br/>
		        &nbsp; LOG_UUCP：UUCP 系统<br/>
				</li>
			<li>void syslog(int priority, char *format, ...)：把日志消息发给系统程序 syslogd 去记录<br/>
				priority：消息级别<br/>
				&nbsp; LOG_EMERG：系统不可用<br/>
		        &nbsp; LOG_ALERT：必须立即采取行动<br/>
		        &nbsp; LOG_CRIT：临界条件<br/>
		        &nbsp; LOG_ERR：出错条件<br/>
		        &nbsp; LOG_WARNING：警告条件<br/>
		        &nbsp; LOG_NOTICE：注意<br/>
		        &nbsp; LOG_INFO：通告信息<br/>
		        &nbsp; LOG_DEBUG：debug 调试信息<br/>
				format：消息格式，和 printf 函数一样<br/>
				</li>
			<li>void closelog(void)：关闭 openlog 打开的连接</li>
			<li>int setlogmask(int mask)：设置进程的记录有限级屏蔽字，当设置了记录优先级屏蔽字时，各条消息除非已在记录优先级屏蔽字中进行了设置，否则不被记录<br/>
				返回值：调用它之前的屏蔽字</li>
			<li>void vsyslog(int priority, const char *format, va_list ap)：处理可变参数列表</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>.h</h3>
			<ol>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>.h</h3>
			<ol>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>.h</h3>
			<ol>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>.h</h3>
			<ol>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>.h</h3>
			<ol>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>.h</h3>
			<ol>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>.h</h3>
			<ol>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>.h</h3>
			<ol>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>.h</h3>
			<ol>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>.h</h3>
			<ol>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>.h</h3>
			<ol>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>编译器支持</h3>
			<ol>
			<li>__FILE__：当前程序文件名，包括路径</li>
			<li>__LINE__：当前文件下的代码行号</li>
			<li>__FUNCTION__：当前函数</li>
			<li>__TIME__：当前编译时间</li>
			<li>__DATE__：当前编译日期</li>
			<li>__STDC__：编译器是否遵循 ANSI C 标准，是为非 0 值</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
	</div>
</body>
</html>