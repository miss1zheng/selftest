<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
	<title>标准库</title>
	<link rel="stylesheet" type="text/css" href="../../../home/all.css" >
	<link rel="shortcut icon" href="../../../picture/favicon.ico" type="image/x-icon">
	<style>
		.main_body li{line-height:25px;}
		a{text-decoration:none;}
	</style>
</head>
<body>
	<div class="menu_body">
		<a href="../../../home.html">首页</a>
		<a href="../../study.html">学习</a>
		<a href="../../../工具/tools.html">工具</a>
		<a href="../../../阅读/read.html">阅读</a>
		<a href="../../../娱乐/play.html">娱乐</a>
	</div>
	<div class="left_body">
		<ul>
			<li><a href="./c.html">c</a></li>
			<li><a href="../c++/c++.html">c++</a></li>
			<li><a href="../css/css.html">css</a></li>
			<li><a href="../html/html.html">html</a></li>
			<li><a href="../协议/http/http.html">http</a></li>
			<li><a href="../java/java.html">java</a></li>
			<li><a href="../javascript/javascript.html">javascript</a></li>
			<li><a href="../python/python.html">python</a></li>
			<li><a href="../sql/sql.html">Sql</a></li>
			<li><a href="../php/php.html">php</a></li>
			<li><a href="../photoshop/photoshop.html">PS</a></li>
			<li><a href="../cad/cad.html">CAD</a></li>
			<li><a href="../硬件/硬件.html">硬件</a></li>
			<li><a href="../语言/语言.html">语言</a></li>
			<li><a href="../系统/系统.html">系统</a></li>
		</ul>
	</div>
	<div class="table_body">
		<a href="#stdio">stdio.h</a><br><a href="#ctype">ctype.h</a><br><a href="#assert">assert.h</a><br><a href="#time">time.h</a><br><a href="#"></a><br>
		<a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br><a href="#"></a><br>
		<a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br><a href="#"></a><br>
		<a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br><a href="#"></a><br>
		<a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br><a href="#"></a><br>
		<a href=""></a><br><a href=""></a><br><a href=""></a><br><a href=""></a><br><a href="#"></a><br>
	</div>
	<div class="main_body">
		<div id="stdio">
			<h3>stdio.h</h3>
			<ol>
			<li>int printf(const char *format, ...)：将内容输出到屏幕，成功返回输出的字符数，失败返回负值。
				<ul>
				<li>%d：十进制有符号整数</li>
				<li>%u：十进制无符号整数</li>
				<li>%f：浮点数</li>
				<li>%s：字符串</li>
				<li>%c：单个字符</li>
				<li>%x/%X：十六进制</li>
				<li>%p：输出指针类型自身的值，也就是指针指向的地址值，十六进制形式</li>
				<li>%e：指数形式的浮点数</li>
				<li>%o：无符号以八进制表示的整数</li>
				<li>%g：把输出的值按照%e或者%f类型中输出长度较小的方式输出</li>
				<li>%lu：32位无符号整数</li>
				<li>%llu：64位无符号整数</li>
				<li>%ld/%lf：输出长整型，双精度浮点型 double</li>
				<li>其他：\n 换行；\f 清屏并换页；\r 回车；\t 制表符；\xhh 表示用十六进制显示 ascii</li>
				</ul>
				注意：<br/>
				1.可在 % 和字母之间加入数字表示最大场宽，若有小数点，小数点后的数为小数位数，小数点前面的数为小数点后数+小数点+小数前的整数部分<br/>
				2.若字符串长度或整数位数超过场宽则按实际长度输出<br/>
				3.浮点数的整数部分超过场宽按实际输出，小数部分超过则四舍五入<br/>
				4.若想用0补齐则 % 后数字前加 0 即可<br/>
				5.如果用非浮点数表示字符或整型量的输出格式，小数点后的数字代表最大宽度，小数点前的数字代表最小宽度，小数点后的数表示全部数据大于此时以后的数据内容将被删除<br/>6.控制左对齐或右对齐，即在 % 和字母之间加个 - 减号即可表示左对齐，否则右对齐<br/>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					int main(){<br/>
						&nbsp; printf("start......\n");<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int fprintf(FILE *fp, const char *format, ...)：输出到流文件<br/>
				fp：指向 FILE 对象的指针<br/>
				format：字符串，包含写入参 1 的文本<br/>
				第一个printf类似，只不过第一个是将流数据打印到屏幕，而这里是将流数据写入参 1 指定的文件中，直到遇到‘\0’为止。其中 format 参数代替值格式为 %[flags][width][.precision][length]specifier，具体如下：<br/>
				specifier：说明符
				<ul>
				<li>c：字符</li>
				<li>d/i：有符号十进制整数</li>
				<li>e/E：科学记数法</li>
				<li>f：浮点数</li>
				<li>g/G：自动选择 %e/%E 或 %f 合适的表示法</li>
				<li>o：有符号八进制</li>
				<li>s：字符的字符串</li>
				<li>u：无符号十进制整数</li>
				<li>x/X：无符号十六进制整数</li>
				<li>p：指针地址</li>
				<li>n：无输出</li>
				<li>%：两个 % 即转义的 % 字符</li>
				</ul>
				flags：标识
				<ul>
				<li>-：左对齐（默认右对齐）</li>
				<li>+：强制在结果前加入符号位（默认情况只有负数有显示 - 号符号位，而正数忽略）</li>
				<li>(space)：没有写入任何符号，插入空格</li>
				<li>#：与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X；与 e、E 和 f 一起使用时，会强制输出包含一个小数点，即使后边没有数字时也会显示小数点。默认情况下，如果后边没有数字时候，不会显示显示小数点；与 g 或 G 一起使用时，结果与使用 e 或 E 时相同，但是尾部的零不会被移除</li>
				<li>0：在指定填充 padding 的数字左边放置零（0），而不是空格</li>
				</ul>
				width：宽度
				<ul>
				<li>(number)：要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充。如果输出的值长于该数，结果不会被截断</li>
				</ul>
				.precision：精度
				<ul>
				<li>.number：对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符；对于 e、E 和 f 说明符：要在小数点后输出的小数位数；对于 g 和 G 说明符：要输出的最大有效位数；对于 s: 要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符；对于 c 类型：没有任何影响；当未指定任何精度时，默认为 1。如果指定时不带有一个显式值，则假定为 0</li>
				<li>.*：精度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前</li>
				</ul>
				length：长度
				<ul>
				<li>h：参数被解释为短整型或无符号短整型（仅适用于整数说明符：i、d、o、u、x 和 X）</li>
				<li>l：参数被解释为长整型或无符号长整型，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）</li>
				<li>L：参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。</li>
				</ul>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;fcntl.h><br/>
					int main(){<br/>
						&nbsp; FILE *fp;<br/>
						&nbsp; fp=fopen("./main.c","a+");<br/>
						&nbsp; fprintf(fp,"this is project...\n");<br/>
						&nbsp; fclose(fp);<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int sprintf(char *str, const char *format, ...)：把格式化的数据写入某个字符串缓冲区<br/>
				str：指向字符数组的指针<br/>
				format：格式化字符串，包含了要被写入到字符串 str 的文本，格式化方式和fprintf类似，会自动在末尾加上空字符'\0'<br/>
				返回值：成功返回写入的字符总数，不包括字符串追加在末尾的空字符，失败返回负数
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					int main(){<br/>
						&nbsp; char buff[255];<br/>
						&nbsp; sprintf(buff,"start......\n");<br/>
						&nbsp; printf("%s",buff);//将 buff 打印出来<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int snprintf(char *str, size_t size, const char *format, ...)：按 size 大小输出到字符串str<br/>
				size：截取的字符串长度，包括 '\0‘，即 size=实际长度+1<br/>
				其他值参考如上 sprintf
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					int main(){<br/>
						&nbsp; char buff[255];<br/>
						&nbsp; snprintf(buff,6,"start......\n");//包括 \0<br/>
						&nbsp; printf("%s",buff);//将 start 打印出来<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int vsprintf(char *str, const char *format, va_list arg)：使用参数列表发送格式化输出到字符串
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;stdarg.h><br/>
					char buff[1024];<br/>
					int printff(char *format,...){<br/>
						&nbsp; int n;<br/>
						&nbsp; va_list ap;<br/>
						&nbsp; va_start(ap,format);<br/>
						&nbsp; n = vsprintf(buff,format,ap);<br/>
						&nbsp; va_end(ap);<br/>
						&nbsp; return n;<br/>
					}<br/>
					int main(){<br/>
						&nbsp; printff("start......\n");<br/>
						&nbsp; printf("%s",buff);<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>FILE *fopen(char *filename, char *mode)：打开文件<br/>
				filename：文件名，包括文件路径，两个反斜杠中第一个反斜杠为转义字符。<br/>
				mode：打开方式。<br/>
				<ul><li>r：只读，并且文件必须已存在；</li>
				<li>b：二进制文件</li>
				<li>t：文本文件</li>
				<li>w：只写，若打开的文件不存在则以指定的文件名创建该文件，若文件已存在则将该文件删除重新创建新文件</li>
				<li>a：追加，若文件不存在则尝试创建该文件</li>
				<li>+：读写</li></ul>
				返回值：成功返回为FILE 类型的结构体变量的地址（获取文件信息，包括文件名、文件状态、当前读写位置等信息），若返回为NULL，则表示打开失败
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					int main(){<br/>
						&nbsp; FILE *fp=fopen("main.c","a+");<br/>
						&nbsp; if(fp == NULL)<br/>
						&nbsp; {<br/>
							&nbsp; &nbsp; printf("open fail.\n");<br/>
						&nbsp; }<br/>
						&nbsp; fclose(fp);<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>void setbuf(FILE *fp, char *buffer)：主要用于打开和关闭缓冲机制。<br/>
				fp：标识一个打开的流<br/>
				buffer：分配给用户的缓存，为 NULL 表示关闭缓存
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					int main(){<br/>
						&nbsp; char buff[BUFSIZ];//长度至少为 BUFSIZ，否则存在缓冲溢出可能<br/>
						&nbsp; setbuf(stdout,buff);<br/>
						&nbsp; printf("start......\n");<br/>
					}<br/>
					或<br/>
					#include &lt;stdio.h><br/>
					int main(){<br/>
						&nbsp; char *buff = NULL<br/>
						&nbsp; FILE *fp=fopen("main.c","a+");<br/>
						&nbsp; setbuf(fp,buff);//不使用流缓冲<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>char *fgets(char *str, int n, FILE *fp)：从指定的流中读取数据，每次读取一行，读取的数据放入 str 中。<br/>
				str：指向数组的指针，数组存储读取的字符串<br/>
				n：读取的最大字符数，包括最后的控制阀，若未到此值遇到换行符或已到达文件末尾则会停止<br/>
				fp：指向 FILE 对象的指针<br/>
				返回值：成功返回相同的 str ，若到文件末尾或者没有读取到任何字符，str 的内容不变，返回一个空指针。发生错误，返回空指针。<br/>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					int main(){<br/>
						&nbsp; char buff[1024];<br/>
						&nbsp; FILE *fp;<br/>
						&nbsp; char *p;<br/>
						&nbsp; fp=fopen("main.c","r");<br/>
						&nbsp; if(fp == NULL){<br/>
							&nbsp; &nbsp; printf("file open fail.\n");<br/>
							&nbsp; &nbsp; return 0;<br/>
						&nbsp; }<br/>
						&nbsp; while(1){<br/>
							&nbsp; &nbsp; p=fgets(buff,1024,fp);<br/>
							&nbsp; &nbsp; if((p == NULL)||(buff == NULL))<br/>
								&nbsp; &nbsp; &nbsp; break;<br/>
							&nbsp; &nbsp; printf("%s",p);<br/>
						&nbsp; }<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int fclose( FILE *fp )：关闭一个流并刷新所有缓冲区。可以把缓冲区内最后剩余的数据输出到内核缓冲区，并释放文件指针和有关的缓冲区。<br/>
				fp：指向 FILE 对象的指针<br/>
				返回值：成功返回 0，失败返回 EOF（-1）<br/>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					int main(){<br/>
						&nbsp; FILE *fp;<br/>
						&nbsp; fp=fopen("main.c","r");<br/>
						&nbsp; if(fp == NULL){<br/>
							&nbsp; &nbsp; printf("file open fail.\n");<br/>
						&nbsp; }<br/>
						&nbsp; else{<br/>
							&nbsp; &nbsp; printf("file is open.\n");<br/>
							&nbsp; &nbsp; if(fclose(fp) == EOF)<br/>
								&nbsp; &nbsp; &nbsp; printf("file close fail.\n");<br/>
						&nbsp; }<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>void perror(const char *str)：将上一个函数发生错误原因输出到标准设备，str 会先打印出来，然后再加上冒号和空格，最后加上错误原因（依据 errno 输出错误原因）<br/>
				str：自定义消息，输出再错误消息之前<br/>
				即输出为：str: error（每个 error 指对应一个错误的字符串信息）<br/>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					int main(){<br/>
						&nbsp; FILE *fp;<br/>
						&nbsp; fp=fopen("main1.c","r");//并没有 main1.c 这个文件<br/>
						&nbsp; if(fp == NULL){<br/>
							&nbsp; &nbsp; perror("file open fail");//除了输出这段，还会打印后面的错误信息<br/>
						&nbsp; }<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int vprintf(const char *format, va_list arg)：使用参数列表发送格式化输出到标准输出 stdout<br/>
				format：包含了要被写入到标准输出 stdout 的文本，format 标签属性是 %[flags][width][.precision][length]specifier，具体 format 请参考 fprintf 函数。<br/>
				arg：可变参数列表的对象<br/>
				返回值：成功返回字节数，失败返回负数
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;stdarg.h><br/>
					int printff(char *format,...){<br/>
						&nbsp; int n;<br/>
						&nbsp; va_list ap;<br/>
						&nbsp; va_start(ap,format);<br/>
						&nbsp; n = vprintf(format,ap);<br/>
						&nbsp; va_end(ap);<br/>
						&nbsp; return n;<br/>
					}<br/>
					int main(){<br/>
						&nbsp; printff("start......\n");<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int vfprintf(FILE *fp, const char *format, va_list arg)：使用参数列表发送格式化输出到流 fd 中<br/>
				fp：文件标识符，可以是 fopen 打开的文件<br/>
				format：包含了要被写入到流 stream 中的文本，format 标签属性是 %[flags][width][.precision][length]specifier，具体请参考 fprintf 函数<br/>
				arg：可变参数列表的对象<br/>
				返回值：成功返回字节数，失败返回负数<br/>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;stdarg.h><br/>
					FILE *fp;<br/>
					int printff(char *format,...){<br/>
						&nbsp; int n;<br/>
						&nbsp; va_list ap;<br/>
						&nbsp; va_start(ap,format);<br/>
						&nbsp; n = vfprintf(fp,format,ap);//保存到 fp 文件流中<br/>
						&nbsp; va_end(ap);<br/>
						&nbsp; return n;<br/>
					}<br/>
					int main(){<br/>
						&nbsp; fp=fopen("main.c","a+");<br/>
						&nbsp; if(fp == NULL){<br/>
							&nbsp; &nbsp; perror("open fail");<br/>
							&nbsp; &nbsp; return 0;<br/>
						&nbsp; }<br/>
						&nbsp; printff("this is project.");<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>long ftell(FILE *fp)：用于得到文件位置指针当前位置相对于文件首的偏移字节数。<br/>
				fp：文件标识符，可以是 fopen 打开的文件<br/>
				返回值：返回位置标识符的当前值。如果发生错误，则返回 -1L<br/>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					int main(){<br/>
						&nbsp; FILE *fp;<br/>
						&nbsp; char buff[1024];<br/>
						&nbsp; fp=fopen("socket_test.c","a+");<br/>
						&nbsp; if(fp == NULL){<br/>
							&nbsp; &nbsp; perror("open fail");<br/>
							&nbsp; &nbsp; return 0;<br/>
						&nbsp; }<br/>
						&nbsp; printf("file curret position is %ld\n",ftell(fp));<br/>
						&nbsp; fgets(buff,1024,fp);<br/>
						&nbsp; printf("file curret position is %ld\n",ftell(fp));<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int fseek(FILE *fp,long offset,int from)：设置 fp 的文件位置为给定的偏移 offset<br/>
				fp：文件标识符<br/>
				offset：相对 from 的偏移量，以字节为单位<br/>
				from：开始添加偏移 offset 的位置，值如下：<br/>
				&nbsp; SEEK_SET：文件的开头<br/>
				&nbsp; SEEK_CUR：文件指针的当前位置<br/>
				&nbsp; SEEK_END：文件的末尾<br/>
				返回值：成功返回 0，失败返回非 0<br/>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					int main(){<br/>
						&nbsp; FILE *fp;<br/>
						&nbsp; char buff[1024];<br/>
						&nbsp; fp=fopen("socket_test.c","r");<br/>
						&nbsp; fseek(fp,10,SEEK_SET);<br/>
						&nbsp; fgets(buff,1024,fp);<br/>
						&nbsp; printf("%s\n",buff);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li>stdin：c 标准输入流；<br/>
				stdout：c 标准输出流<br/>
				errno：错误，可使用 strerror(errno) 获取对应的错误输出</li>
			<li></li>
			</ol>
			</div><hr/>
		<div id="ctype">
			<h3>ctype.h</h3>
			<ol>
			<li>int toupper(int c)：把小写字母转换为大写字母<br/>
				c：字符<br/>
				返回值：如果 c 有相对应的大写字母，则该函数返回 c 的大写字母，否则 c 保持不变。<br/>
				举例：char a='c';printf("%c\n",toupper(a));</li>
			<li>int tolower(int c)：把给定的字母转换为小写字母<br/>
				c：字符<br/>
				返回值：如果 c 有相对应的小写字母，则该函数返回 c 的小写字母，否则 c 保持不变。<br/>
				举例：char a='C';printf("%c",tolower(a));</li>
			<li>int isxdigit(int c)：检查所传的字符是否是十六进制数字，十六进制一般用数字 0 到 9 和字母 A 到 F（或 a~f）<br/>
				c：传入的数值<br/>
				返回值：成功返回非 0，失败返回 0<br/>
				举例：int a='C';printf("%d\n",isxdigit(a));</li>
			<li>int isupper(int c)：检查所传的字符是否是大写字母<br/>
				c：字符<br/>
				返回值：成功返回非 0，失败返回 0<br/>
				举例：int a='C';printf("%d\n",isupper(a));</li>
			<li>int islower(int c)：检查所传的字符是否是小写字母<br/>
				c：字符<br/>
				返回值：成功返回非 0，失败返回 0<br/>
				举例：int a='c';printf("%d\n",islower(a));</li>
			<li>int isspace(int c)：检查所传的字符是否是空白字符<br/>
				c：字符<br/>
				返回值：成功返回非 0，失败返回 0<br/>
				空白字符包括：空格符' '、tab水平制表符'\t'、换行符'\n'、tab垂直制表符'\v'、换页符'\f'、回车符'\r'<br/>
				举例：int a=' ';printf("%d\n",isspace(a));</li>
			<li>int ispunct(int c)：检查所传的字符是否是标点符号字符<br/>
				c：字符<br/>
				返回值：成功返回非 0，失败返回 0<br/>
				举例：int a='.';printf("%d\n",ispunct(a));</li>
			<li>int isprint(int c)：检查所传的字符是否是可打印的<br/>
				c：字符<br/>
				返回值：成功返回非 0，失败返回 0<br/>
				举例：int a='.';printf("%d\n",isprint(a));</li>
			<li>int isgraph(int c)：检查所传的字符是否有图形表示法<br/>
				c：字符<br/>
				返回值：成功返回非 0，失败返回 0<br/>
				举例：int a='.';printf("%d\n",isgraph(a));</li>
			<li>int isdigit(int c)：检查所传的字符是否是十进制数字字符<br/>
				c：字符<br/>
				返回值：成功返回非 0，失败返回 0<br/>
				举例：int a='9';printf("%d\n",isdigit(a));</li>
			<li>int iscntrl(int c)：检查所传的字符是否是控制字符<br/>
				c：字符<br/>
				返回值：成功返回非 0，失败返回 0<br/>
				举例：int a='\t';printf("%d\n",iscntrl(a));</li>
			<li>int isalpha(int c)：检查所传的字符是否是字母<br/>
				c：字符<br/>
				返回值：成功返回非 0，失败返回 0<br/>
				举例：int a='t';printf("%d\n",isalpha(a));</li>
			<li>int isalnum(int c)：检查所传的字符是否是字母和数字<br/>
				c：字符<br/>
				返回值：成功返回非 0，失败返回 0<br/>
				举例：int a='t';printf("%d\n",isalnum(a));</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div id="time">
			<h3>time.h</h3>
			<ol>
			<li>int clock_gettime(clockid_t clk_id,struct timespec *tp)：可以根据需要，获取不同要求的精确时间（可以达到纳秒）。lock_gettime 比 gettimeofday 更加精确<br/>
				clk_id：
				<ul><li>CLOCK_MONOTONIC：从系统启动到这一刻起开始即使，不受系统时间被用户改变影响</li>
				<li>CLOCK_REALTIME：系统时钟时间，随系统实时时间改变而改变，从 1970/1/1,0:0:0 开始计时，中间时刻若系统时间被用户改成其他则对应时间相应改变</li>
				<li>CLOCK_PROCESS_CPUTIME_ID：本进程到当前代码系统 CPU 花费的时间</li>
				<li>CLOCK_THREAD_CPUTIME_ID：本线程到当前代码系统 CPU 花费的时间</li></ul>
				timespec：存储当前时间，秒和纳秒<br/>
				返回值：成功返回 0
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;time.h><br/>
					int main(){<br/>
						&nbsp; struct timespec time_value={0,0};<br/>
						&nbsp; int a=clock_gettime(CLOCK_MONOTONIC,&amp;time_value);<br/>
						&nbsp; printf("sec=%lu,nsec=%lu\n",time_value.tv_sec,time_value.tv_nsec);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int nanosleep(const struct timespec *req, struct timespec *rem)：暂停某个进程直到指定的时间后恢复。<br/>
				req：要暂停的时间，req->tv_sec 是以秒为单位，而 req->tv_nsec 以毫微秒为单位<br/>
				rem：剩余微秒时间<br/>
				返回值：成功返回 0，失败返回 -1，剩余微秒数纪录在 rem 中
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;time.h><br/>
					int main(){<br/>
						&nbsp; while(1)<br/>
						&nbsp; {<br/>
							&nbsp; &nbsp; struct timespec rem,req={5,600000};<br/>
							&nbsp; &nbsp; printf("process start...\n");<br/>
							&nbsp; &nbsp; nanosleep(&amp;req,&rem);<br/>
							&nbsp; &nbsp; printf("process ending...\n");<br/>
							&nbsp; &nbsp; break;<br/>
						&nbsp; }<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
				</li>
			<li>time_t time(time_t *timer)：返回自纪元（1970/1/1,00:00:00 UTC）起经过的时间，以秒为单位<br/>
				timer：time_t（为长整数别名）<br/>
				返回值：返回总秒数。
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;time.h><br/>
					int main(){<br/>
						&nbsp; time_t time_value;<br/>
						&nbsp; time_value=time(NULL);//NULL 表示从 1970-1-1 开始计时<br/>
						&nbsp; printf("%ld\n",time_value);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>struct tm *localtime(const time_t *timer)：使用 timer 的值来填充 tm 结构。timer 的值被分解为 tm 结构，并用本地时区表示。<br/>
				timer：指向表示日历时间的 time_t 值的指针。<br/>
				返回值：tm 结构指针<br/>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;time.h><br/>
					int main(){<br/>
						&nbsp; struct tm *tm_value;<br/>
						&nbsp; time_t alltime = time(NULL);<br/>
						&nbsp; tm_value = localtime(&amp;alltime);<br/>
						&nbsp; printf("%d-%d-%d,%d:%d:%d",tm_value->tm_year,tm_value->tm_mon,tm_value->tm_mday,tm_value->tm_hour,tm_value->tm_min,tm_value->tm_sec);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr)：格式化结构体 timeptr 表示的时间，并将值存储在 str 中。<br/>
				str：指向目标数组的指针<br/>
				maxsize：被复制到 str 最大字节数<br/>
				format：格式化字符串，包含了要被写入到字符串，具体格式化如下：<br/>
				<table border="1">
					<tr><th>格式化字符</th><th>描述</th><th>示例</th></tr>
					<tr><td>%a</td><td>缩写的星期</td><td>Sun</td></tr>
					<tr><td>%A</td><td>完整的星期</td><td>Sunday</td></tr>
					<tr><td>%b</td><td>缩写的月份</td><td>Mar</td></tr>
					<tr><td>%B</td><td>完整的月份</td><td>March</td></tr>
					<tr><td>%c</td><td>日期和时间表示法</td><td>Sun Aug 19 09:41:23 2021</td></tr>
					<tr><td>%C</td><td>年份的前 2 个数</td><td>21</td></tr>
					<tr><td>%d</td><td>一月中的第几天（01-31）</td><td>20</td></tr>
					<tr><td>%D</td><td>月/天/年</td><td>05/02/21</td></tr>
					<tr><td>%F</td><td>年-月-日</td><td>21-02-05</td></tr>
					<tr><td>%H</td><td>24小时个数的小时（00-23）</td><td>20</td></tr>
					<tr><td>%l</td><td>12小时个数的小时（01-12）</td><td>10</td></tr>
					<tr><td>%j</td><td>一年中的第几天（001-366）</td><td>100</td></tr>
					<tr><td>%m</td><td>十进制的月份（01-12）</td><td>10</td></tr>
					<tr><td>%M</td><td>分钟（00-59）</td><td>20</td></tr>
					<tr><td>%p</td><td>AM 或 PM 名称</td><td>PM</td></tr>
					<tr><td>%S</td><td>秒针（00-59）</td><td>20</td></tr>
					<tr><td>%U</td><td>一年中的第几周，以第一星期日作为第一周的第一天（00-53）</td><td>20</td></tr>
					<tr><td>%w</td><td>十进制的星期（0-6）</td><td>1</td></tr>
					<tr><td>%W</td><td>一年中的第几周，以第一星期一作为第一周的第一天（00-53）</td><td>20</td></tr>
					<tr><td>%x</td><td>日期表示法</td><td>21/02/05</td></tr>
					<tr><td>%X</td><td>时间表示法</td><td>08:49:32</td></tr>
					<tr><td>%y</td><td>年份（00-99）</td><td>21</td></tr>
					<tr><td>%Y</td><td>年份</td><td>2021</td></tr>
					<tr><td>%Z</td><td>时区名称或缩写</td><td>CDT</td></tr>
					<tr><td>%</td><td></td><td></td></tr>
				</table>
				timeptr：指向 tm 结构的指针<br/>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;time.h><br/>
					int main(){<br/>
						&nbsp; char buff[215];<br/>
						&nbsp; struct tm *tm_value;<br/>
						&nbsp; time_t alltime = time(NULL);<br/>
						&nbsp; tm_value = localtime(&amp;alltime);<br/>
						&nbsp; strftime(buff,215,"%F,%X",tm_value);<br/>
						&nbsp; printf("%s\n",buff);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>clock_t clock(void)：处理器时钟所使用时间，一般用于计时程序或程序某一段的执行时间<br/>
				返回值：时间，clock_t 是长整型<br/>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;time.h><br/>
					int main(){<br/>
						&nbsp; clock_t start,end;<br/>
						&nbsp; start=clock();<br/>
						&nbsp; for(int i=0;i<10000;i++)<br/>
							&nbsp; &nbsp; ;<br/>
						&nbsp; end=clock();<br/>
						&nbsp; printf("%ld",end-start);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>char *asctime(const struct tm *timeptr)：把 timeptr 指向的 tm 结构体中储存的时间转换为字符串<br/>
				timeptr：tm 结构体指针<br/>
				返回值：返回的字符串格式为：Www Mmm dd hh:mm:ss yyyy。其中Www为星期；Mmm为月份；dd为日；hh为时；mm为分；ss为秒；yyyy为年份。
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;time.h><br/>
					int main(){<br/>
						&nbsp; struct tm *tmvalue;<br/>
						&nbsp; time_t alltime = time(NULL);<br/>
						&nbsp; tmvalue = localtime(&amp;alltime);<br/>
						&nbsp; printf("%s",asctime(tmvalue));<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>char *ctime(const time_t *timer)： 把日期和时间转换为字符串<br/>
				timer：包含日历时间的 time_t 指针<br/>
				返回值：返回的字符串格式为：Www Mmm dd hh:mm:ss yyyy 其中，Www 表示星期几，Mmm 是以字母表示的月份，dd 表示一月中的第几天，hh:mm:ss 表示时间，yyyy 表示年份。<br/>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;time.h><br/>
					int main(){<br/>
						&nbsp; time_t curtime;<br/>
						&nbsp; time(&amp;curtime);<br/>
						&nbsp; printf("%s", ctime(&amp;curtime));<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>double difftime(time_t time1, time_t time2)：计算时间差<br/>
				time1：结束时间<br/>
				time2：开始时间<br/>
				返回值：两时间差（time1-time2），以秒为单位
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;time.h><br/>
					#include &lt;unistd.h><br/>
					int main(){<br/>
						&nbsp; time_t start_t, end_t;<br/>
						&nbsp; double diff_t;<br/>
						&nbsp; time(&amp;start_t);<br/>
						&nbsp; sleep(5);<br/>
						&nbsp; time(&amp;end_t);<br/>
						&nbsp; diff_t = difftime(end_t, start_t);<br/>
						&nbsp; printf("diff time is %f\n", diff_t);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form></li>
			<li>struct tm *gmtime(const time_t *timer)：把日期和时间转换成格林威治（GMT）时间<br/>
				timer：长整型<br/>
				返回值：返回转换后的 tm 结构的时间
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;time.h><br/>
					int main(){<br/>
						&nbsp; time_t curtime;<br/>
						&nbsp; struct tm *tmtime;<br/>
						&nbsp; time(&amp;curtime);<br/>
						&nbsp; tmtime = gmtime(&amp;curtime);<br/>
						&nbsp; printf("english:%2d:%02d\n",(tmtime->tm_hour+0)%24, tmtime->tm_min);<br/>
						&nbsp; printf("china:%2d:%02d\n", (tmtime->tm_hour+8)%24, tmtime->tm_min);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>time_t mktime(struct tm *timeptr)：将时间转换为自1970年1月1日以来持续时间的秒数<br/>
				timeptr：tm 结构体<br/>
				返回值：成功返回总秒数，失败返回 -1
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;time.h><br/>
					int main(){<br/>
						&nbsp; time_t curtime,alltime;<br/>
						&nbsp; struct tm *tmtime;<br/>
						&nbsp; time(&amp;curtime);<br/>
						&nbsp; printf("current is %ld\n",curtime);//本地时间（北京东八区+8）<br/>
						&nbsp; tmtime = gmtime(&amp;curtime);<br/>
						&nbsp; alltime=mktime(tmtime);<br/>
						&nbsp; printf("all time is %ld\n",alltime);//格林威治时间<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
			</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li>size_t：无符号整型；<br/>
				clock_t：长整型<br/>
				time_t：长整型<br/>
				tm：存储时间的结构体</li>
			<li>tm：<br/>
				struct tm {<br/>
					&nbsp; int tm_sec; //秒，范围从 0 到 59<br/>
					&nbsp; int tm_min; //分，范围从 0 到 59<br/>
					&nbsp; int tm_hour; //小时，范围从 0 到 23<br/>
					&nbsp; int tm_mday; //一月中的第几天，范围从 1 到 31<br/>
					&nbsp; int tm_mon; //月份，范围从 0 到 11<br/>
					&nbsp; int tm_year; //自 1900 起的年数<br/>
					&nbsp; int tm_wday; //一周中的第几天，范围从 0 到 6<br/>
					&nbsp; int tm_yday; //一年中的第几天，范围从 0 到 365<br/>
					&nbsp; int tm_isdst; //夏令时<br/>
				};</li>
			<li>timespec：<br/>
				struct timespec{<br/>
					&nbsp; __time_t tv_sec; /* Seconds.  */<br/>
					&nbsp; long int tv_nsec; /* Nanoseconds.  */<br/>
				};</li>
			<ol>
			</div><hr/>
		<div>
			<h3>stdarg.h</h3>
			<ol>
			<li>void va_start(va_list ap, last_arg)：初始化 ap 变量，它与 va_arg 和 va_end 宏是一起使用的。last_arg 是最后一个传递给函数的已知的固定参数，即省略号之前的参数。注意这个宏必须在使用 va_arg 和 va_end 之间被调用。</li>
			<li>type va_arg(va_list ap, type)：检索函数参数列表中类型为 type 的下一个参数。它无法判断检索到的参数是否是传给函数的最后一个参数。</li>
			<li>void va_end(va_list ap)：允许使用了 va_start 宏的带有可变参数的函数返回。如果在从函数返回之前没有调用 va_end，则结果为未定义。<br/>
				<form>
				<fieldset>
					<legend>** <b>整体实现</b> **</legend>
				#include &lt;iostream><br/>
				#include &lt;stdarg.h><br/>
				FILE fp;<br/>
				//和 printf 函数一致<br/>
				int printff(char *format,...){<br/>
					&nbsp; int n;<br/>
					&nbsp; va_list ap;<br/>
					&nbsp; va_start(ap,format);//获取可变参数列表第一个参数地址<br/>
					&nbsp; n = vprintf(format,ap);//使用参数列表发送格式化输出到标准输出<br/>
					&nbsp; va_end(ap);//清空va_list可变参数列表<br/>
					&nbsp; return n;<br/>
				}<br/>
				int sum(int num,...){<br/>
					&nbsp; int all=0;<br/>
					&nbsp; va_list ap;<br/>
					&nbsp; va_start(ap,num);<br/>
					&nbsp; for(int i=0;i &lt; num;i++){<br/>
						&nbsp; &nbsp; all += va_arg(ap,int);//获取可变参数的当前参数，返回指定类型并将指针指向下一个参数<br/>
					&nbsp; }<br/>
					&nbsp; va_end(ap);<br/>
					&nbsp; return all;<br/>
				}<br/>
				//打印到屏幕并输出到文件<br/>
				void log(const char *format,...){<br/>
					&nbsp; int p_file;<br/>
					&nbsp; va_list ap;<br/>
					&nbsp; va_start(ap,format);<br/>
					&nbsp; vprintf(format,ap);<br/>
					&nbsp; p_file=ftell(fp);//获取当前位置<br/>
					&nbsp; if(p_file>=1024*10)<br/>
						&nbsp; &nbsp; fseek(fp,0L,SEEK_SET);//将位置移到文件开头的起始位置；0L 为起始位置；100L 为离开头 100 字节位置<br/>
					&nbsp; vfprintf(fp,format,ap);<br/>
					&nbsp; va_end(ap);<br/>
				}<br/>
				int main(){<br/>
					&nbsp; printff("1-9 sum is %d\n",sum(10,0,1,2,3,4,5,6,7,8,9));<br/>
					&nbsp; fp=fopen("test.txt","a+");<br/>
					&nbsp; log("this is log0\n");<br/>
					&nbsp; log("this is log1\n");<br/>
					&nbsp; fclose(fp);<br/>
					&nbsp; fp=fopen("test.txt","a+");//若 a+ 改成 w，则会清空文件里的内容，重新写入<br/>
					&nbsp; log("this is log2\n");<br/>
					&nbsp; log("this is log3\n");<br/>
					&nbsp; fclose(fp);<br/>
					&nbsp; return 0;<br/>
				}</fieldset>
				</form>
				</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li>va_list：<br/>
			#ifdef _M_ALPHA<br/>
				&nbsp; typedef struct {<br/>
				&nbsp; char *a0; /* pointer to first homed integer argument */<br/>
				&nbsp; int offset; /* byte offset of next parameter */<br/>
			} va_list;<br/>
			#else<br/>
			typedef char * va_list;<br/>
			#endif</li>
			<ol>
			</div><hr/>
		<div>
			<h3>fcntl.h</h3>
			<ol>
			<li>int open(const char *pathname,int flags)/int open(const char *pathname, int flags, mode_t mode)：打开文件<br/>
				pathname：要打开或创建的目标文件，比如 /dev/ttyS0（即 COM1）<br/>
				flags：打开文件时，可以传入多个参数选项，用下面的一个或者多个常量进行“或”运算，构成 falgs
				<ul>
					<li>O_RDONLY：只读打开</li>
					<li>O_WRONLY：只写打开</li>
					<li>O_RDWR：读，写打开</li>
				</ul>
				上面三个常量，必须指定一个且只能指定一个
				<ul>
				<li>O_CREAT：若文件不存在，则创建它，需要使用 mode 选项。来指明新文件的访问权限</li>
				<li>O_APPEND：追加写，如果文件已经有内容，这次打开文件所写的数据附加到文件的末尾而不覆盖原来的内容</li>
				<li>O_NOCTTY：如果路径名指向终端设备，不要把这个设备用作控制终端</li>
				<li>O_NONBLOCK：如果路径名指向 FIFO/块文件/字符文件，则把文件的打开和后继 I/O 设置为非阻塞模式</li>
				<li>O_NDELAY：对于串口的打开操作，必须使用 O_NOCTTY 参数，它表示打开的是一个终端设备，程序不会成为该端口的控制终端。如果不使用此标志，任务的一个输入(比如键盘终止信号等)都会影响进程<br/>
					设置了 O_NDELAY 而当前不可写，那么 write 接口会设置 errno 为 EAGAIN，但是 write 接口会返回 0 而不是 -1</li>
				<li>O_TRUNC：如果文件存在，并且以只写/读写方式打开，则清空文件全部内容</li>
				<li>O_EXCL：如果要创建的文件已存在，则返回 -1，并且修改 errno 的值</li>
				<li>O_DSYNC：等待物理 I/O 结束后再 write。在不影响读取新写入的数据的前提下，不等待文件属性更新</li>
				<li>O_RSYNC：读(read)等待所有写入同一区域的写操作完成后再进行</li>
				<li>O_SYNC：等待物理 I/O 结束后再 write，包括更新文件属性的 I/O</li>
				</ul>
				返回值：成功返回新打开的文件描述符，失败返回 -1<br/>
				如目标文件存在，使用两个参数的 open，如果目标文件不存在，需要 open 创建，则第三个参数表示创建文件的默认权限<br/>
				打开的文件描述符一定要记得关闭，否则资源会被大量的占用，导致内存不够<br/>
				fopen 和 open 区别：以可写的方式 fopen 一个文件时，如果文件不存在则会自动创建，而 open 一个文件时必须明确 O_CREAT 才会创建文件，否则文件不存在就出错返回，并且 fopen 打开的是 FILE 文件流，open 打开的是 int
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;fcntl.h><br/>
					#include &lt;string.h><br/>
					#include &lt;unistd.h><br/>
					int main(){<br/>
						&nbsp; int fd=0;<br/>
						&nbsp; char buff[21];<br/>
						&nbsp; memset(buff,0,21);<br/>
						&nbsp; fd=open("./main.c",O_RDWR|O_APPEND);<br/>
						&nbsp; read(fd,buff,20);<br/>
						&nbsp; printf("%s\n",buff);<br/>
						&nbsp; write(fd,"hello,world\n",strlen("hello,world\n"));<br/>
						&nbsp; close(fd);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int fcntl(int fd, int cmd)/int fcntl(int fd, int cmd, long arg)/int fcntl(int fd, int cmd, struct flock *lock)：根据文件描述词来操作文件的特性<br/>
				fd：文件描述符<br/>
				cmd：命令参数
					<ul><li>F_DUPFD：复制一个现有的描述符，返回新的文件描述符，返回值具体描述：<br/>
						最小的大于或等于arg的一个可用的描述符<br/>
						与原始操作符一样的某对象的引用如果对象是文件(file)的话,返回一个新的描述符,这个描述符与arg共享相同的偏移量<br/>
						相同的访问模式(读,写或读/写)<br/>
						相同的文件状态标志(如:两个文件描述符共享相同的状态标志) </li>
					<li>F_GETFD/F_SETFD：获得/设置文件描述符标记，返回相应标志</li>
					<li>F_GETFL/F_SETFL：获得/设置文件状态标记，设置给 arg 描述状态标志。如：<br/>
						fcntl(fd,F_SETFL,0) //设置为阻塞<br/>
						fcntl(fd, F_SETFL, flags | O_NONBLOCK) //设置为非阻塞<br/>
						返回相应标志<br/>
						F_SETFL 设置给 arg 描述符状态标志,可以更改的几个标志是：O_APPEND， O_NONBLOCK，O_SYNC和O_ASYNC</li>
					<li>F_GETOWN/F_SETOWN：获得/设置异步 I/O 所有权，返回一个正的进程 ID 或负的进程组 ID</li>
					<li>F_GETLK/F_SETLK/F_SETLKW：获得/设置记录锁</li></ul>
				arg：状态标志
					<ul><li>O_RDONLY</li>
					<li>O_WRONLY</li>
					<li>O_RDWR</li>
					<li>O_APPEND：强制每次写(write)操作都添加在文件大的末尾</li>
					<li>O_NONBLOCK：非阻塞 I/O。如果 read 调用没有可读取的数据，或者如果 write 操作将阻塞，read 或 write 调用返回 -1 和 EAGAIN 错误</li>
					<li>O_SYNC</li>
					<li>O_ASYNC： 当 I/O 可用的时候，允许 SIGIO 信号发送到进程组，例如：当有数据可以读的时候</li></ul>
				lock：
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;unistd.h><br/>
					#include &lt;fcntl.h><br/>
					#include &lt;errno.h><br/>
					#include &lt;string.h><br/>
					#include &lt;stdlib.h><br/>
					#include &lt;stdio.h><br/>

					int main(void){<br/>
						&nbsp; char buf[10];<br/>
						&nbsp; int n;<br/>
						&nbsp; int flags;<br/>
						&nbsp; int i=0;<br/>
						&nbsp; flags = fcntl(STDIN_FILENO, F_GETFL);//获取当前 flags<br/>
						&nbsp; flags |= O_NONBLOCK;//设置新的 flags，非阻塞<br/>
						&nbsp; if (fcntl(STDIN_FILENO, F_SETFL, flags) == -1)//更新 flags<br/>
						&nbsp; {<br/>
							&nbsp; &nbsp; printf("fcntl error.\n");<br/>
							&nbsp; &nbsp; return 0;<br/>
						&nbsp; }<br/>
					tryagain:<br/>
						&nbsp; n = read(STDIN_FILENO, buf, 10);//读取标准输入的数据<br/>
						&nbsp; if (n &lt; 0)//读取失败<br/>
						&nbsp; {<br/>
							&nbsp; &nbsp; if (errno == EAGAIN)<br/>
							&nbsp; &nbsp; {<br/>
								&nbsp; &nbsp; &nbsp; if (i++ > 10)<br/>
									&nbsp; &nbsp; &nbsp; &nbsp; return 0;<br/>
								&nbsp; &nbsp; &nbsp; sleep(1);<br/>
								&nbsp; &nbsp; &nbsp; write(STDOUT_FILENO, "try again\n",strlen("try again\n"));<br/>
								&nbsp; &nbsp; &nbsp; goto tryagain;<br/>
							&nbsp; &nbsp; }<br/>
							&nbsp; &nbsp; printf("read stdin error.\n");<br/>
						&nbsp; }<br/>
						&nbsp; write(STDOUT_FILENO, buf, n);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li>struct flock{<br/>
				short int l_type; //锁定状态<br/>
				short int l_whence; //偏移量的起始位置<br/>
				off_t l_start; //锁定区域开头位置<br/>
				off_t l_len; //锁定区域的大小<br/>
				pid_t l_pid; //锁定动作的进程<br/>
				};<br/>
				l_type 取值有：1.F_RDLCK：建立一个供读取用的锁定（共享锁）；2.F_WRLCK：建立一个供写入用的锁定（互斥锁）；3.F_UNLCK：删除之前建立的锁定（解锁）<br/>
				l_whence 取值有：1.SEEK_SET 以文件开头为锁定的起始位置；2.SEEK_CUR：以目前文件读写位置为锁定的起始位置；3.SEEK_END：以文件结尾为锁定的起始位置<br/>
				l_start：相对 l_whence 位置的偏移量，两者一起确定锁定区域的开始位置<br/>
				l_len：锁定区域的长度，如果为 0 表示从起点(由 l_whence 和 l_start 决定的开始位置)开始直到最大可能偏移量为止。<br/>
				注意：为了锁整个文件，需要将 l_whence、l_start、l_len 都设置为0
			</li>
			<ol>
			</div><hr/>
		<div>
			<h3>unistd.h</h3>
			<ol>
			<li>int close(int fd)：关闭一个已经打开的文件/套接字，参数是需要关闭的文件描述符<br/>
				fd：文件描述符<br/>
				返回值：成功返回 0，失败返回 -1 并设置 errno
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;fcntl.h><br/>
					#include &lt;unistd.h><br/>
					int main(){<br/>
						&nbsp; int fd=0;<br/>
						&nbsp; fd=open("./main.c",O_RDWR|O_APPEND);<br/>
						&nbsp; close(fd);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form></li>
			<li>ssize_t write(int fd, const void *buf, size_t nbyte)：将 buf 数据写入 fd 指定的文件中<br/>
				fd：文件描述符；<br/>
				buf：指定的缓冲区，即指针，指向一段内存单元；<br/>
				nbyte：要写入文件指定的字节数；<br/>
				返回值：写入文档的字节数（成功）；-1（出错）
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;fcntl.h><br/>
					#include &lt;unistd.h><br/>
					int main(){<br/>
						&nbsp; int fd=0;<br/>
						&nbsp; fd=open("./main.c",O_RDWR|O_APPEND);<br/>
						&nbsp; write(fd,"hello,world\n",strlen("hello,world\n"));<br/>
						&nbsp; close(fd);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form></li>
			<li>ssize_t read(int fd, void *buf, size_t count)：将 fd 指定文件中的数据读取到 buf<br/>
				fd：文件描述符<br/>
				buf：缓冲区<br/>
				count：请求读取的字节数<br/>
				返回值：成功返回读取的字节数，失败返回 -1 并设置 errno，若在调用read前已到达文件末尾则返回 0
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;fcntl.h><br/>
					#include &lt;string.h><br/>
					#include &lt;unistd.h><br/>
					int main(){<br/>
						&nbsp; int fd=0;<br/>
						&nbsp; char buff[21];<br/>
						&nbsp; memset(buff,0,21);<br/>
						&nbsp; fd=open("./main.c",O_RDWR|O_APPEND);<br/>
						&nbsp; read(fd,buff,20);<br/>
						&nbsp; printf("%s\n",buff);<br/>
						&nbsp; close(fd);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int access(const char* pathname, int mode)：判断指定的文件或目录是否存在，已存在的文件或目录是否有可读/写/执行<br/>
				pathname：文件路径名，包括文件名<br/>
				mode：模式
				<ul><li>F_OK：值为0，判断文件是否存在</li>
					<li>X_OK：值为1，判断对文件是可执行权限</li>
					<li>W_OK：值为2，判断对文件是否有写权限</li>
					<li>R_OK：值为4，判断对文件是否有读权限</li></ul>
				返回值：成功为 0，失败为 -1
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;unistd.h><br/>
					int main(){<br/>
						&nbsp; int ok;<br/>
						&nbsp; ok = access("./main.c",0);<br/>
						&nbsp; if(ok == 0)<br/>
							&nbsp; &nbsp; printf("file ok\n");<br/>
						&nbsp; else<br/>
							&nbsp; &nbsp; printf("file error\n");<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>unsigned sleep(unsigned seconds)：执行挂起指定的秒数<br/>
				seconds：挂起时间，单位秒<br/>
				返回值：成功返回 0，失败返回剩余秒数<br/>
				sleep()是在库函数中实现的，它是通过alarm()来设定报警时间。具体例子请看 usleep 函数</li>
			<li>void usleep(int micro_seconds)：进程挂起指定的时间<br/>
				micro_seconds：挂起时间，单位微秒（1000000us=1s，1000us=1ms）<br/>
				返回值：成功返回 0，失败返回剩余秒数。
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;unistd.h><br/>
					int main(){<br/>
						&nbsp; printf("one\n");<br/>
						&nbsp; usleep(1000000);//微秒<br/>
						&nbsp; printf("two\n");<br/>
						&nbsp; usleep(1000);<br/>
						&nbsp; printf("three\n");<br/>
						&nbsp; usleep(5000000);<br/>
						&nbsp; printf("four\n");<br/>
						&nbsp; sleep(5);//秒<br/>
						&nbsp; printf("five\n");<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)：允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定时间后才唤醒。<br/>
				nfds：指定待测描述符 +1 个数<br/>
				readfds：select 监视的可读文件描述符集合，即是否可以从这些文件中读取数据了，如果这个集合中有一个文件可读，select 就会返回一个大于 0 的值<br/>
				writefds：select 监视的可写文件描述符集合<br/>
				exceptfds：监视的异常文件描述符集合<br/>
				timeout：select 超时时间，为 NULL 无限等待，仅在有描述符就绪或信号中断才返回（就绪条件：1.接收缓冲区 >= 接收缓冲区低水位标记的大小；2.接收到 FIN 的 TCP 连接；3.监听套接字并已完成的连接数不为0；4.套接字上有个错误待处理）；tv_sec=0 并且 tv_usec=0 不等待（轮询）检测描述符后立即返回<br/>
				返回值：当超时或其中一个/多个文件描述符发生变化时，此函数将返回，成功返回准备就绪的描述符个数，执行出错返回 -1，超时返回 0 并将时间结构体清空<br/>
				fd_set 类型的相关宏：<br/>
				&nbsp; FD_ZERO(fd_set *fdset)：清空 fdset 与所有文件描述符的联系<br/>
				&nbsp; FD_SET(int fd, fd_set *fdset)：建立文件描述符 fd 与 fdset 的联系<br/>
				&nbsp; FD_CLR(int fd, fd_set *fdset)：清除文件描述符 fd 与 fdset 的联系<br/>
				&nbsp; FD_ISSET(int fd, fd_set *fdset)：检查 fdset 联系的文件描述符 fd 是否被置位，返回 0 表示失败，非 0 表示成功<br/>
				原理如下：<br/><img src="./data/socket原理.jpg" alt="socket基本原理"/>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;unistd.h><br/>
					#include &lt;sys/time.h><br/>
					#include &lt;stdio.h><br/>
					#include &lt;string.h><br/>
					#include &lt;sys/ioctl.h><br/>
					#include &lt;fcntl.h><br/>

					#define RECV_AT_MAX_LEN 1024<br/>
					int main(void){<br/>
						&nbsp; struct timeval select_timeouts = {0, 1};<br/>
						&nbsp; fd_set readset;<br/>
						&nbsp; int n = 0 ,ret = 0;<br/>

						&nbsp; select_timeouts.tv_sec = 0;<br/>
						&nbsp; select_timeouts.tv_usec = 0;<br/>

						&nbsp; int fd = open("main.c",O_RDWR | O_NOCTTY | O_NDELAY);<br/>

						&nbsp; if (fd &lt; 0){<br/>
							&nbsp; &nbsp; printf("no this file\n");<br/>
						&nbsp; }else{<br/>
							&nbsp; &nbsp; ioctl(fd, (('R'&lt;&lt;8)|1|(0x4004&lt;&lt;16)), 0x400);<br/>
							&nbsp; &nbsp; ioctl(fd, (('R'&lt;&lt;8)|4|(0x4004&lt;&lt;16)), 0);//从设备驱动层读取数据<br/>
						
							&nbsp; &nbsp; FD_ZERO(&amp;readset);//清空 fdset 与所有文件描述符的联系<br/>
							&nbsp; &nbsp; FD_SET(fd, &amp;readset);//建立文件描述符 fd 与 readset 的联系<br/>
							&nbsp; &nbsp; ret = select(fd+1, &amp;readset, NULL, NULL, &amp;select_timeouts);<br/>

							&nbsp; &nbsp; if(ret > 0)<br/>
							&nbsp; &nbsp; {<br/>
								&nbsp; &nbsp; &nbsp; if(FD_ISSET(fd, &amp;readset))//检查 readset 联系的文件描述符 fd 是否被置位<br/>
								&nbsp; &nbsp; &nbsp; {<br/>
									&nbsp; &nbsp; &nbsp; &nbsp; char data[RECV_AT_MAX_LEN+1];<br/>
									&nbsp; &nbsp; &nbsp; &nbsp; memset(data,0,RECV_AT_MAX_LEN+1);<br/>
									&nbsp; &nbsp; &nbsp; &nbsp; n=read(fd,data,RECV_AT_MAX_LEN);<br/>
									&nbsp; &nbsp; &nbsp; &nbsp; if(n>0){<br/>
										&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("len:%d,data:%s",n,data);<br/>
										&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;<br/>
									&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
								&nbsp; &nbsp; &nbsp; }<br/>
							&nbsp; &nbsp; }<br/>
						&nbsp; }<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li>STDIN_FILENO：标准输入<br/>
				STDOUT_FILENO：标准输出<br/>
				STDERR_FILENO：标准错误<br/>
				对比 c 标准库中的标准输入输出错误 stdin、stdout、stderr<br/>
				使用 stdin 的函数主要有：fread、fwrite、fclose等；使用 STDIN_FILENO 的函数有：read、write、close等</li>
			<ol>
			</div><hr/>
		<div>
			<h3>string.h</h3>
			<ol>
			<li>char *strstr(const char *haystack, const char *needle)：在参 1 中查找第一次出现参 2 的位置，不包含终止符‘\0’<br/>
				haystack：要被检索的字符串<br/>
				needle：在第一个参数内搜索的字符<br/>
				返回值：成功返回参 2 第一次在参 1 中出现的位置，失败返回 null
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;string.h><br/>
					#include &lt;stdio.h><br/>
					int main(){<br/>
						&nbsp; char buff[15]="hello,world!";<br/>
						&nbsp; char *p;<br/>
						&nbsp; printf("%s\n",buff);<br/>
						&nbsp; p=strstr(buff,",");<br/>
						&nbsp; printf("%s\n",p);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>void *memset(void *s, int ch, size_t n)：将某一块内存中的内容全部设置为指定的值， 这个函数通常为新申请的内存做初始化工作。<br/>
				s：指向要填充的内存块<br/>
				ch：填充设置的值<br/>
				n：填充的字符数<br/>
				返回值：成功返回指向存储区s的指针
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;string.h><br/>

					int main(void){<br/>
						&nbsp; char data[]="hello,world";<br/>
						&nbsp; memset(data,0x35,sizeof(data));<br/>
						&nbsp; printf("data:%s\n",data);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>void *memcpy(void *dest, const void *src, size_t n)：从源内存地址的起始位置开始拷贝若干个字节到目标内存地址中<br/>
				dest：指向用于存储复制内容的目标数组，类型强制转换为 void* 指针<br/>
				src：指向要复制的数据源，类型强制转换为 void* 指针<br/>
				n：要被复制的字节数<br/>
				返回值：指向目标存储区的指针
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;string.h><br/>

					int main(void){<br/>
						&nbsp; char data[]="hello,world";<br/>
						&nbsp; memcpy(data,"hello,children",strlen("hello,children"));<br/>
						&nbsp; printf("data:%s\n",data);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>size_t strlen(const char *str)：计算字符串长度，直到碰到第一个字符串结束符'\0'为止<br/>
				str：要计算的字符串<br/>
				返回值：返回字符串长度，不包括结束符 NULL（‘\0’）
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;string.h><br/>

					int main(void){<br/>
						&nbsp; char data[]="hello,world";<br/>
						&nbsp; printf("len:%d\n", strlen("hello,children"));<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form></li>
			<li>int memcmp(const void *s1, const void *s2, size_t n)：把存储区 s1 和存储区 s2 的前 n 个字节进行比较（按字节比较 ascii 值）。<br/>
				s1：指向内存块的指针<br/>
				s2：指向内存块的指针<br/>
				n：要被比较的字节数<br/>
				返回值：s1&gt;s2 返回正数；s1&lt;s2 返回负数；s1=s2 返回 0</li>
			<li>int strcmp(const char *s1, const char *s2)：比较两个字符串并根据比较结果返回整数。直到出现不同的字符或遇'\0'为止。<br/>
				s1：指向字符串的指针<br/>
				s2：指向字符串的指针<br/>
				返回值：s1&gt;s2 返回正数；s1&lt;s2 返回负数；s1=s2 返回 0</li>
			<li>void bzero(void *s, int n)：置字节字符串前 n 个字节为零且包括‘\0’。<br/>
				s：要置零的数据的起始地址<br/>
				n：要置零的数据字节个数</li>
			<li>int strncmp(const char *s1, const char *s2, size_t n)：比较 s1 和 s2 的前 n 个字节<br/>
				s1：要比较的字符串<br/>
				s2：要比较的字符串<br/>
				返回值：s1&gt;s2 返回正数；s1&lt;s2 返回负数；s1=s2 返回 0</li>
			<li>char *strerror(int errnum)：通过标准错误的标号，获得错误的描述字符串 ，将单纯的错误标号转为字符串描述。<br/>errnum：最新的错误标号<br/>返回值：指向错误信息的指针</li>
			<li>char *strcpy(char* dest, const char *src)：将 src 数据拷贝到 dest 里面<br/>
				src：要复制的数据<br/>
				dest：存储复制内容的数据</li>
			<li>char *strcat(char *dest, const char *src)：把 src 指向的字符串追加到 dest 指向的字符串结尾。<br/>
				dest：指向目标数组<br/>
				src：指向要追加的字符串<br/>
				返回值：返回一个指向最终目标字符串 dest 的指针</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>stdlib.h</h3>
			<ol>
			<li>int system(const char *command)：把参数指定的命令名称或程序名称传给要被命令处理器（window下的dos，linux下的shell）执行的主机环境，并在命令完成后返回<br/>
				command：命令名<br/>
				返回值：成功返回 0，失败返回 -1<br/>
				比如 system("pause") 在 window 下是暂停 cmd 命令界面<br/>
				<form>
				<fieldset>
					<legend>** <b>举例</b> **</legend>
					#include <stdlib.h><br/>
					int main(){<br/>
						&nbsp; char buff[1024]="echo 1 > ./touch";//将 1 写入到此文件<br/>
						&nbsp; //char buff[1024]="ls";//打印当前目录里的文件或目录<br/>
						&nbsp; //char buff[1024]="./xx";//直接执行当前目录下的 xx 文件<br/>
						&nbsp; system(buff);<br/>
						&nbsp; return 0;<br/>
					}
					</fieldset>
				</form>
				</li>
			<li>int atoi(const char *str)：把字符串转换成整型数（会跳过前面空白符）<br/>
				str：要转换成整数的字符串<br/>
				返回值：成功返回转换后的整数，失败或空字符返回 0</li>
			<li>void exit(int status)：立即终止进程<br/>
				status：返回给父进程的状态值<br/>
				exit(0)正常退出；exit(x)异常退出（x 不为 0）</li>
			<li>void *malloc(size_t size)：分配动态内存空间<br/>
				size：内存块大小，以字节为单位<br/>
				返回值：成功返回一个指针，指向已分配大小的内存，失败返回 NULL</li>
			<li>void free(void *ptr)：释放调用 calloc、malloc 或 realloc 分配的内存空间<br/>
				ptr：指针指向一个要释放的内存块</li>
			<li>void *calloc(size_t nitems, size_t size)：动态分配内存空间<br/>
				nitems：要被分配的元素个数<br/>
				size：元素大小，一般可用 sizeof(元素的变量类型，如 int) 获取<br/>
				返回值：成功返回一个指针，指向已分配大小的内存，失败返回 NULL</li>
			<li>void *realloc(void *ptr, size_t size)：重新调整调用 malloc 或 calloc 分配的 ptr 所指向的内存块大小<br/>
				ptr：指针指向一个要重新分配内存的内存块，该内存块之前是通过调用 malloc、calloc 或 realloc 进行分配内存的。如果为空指针，则会分配一个新的内存块，且函数返回一个指向它的指针<br/>
				size：内存块新的大小，以字节为单位<br/>
				返回值：成功返回一个指针，指向重新分配大小的内存，失败返回 NULL</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>sys/ioctl.h</h3>
			<ol>
			<li>int ioctl(int fd, ind cmd, …)：对设备的I/O通道进行管理的函数，驱动层函数。<br/>
				fd：文件描述符（由 socket 或 open 创建）<br/>
				cmd：用户程序对设备的控制命令<br/>
				...（省略号）：可变参数，一般最多一个，依赖 cmd 指定长度及类型<br/>
				返回值：成功返回 0，失败返回 -1 并设置 errorno<br/>
				cmd 格式：<br/><sub>----------------------------------------</sub><br/>
				| dir &nbsp;| size &nbsp;| type&nbsp;|&nbsp;nr &nbsp;|<br/>
				----------------------------------<br/>
				| 2 bit | 14 bit | 8 bit | 8 bit |<br/><sup>----------------------------------------</sup><br/>
				&nbsp; dir：命令访问模式，具体如下：<br/>
					&nbsp; &nbsp; 1._IOC_NONE：值为 0，无数据传输<br/>
					&nbsp; &nbsp; 2._IOC_READ：值为 1，从设备驱动读取数据<br/>
					&nbsp; &nbsp; 3._IOC_WRITE：值为 2，往设备驱动写入数据<br/>
					&nbsp; &nbsp; 4._IOC_READ | _IOC_WRITE：值为 3，双向数据传输<br/>
				&nbsp; size：指定可变参数的数据类型和长度，通常忽略该参数<br/>
				&nbsp; type：设备类型，魔幻数，可以为任意 char 字符<br/>
				&nbsp; nr：命令编号/序号，取值范围 0-255<br/>
				如下 linux 内核已定义 cmd，可直接传入 size、type、size 即可：<br/>
				&nbsp; _IO(type,nr) //没有参数的命令<br/>
				&nbsp; _IOR(type,nr,size) //该命令是从驱动读取数据<br/>
				&nbsp; _IOW(type,nr,size) //该命令是从驱动写入数据<br/>
				&nbsp; _IOWR(type,nr,size) //双向数据传输<br/>
				如下从命令中提取 cmd、type、size、nr：<br/>
				&nbsp; _IOC_DIR(cmd) //从命令中提取方向<br/>
				&nbsp; _IOC_TYPE(cmd) //从命令中提取幻数<br/>
				&nbsp; _IOC_NR(cmd) //从命令中提取序数<br/>
				&nbsp; _IOC_SIZE(cmd) //从命令中提取数据大小<br/>
				&nbsp; SIOCGIFADDR：获取 PA 地址<br/>
				可变参数：1.整数，如改变偏移量；2.指针，必须先检验指针的安全性（检验方式：1.需要使用的时候再检验；2.一开始就检验）<br/>
				作用：设备在运行的时候可能要求数据的写入是连续的，如果这个时候仍然用WRITE函数去写指令的话，就有可能导致数据的不连续，比如声卡放音乐卡顿，电影播放不流畅等等的情况，为了解决这种情况，就有了IOCTL函数，此函数专门向驱动层发送或者接收指令。
				<form>
				<fieldset>
					<legend>** <b>获取 IP</b> **</legend>
					struct ifreq ifr;<br/>
					const char *eth_inf = "wan1";<br/>
					strncpy(ifr.ifr_name, eth_inf, IFNAMSIZ);<br/>
					ioctl(sockfd, SIOCGIFADDR, &ifr); //获取 IP 地址
					</fieldset>
				</form>
				<form>
				<fieldset>
					<legend>** <b>写入 文件 或 串口设备</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;sys/ioctl.h><br/>
					#include &lt;string.h><br/>
					#include &lt;fcntl.h><br/>
					#include &lt;unistd.h><br/>
					int main(){<br/>
						&nbsp; int fd;<br/>
						&nbsp; fd=open("./test.txt",O_RDWR | O_NOCTTY | O_NDELAY);//串口使用 /dev/ttyS0<br/>
						&nbsp; if(fd < 0)<br/>
						&nbsp; {<br/>
							&nbsp; &nbsp; printf("file error.\n");<br/>
							&nbsp; &nbsp; return 0;<br/>
						&nbsp; }<br/>
					/* R 值为 0x52，即 0101 0010，左移 8 bit<br/>
					0101 0010 0000 0000<br/>
					位与 1<br/>
					0101 0010 0000 0001<br/>
					位与（0x4004 左移 16 bit）<br/>
					0100 0000 0000 0100 0101 0010 0000 0001<br/>
					01（1） 是dir；后面 14bit（4） 是 size；之后 8bit（R） 是 type；最后 8bit（1） 是 nr*/<br/>
						&nbsp; ioctl(fd,(('R'<<8)|1|(0x4004<<16)),0);<br/>
						&nbsp; write(fd,"ATI\r\n",strlen("ATI\r\n"));<br/>
						&nbsp; close(fd);<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>pthread.h</h3>
			<ol>
			<li>int pthread_create(pthread_t *restrict tidp,const pthread_attr_t *restrict_attr,void*（*start_rtn)(void*),void *restrict arg)：创建线程。<br/>
				tidp：指向线程标识符的指针<br/>
				restrict_attr：设置线程属性<br/>
				void*（*start_rtn)(void*)：线程运行函数的起始地址<br/>
				arg：运行函数的参数，若不止一个参数，则需要将全部参数放入结构体中<br/>
				返回值：成功为 0，失败返回 -1 并设置 errorno 值<br/>
				注意：由于 pthread 非默认库，需要在末尾加上 -lpthread 以调用静态链接库，如 gcc -o aa ./main.c -lpthread
				<form>
				<fieldset>
					<legend>** <b>一般创建方式</b> **</legend>
					#include &lt;stdio.h><br/>
					#include &lt;pthread.h><br/>
					#include &lt;unistd.h><br/>
					void allsum(){<br/>
						&nbsp; int sum=0;<br/>
						&nbsp; for(int i=0;i<100;i++){<br/>
							&nbsp; &nbsp; sum+=i;<br/>
						&nbsp; }<br/>
						&nbsp; printf("sum=%d\n",sum);<br/>
					}<br/>
					int main(){<br/>
						&nbsp; int pthread_ok;<br/>
						&nbsp; pthread_t th;<br/>
						&nbsp; pthread_ok = pthread_create(&th,NULL,(void *)allsum,NULL);<br/>
						&nbsp; if(pthread_ok != 0)<br/>
							&nbsp; &nbsp; oprintf("pthread creat fail.\n");<br/>
						&nbsp; else<br/>
							&nbsp; &nbsp; printf("pthread creat success\n");<br/>
						&nbsp; sleep(1);//确保线程能完成操作<br/>
						&nbsp; //pthread_join(th,NULL);//不用 sleep 用这个也可以，这个是直到线程运行完成<br/>
						&nbsp; return 0;<br/>
					}
				</fieldset>
				</form>
				</li>
			<li>int pthread_mutex_destroy(pthread_mutex_t *mutex)：销毁互斥锁<br/>
				mutex：指向要销毁的互斥锁的指针<br/>
				成功返回 0，失败返回错误码</li>
			<li>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr)：初始化互斥锁<br/>
				mutex：指向要初始化的互斥锁的指针<br/>
				attr：指向属性对象的指针，为 NULL 则使用默认的属性<br/>
				成功返回 0，失败返回错误码</li>
			<li>int pthread_cond_destroy(pthread_cond_t *cond)：销毁条件变量<br/>
				cond：指向pthread_cond_t结构的指针<br/>
				返回值：函数成功返回0；否则错误</li>
			<li>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr)：初始化条件变量（动态创建）<br/>
				返回值：函数成功返回0；否则错误</li>
			<li>int pthread_mutex_lock(pthread_mutex_t *mutex)：互斥锁上锁<br/>
				mutex：互斥对象<br/>
				返回值：成功返回 0，失败返回非 0 值</li>
			<li>int pthread_mutex_unlock(pthread_mutex_t *mutex)：互斥锁解锁<br/>
				mutex：互斥对象<br/>
				返回值：成功返回 0，失败返回非 0 值</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>sys/socket.h</h3>
			<ol>
			<li>int socket(int af, int type, int protocol)：创建套接字。<br/>
				af：地址族（AF_INET；AF_INET6）<br/>
				type：数据传输方式或套接字类型（SOCK_STREAM：TCP连接；SOCK_DGRAM：UDP连接）<br/>
				protocol：传输协议（IPPROTO_TCP：TCP；IPPROTO_UDP：UDP，在头文件 netinet/in.h 里面），一般设置为 0<br/>
				返回值：成功返回套接字描述符，失败返回 -1</li>
			<li>int bind(int s,struct sockaddr *addr, int addrlen)：服务器绑定端口信息<br/>
				s：socket 描述符<br/>
				addr：<br/>
				addrlen：<br/>
				返回值：成功返回 0，失败返回 -1</li>
			<li>int listen(int s， int backlog)：服务器端监听连接<br/>
				s：socket 描述符<br/>
				返回值：成功返回 0，失败返回 -1</li>
			<li>int accept(int s, void *addr, int *addrlen)：服务器端连接请求<br/>
				s：socket 描述符<br/>
				addr：目标地址信息<br/>
				addrlen：目标地址长度<br/>
				返回值：成功返回已连接的 socket 描述符，失败返回 -1</li>
			<li>int connect(int s, struct sockaddr *addr,int addrlen)：建立连接<br/>
				s：socket 描述符<br/>
				addr：目标地址信息<br/>
				addrlen：目标地址长度<br/>
				返回值：成功返回 0，失败返回 -1</li>
			<li>int sendto (int s, const void *buf, int len, unsigned int flags, const struct sockaddr *to, int tolen)：UDP 发送数据<br/>s：socket 描述符<br/>buf：数据报缓存地址<br/>len：数据报长度<br/>flags：该参数一般为0<br/>to：struct sockaddr_in 类型，指明目标 ip 信息<br/>tolen：对方地址长度，一般为：sizeof(struct sockaddr_in)<br/>返回值：成功返回发送的字节数，失败返回 -1，错误原因在 errno 中</li>
			<li>int recvfrom(int s, void *buf, int len, unsigned int flags, struct sockaddr *from, int *fromlen)：UDP 接收数据<br/>
				s：socket 描述符<br/>
				buf：数据报缓存地址<br/>
				len：数据报长度<br/>
				flags：该参数一般为0<br/>
				<ul><li>MSG_DONTWAIT：操作不会被阻塞</li>
				<li>MSG_PEEK：指示数据接收后，在接收队列中保留原数据，不将其删除，随后的读操作还可以接收相同的数据</li>
				<li>MSG_TRUNC：返回封包的实际长度，即使它比所提供的缓冲区更长， 只对 packet 套接字有效</li>
				<li>MSG_WAITALL：要求阻塞操作，直到请求得到完整的满足</li>
				<li>MSG_EOR：指示记录的结束，返回的数据完成一个记录</li>
				<li>MSG_TRUNC：指明数据报尾部数据已被丢弃，因为它比所提供的缓冲区需要更多的空间</li>
				<li>MSG_CTRUNC：指明由于缓冲区空间不足，一些控制数据已被丢弃</li></ul>
				from：struct sockaddr_in 类型，指明目标 ip 信息<br/>
				fromlen：对方地址长度，一般为：sizeof(struct sockaddr_in)<br/>
				返回值：成功返回接收的字节数，失败返回 -1，错误原因在 errno 中</li>
			<li>int send(int s, const void *buf, int len, int flags)：TCP 发送数据<br/>
				s：socket 描述符<br/>
				buf：发送数据的缓冲区<br/>
				len：数据长度<br/>
				flags：该参数一般为 0
				<ul><li>MSG_NOSIGNAL：禁止send向系统发送消息（注意：linux下当连接断开但还发数据时，send函数会有反应并向系统发送一个异常消息，而不做处理系统会出BrokePipe导致程序退出）</li>
				</ul>
				返回值：成功返回发送的字节数，失败返回 -1，错误原因在 errno 中</li>
			<li>int recv(int s,void *buf,int len,unsigned int flags)：TCP 接收数据<br/>
				s：socket 描述符<br/>
				buf：接收数据的缓冲区<br/>
				len：数据长度<br/>
				flags：该参数一般为 0<br/>
				返回值：成功返回发送的字节数，失败返回 -1，错误原因在 errno 中</li>
			<li>int shutdown(int s,int howto)：禁止在一个套接口上进行数据的接收与发送。之后再使用 close 关闭套接字。<br/>
				s：socket 描述符<br/>
				howto：断开方式
				<ul><li>SHUT_RD：断开输入流。套接字无法接收数据（即使输入缓冲区收到数据也被抹去），无法调用输入相关函数</li>
				<li>SHUT_WR：断开输出流。套接字无法发送数据，但如果输出缓冲区中还有未传输的数据，则将传递到目标主机</li>
				<li>SHUT_RDWR：同时断开 I/O 流。相当于分两次调用 shutdown()，其中一次以 SHUT_RD 为参数，另一次以 SHUT_WR 为参数</li>
				</ul></li>
			<li>int getsockname(int s,struct sockaddr* localaddr,socklen_t *addrlen)：获取一个已捆绑或已连接的套接字的名字，即服务器端可通过它获取相关客户端地址，而客户端可通过它得到当前已连接成功的服务器地址<br/>
				s：socket 描述符，此为已捆绑或已连接的套接字<br/>
				localaddr：接收套接口的地址（名字）<br/>
				addrlen：地址缓冲区长度<br/>
				返回值：成功返回 0，失败返回 SOCKET_ERROR<br/>
				注意：TCP 连接不进行 bind 指定 ip 和端口时只有在调用 connect 连接成功后此函数才会正确获取当前正在通信的 IP 和端口；而 UDP 始终无法获取到正确 IP （为 0），端口正确。</li>
			<li>int getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)：获取一个套接口选项。<br/>
				s：套接字描述符<br/>
				level：协议层次
					<ul><li>SOL_SOCKET：套接字层</li>
					<li>IPPROTO_IP：ip层</li>
					<li>IPPROTO_TCP：tcp层</li></ul>
				optname：选项名称
					<ul><li>：（SOL_SOCKET）</li>
					<li>SO_ACCEPTCONN：套接字是否处于监听模式（SOL_SOCKET）</li>
					<li>SO_BROADCAST：是否允许发送广播信息（SOL_SOCKET）</li>
					<li>SO_CONNECT_TIME：返回套接字建立连接的时间，以秒为单位，如尚未连接，返回0xffffffff（SOL_SOCKET）</li>
					<li>SO_DEBUG：是否允许调试（SOL_SOCKET）</li>
					<li>SO_REUSEADDR：是否允许重复使用本地地址</li>
					<li>SO_DONTROUTE：不查找路由（SOL_SOCKET）</li>
					<li>SO_ERROR：获得套接字错误（SOL_SOCKET）</li>
					<li>SO_KEEPALIVE：保持连接（SOL_SOCKET）</li>
					<li>SO_LINGER：延迟关闭连接（SOL_SOCKET）</li>
					<li>SO_OOBINLINE：带外数据放入正常数据流（SOL_SOCKET）</li>
					<li>SO_RCVBUF：接收缓冲区大小（SOL_SOCKET），对于客户端，SO_RCVBUF选项必须在connect之前设置；对于服务器，SO_RCVBUF选项必须在listen前设置。</li>
					<li>SO_SNDBUF：发送缓冲区大小（SOL_SOCKET）</li>
					<li>SO_RCVLOWAT：接收缓冲区下限（SOL_SOCKET）</li>
					<li>SO_SNDLOWAT：发送缓冲区下限（SOL_SOCKET）</li>
					<li>SO_RCVTIMEO：接收超时（SOL_SOCKET）</li>
					<li>SO_SNDTIMEO：发送超时（SOL_SOCKET）</li>
					<li>SO_REUSERADDR：允许重用本地地址和端口（SOL_SOCKET）</li>
					<li>SO_TYPE：获得套接字类型（SOL_SOCKET）</li>
					<li>SO_BSDCOMPAT：与BSD系统兼容（SOL_SOCKET）</li>
					<li>IP_HDRINCL：在数据包中包含IP首部（IPPROTO_IP）</li>
					<li>IP_OPTINOS：IP首部选项（IPPROTO_IP）</li>
					<li>IP_TOS：服务类型（IPPROTO_IP）</li>
					<li>IP_TTL：生存时间（IPPROTO_IP）</li>
					<li>TCP_MAXSEG：TCP最大数据段的大小（IPPRO_TCP）</li>
					<li>TCP_NODELAY：不使用Nagle算法（IPPRO_TCP）</li>
					<li>TCP_INFO：查看当前 TCP 信息（IPPRO_TCP）</li></ul>
				optval：选项值，optname 获取的返回值<br/>
				optlen：选项值长度<br/>
				返回值：成功为 0，失败为 -1<br/>
				当 level 为 IPPROTO_TCP，optname 为 TCP_INFO，时，optval 的值可获取当前 TCP 连接状态，如 ooptval 值为 tcp_info sock_info 时，sock_info.tcpi_state 获取的就是状态，可为 TCP_ESTABLISHED（已建立连接）<br/>
				SO_RCVTIMEO/SO_SNDTIMEO 会导致 read/write 函数返回 EAGAIN（即 errno == EAGAIN）</li>
			
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>arpa/inet.h</h3>
			<ol>
			<li>in_addr_t inet_addr(const char *cp)：将一个点分十进制格式 ip 转换成一个长整数值（网络字节格式）<br/>
				cp：点分十进制 ip地址<br/>
				返回值：成功返回转换后的二进制网络字节序，失败返回 INADDR_NONE<br/>
				如 inet_addr("192.168.2.80")，若返回的是 INADDR_NONE（255.255.255.255）则表示网络广播地址</li>
			<li>char *inet_ntoa(struct in_addr in)：将整数转换成点分十进制格式表示的 ip 地址字符串<br/>
				in：长整数二进制网络字节序<br/>
				返回值：成功返回点分十进制字符串，失败返回 NULL</li>
			<li>int inet_pton(int family, const char *strptr, void *addrptr)：将点分十进制的 ip 地址转化为用于网络传输的数值格式<br/>
				family：AF_INET 或 AF_INET6<br/>
				strptr：点分十进制<br/>
				addrptr：ip 地址，数值格式<br/>
				返回值：若成功则为1，若输入不是有效的表达式则为0，若出错则为-1</li>
			<li>const char *inet_ntop(int family, const void *addrptr, char *strptr, size_t len)：将数值格式（二进制整数）转化为点分十进制的 ip 地址格式<br/>
				family：AF_INET 或 AF_INET6<br/>
				addrptr：ip 地址，数值格式<br/>
				strptr：点分十进制<br/>
				len：strptr 的长度<br/>
				返回值：成功返回指向结构的指针，失败返回 NULL，如 "127.0.0.1"</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>sys/msg.h</h3>
			<ol>
			<li>int msgget(key_t, key, int msgflg)：创建新的或打开已存在的消息队列，其消息数量受系统限制。<br/>
				key：消息队列对象的关键字，与已有的消息队列对象的关键字进行比较判断是否已创建，即新的或已有的队列 id<br/>
				msgflg：消息队列访问权限<br/>
				&nbsp; IPC_CREAT：创建新的消息队列，若已存在则打开<br/>
				&nbsp; IPC_EXCL：与 IPC_CREAT 一起使用表示消息队列不存在则创建，若要创建的消息队列已存在则返回错误<br/>
				&nbsp; IPC_NOWAIT：读写消息队列要求无法满足时，不阻塞<br/>
				返回值：失败返回 -1，成功返回 key 命名的消息队列标识符<br/>
				失败的 error 值：EACCESS（拒绝进入）、EEXIST（队列已存在不能创建）、EIDRM（队列已标记为删除）、ENOENT（队列不存在）、ENOMEM（没有足够内存创建队列）、ENOSPC（超过最大队列限制）</li>
			<li>int msgrcv (int msqid, void *msgp, size_t msgsz,long msgtype, int flag)：从消息队列获取消息<br/>
				msqid：消息队列标识符，msgget 函数的返回值<br/>
				msgp：接收消息的缓存区<br/>
				msgsz：接收消息的大小<br/>
				msgtype：期望接收的消息类型<br/>
				&nbsp; 0：获取队列中的第一个消息（最早的消息）<br/>
				&nbsp; &gt;0：获取具有相同消息类型的第一个消息（类型为 msgtype 的第一个消息）<br/>
				&nbsp; &lt;0：获取类型小于等于 msgtype 的绝对值的第一个消息<br/>
				flag：控制当队列中没有相应类型的消息可接收时将发生的事件<br/>
				返回值：成功返回接收缓存区的字节数，失败返回 -1</li>
			<li>int msgsnd(int msqid, const void *msgp, size_t msgsz, int flag)：将消息添加到消息队列中<br/>
				msqid：消息队列标识符，msgget 函数的返回值<br/>
				msgp：接收消息的缓存区<br/>
				msgsz：接收消息的大小<br/>
				flag：控制当队列中没有相应类型的消息可接收时将发生的事件<br/>
				返回值：成功返回 0，失败返回 -1</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>termios.h</h3>
			<ol>
			<li>int tcgetattr(int fd, struct termios *termios_p)：获取终端参数（如虚拟终端、串口、显示器、键盘等）<br/>
				fd：文件描述符，如 open 返回的 fd 值。<br/>
				termios_p：获取的参数保存在此结构体中，结构体如下：<br/>
				struct termios<br/>
				{<br/>
					&nbsp; unsigned short c_iflag; /* 输入模式标志 */<br/>
					&nbsp; unsigned short c_oflag; /* 输出模式标志 */<br/>
					&nbsp; unsigned short c_cflag; /* 控制模式标志，包括波特率、校验位等*/<br/>
					&nbsp; unsigned short c_lflag; /* 本地模式标志 */<br/>
					&nbsp; unsigned char c_line; /* 线路规程 */<br/>
					&nbsp; unsigned char c_cc[NCC]; /* 控制特性 */<br/>
					&nbsp; speed_t c_ispeed; /* 输入速度 */<br/>
					&nbsp; speed_t c_ospeed; /* 输出速度 */<br/>
				};<br/>
				其中 c_iflag 输入模式标志，控制终端输入模式，值如下：<br/>
				&nbsp; IGNBRK：忽略 BREAK 键输入<br/>
				&nbsp; BRKINT：如果设置了 IGNBRK，BREAK 键输入将被忽略<br/>
				&nbsp; IGNPAR：忽略奇偶校验错误<br/>
				&nbsp; PARMRK：标识奇偶校验错误<br/>
				&nbsp; INPCK：奇偶校验使能<br/>
				&nbsp; ISTRIP：去除字符的第 8 个比特<br/>
				&nbsp; INLCR：将输入的 NL（换行）转换成 CR（回车）<br/>
				&nbsp; IGNCR：忽略输入的回车<br/>
				&nbsp; ICRNL：将输入的回车转化成换行（如果 IGNCR 未设置的情况下）<br/>
				&nbsp; IUCLC：将输入的大写字符转换成小写字符（非 POSIX）<br/>
				&nbsp; IXON：允许输出时对 XON/XOFF 流进行控制<br/>
				&nbsp; IXANY：输入任何字符将重启停止的输出<br/>
				&nbsp; IXOFF：允许输入时对 XON/XOFF 流进行控制<br/>
				&nbsp; IMAXBEL：当输入队列满的时候开始响铃<br/>
				c_oflag 输出模式标志，控制终端输出模式，值如下：<br/>
				&nbsp; OPOST：处理后输出<br/>
				&nbsp; OLCUC：将输入的小写字符转换成大写字符（非 POSIX）<br/>
				&nbsp; ONLCR：将输入的 LF（换行）转换成 CR（回车）<br/>
				&nbsp; OCRNL：将输入的 CR（回车）转换成 LF（换行）<br/>
				&nbsp; ONOCR：第一行不输出回车符<br/>
				&nbsp; ONLRET：不输出回车符<br/>
				&nbsp; OFILL：发送填充字符以延迟终端输出<br/>
				&nbsp; OFDEL：以 ASCII 码的 DEL 作为填充字符，如果未设置该参数，填充字符为 NUL<br/>
				&nbsp; NLDLY：换行输出延时，可以取 NL0（不延迟）或 NL1（延迟0.1s）<br/>
				&nbsp; CRDLY：回车延迟，取值范围为：CR0、CR1、CR2和 CR3<br/>
				&nbsp; TABDLY：水平制表符输出延迟，取值范围为：TAB0、TAB1、TAB2 和 TAB3<br/>
				&nbsp; BSDLY：空格输出延迟，可以取 BS0 或 BS1<br/>
				&nbsp; VTDLY：垂直制表符输出延迟，可以取 VT0 或 VT1<br/>
				&nbsp; FFDLY：换页延迟，可以取 FF0 或 FF1<br/>
				c_cflag：控制模式标志，指定终端硬件控制信息，值如下：<br/>
				&nbsp; CBAUD：波特率（4+1位）（非 POSIX），如 B9600 是 9600 波特率；B115200 是 115200波特率<br/>
					&nbsp; &nbsp; cfsetospeed(&newtios,B9600);cfsetispeed(&newtios,B9600);//设置波特率<br/>
				&nbsp; CBAUDEX：附加波特率（1位）（非 POSIX）<br/>
				&nbsp; CSIZE：字符长度，如 CS5 是 5 个数据位；CS8 是 8 个数据位，如：<br/>
					&nbsp; &nbsp; tios.c_cflag &= ~CSIZE;tios.c_cflag |= CS8;// 8 位数据位，8 改成 7 就是 7bit<br/>
				&nbsp; CSTOPB：设置 2 个停止位，不设则是 1 个停止位，如：<br/>
					&nbsp; &nbsp; tios.c_cflag &= ~CSTOPB;// 1bit 停止位<br/>
					&nbsp; &nbsp; tios.c_cflag |= CSTOPB;// 2bit 停止位<br/>
				&nbsp; CREAD：接收使能<br/>
				&nbsp; PARENB：奇偶校验使能，如：<br/>
					&nbsp; &nbsp; tios.c_iflag |= IGNPAR;tios.c_cflag &= ~PARENB;//NONE，忽略奇偶校验错误<br/>
					&nbsp; &nbsp; tios.c_iflag |= IGNPAR;tios.c_cflag |= PARENB;tios.c_cflag |= PARODD;//ODD<br/>
					&nbsp; &nbsp; tios.c_iflag |= IGNPAR;tios.c_cflag |= PARENB;tios.c_cflag &= ~PARODD;//EVEN<br/>
					&nbsp; &nbsp; 或<br/>
					&nbsp; &nbsp; tios.c_cflag &= ~PARENB;tios.c_cflag &= ~INPCK;//NONE，奇偶校验不使能<br/>
					&nbsp; &nbsp; tios.c_cflag |= (PARENB | PARODD);tios.c_cflag |= INPCK;//ODD。奇偶校验使能<br/>
					&nbsp; &nbsp; tios.c_cflag |= PARENB;tios.c_cflag &= ~PARODD;tios.c_cflag |= INPCK;//EVEN<br/>
				&nbsp; PARODD：对输入使用奇偶校验，对输出使用偶校验<br/>
				&nbsp; HUPCL：关闭设备时挂起<br/>
				&nbsp; CLOCAL：忽略调制解调器线路状态，本地连接<br/>
				&nbsp; CRTSCTS：使用 RTS/CTS 流控制，硬件流控<br/>
				c_lflag：本地模式标志，控制终端编辑功能，值如下：<br/>
				&nbsp; ISIG：当输入INTR、QUIT、SUSP或DSUSP时，产生相应的信号<br/>
				&nbsp; ICANON：使用标准输入模式<br/>
				&nbsp; XCASE：在 ICANON 和 XCASE 同时设置的情况下，终端只使用大写。<br/>
				&nbsp; ECHO：显示输入字符<br/>
				&nbsp; ECHOE：如果 ICANON 同时设置，ERASE 将删除输入的字符<br/>
				&nbsp; ECHOK：如果 ICANON 同时设置，KILL 将删除当前行<br/>
				&nbsp; ECHONL：如果 ICANON 同时设置，即使 ECHO 没有设置依然显示换行符<br/>
				&nbsp; ECHOPRT：如果 ECHO 和 ICANON 同时设置，将删除打印出的字符（非 POSIX）<br/>
				&nbsp; TOSTOP：向后台输出发送 SIGTTOU 信号<br/>
				c_cc[NCCS]：控制字符，用于保存终端驱动程序中的特殊字符，如输入结束符等。值如下：<br/>
				&nbsp; VINTR：Interrupt 字符，中断控制字符（ctrl+c）<br/>
				&nbsp; VEOL：附加的 End-of-file 字符，附加行结束符（CR）<br/>
				&nbsp; VQUIT：Quit 字符，退出操作符（ctrl+z）<br/>
				&nbsp; VTIME：非规范模式读取时的超时时间，单位百毫秒，不能超过 cc_t<br/>
				&nbsp; VERASE：Erase 字符，删除操作符（Backspace 键）<br/>
				&nbsp; VSTOP：Stop 字符<br/>
				&nbsp; VKILL：Kill 字符，删除行符<br/>
				&nbsp; VSTART：Start 字符<br/>
				&nbsp; VEOF：End-of-file 字符，文件结尾符<br/>
				&nbsp; VSUSP：Suspend 字符<br/>
				&nbsp; VMIN：非规范模式读取时的最小字符数<br/>
				返回值：成功返回 0，失败返回非 0 并设置 errno 错误标识<br/>
				VTIME 和 VMIN 属性设置的作用：映像 read 函数的返回<br/>
				&nbsp; 1.VTIME 是等待时间，VMIN 是等待的最小字节数，可以为 0<br/>
				&nbsp; 2.VTIME 为 0，VMIN 定义等待读取最小字节数时，read 只有在读取了 VMIN 个字节数或收到一个信号时才返回<br/>
				&nbsp; 3.VMIN 为 0，VTIME 定义即使没有数据也可读取，read 返回前要等待 VTIME 时间，这时 read 不需要遇到文件结束标志才返回 0<br/>
				&nbsp; 4.若 VMIN 和 VTIME 都是 0，则计时读不到数据，read 也会立即返回，同时，返回值为 0 表示 read 函数不需要等待文件结束标志就返回了<br/>
				&nbsp; 5.若 VMIN 和 VTIME 都非 0，VTIME 定义接收到第一个字节数据后开始计算等待时间，若调用 read 可得到数据则马上开始计时，若调用 read 后还没数据则等接收第一个字节后计时。read 可能会在读取到 VMIN 个字节后返回，也可能在计时完毕后返回。</li>
			<li>void cfmakeraw (struct termios *termios-p)：将中断设置为原始模式，该模式下所有的输入数据以字节为单位被处理<br/>
				termios-p：可以先用 tcgetattr 获取参数，然后使用 tcgetattr 里面的 termios-p</li>
			<li>int cfsetospeed(struct termios *termptr, speed_t speed)：配合 cfsetispeed 函数实现设置波特率<br/>
				termptr：指向 termios 结构的指针<br/>
				speed：输出的波特率<br/>
				返回值：成功返回 0，失败返回 -1<br/>
				如：cfsetospeed(&tios,B115200);cfsetispeed(&tios,B115200);</li>
			<li>int cfsetispeed(struct termios *termptr, speed_t speed)：配合 cfsetospeed 函数实现设置波特率<br/>
				termptr：指向 termios 结构的指针<br/>
				speed：输入的波特率<br/>
				返回值：成功返回 0，失败返回 -1</li>
			<li>speed_t cfgetispeed(const struct termios *termios_p)：配合 cfgetospeed 实现获取波特率<br/>
				termios_p：指向 termios 的结构体指针<br/>
				返回值：成功返回输入波特率，失败返回 -1</li>
			<li>speed_t cfgetospeed(const struct termios *termios_p)：配合 cfgetispeed 实现获取波特率<br/>
				termios_p：指向 termios 的结构体指针<br/>
				返回值：成功返回输出波特率，失败返回 -1</li>
			<li>int tcflush(int fd, int queue_selector)：清空串口 buffer 中的数据<br/>
				fd：文件描述符<br/>
				queue_selector：对缓存区的操作，值如下<br/>
				&nbsp; TCIFLUSH：清除/刷新正收到的数据，且不会读取出来<br/>
				&nbsp; TCOFLUSH：清除/刷新正写入的数据，且不会发送至终端<br/>
				&nbsp; TCIOFLUSH：清除/刷新所有正在发生的 I/O 数据，即将输出缓冲区和输入缓存区清空<br/>
				返回值：成功返回 0，失败返回 -1 并设置 errno 错误</li>
			<li>int tcsetattr(int fd, int optional_actions, const struct termios *termios_p)：设置终端参数<br/>
				fd：文件描述符<br/>
				optional_actions：参数生效时间<br/>
				&nbsp; TCSANOW：不等数据传输完毕就立即改变属性<br/>
				&nbsp; TCSADRAIN：等待所有数据传输结束才改变属性<br/>
				&nbsp; TCSAFLUSH：等待所有数据传输结束，清空输入输出缓冲区才改变属性<br/>
				termios_p：指向 termios 的结构体指针<br/>
				返回值：成功返回 0，失败返回 -1 并设置 errno 错误</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>netdb.h</h3>
			<ol>
			<li>struct hostent *gethostbyname(const char *name)：用域名或主机名获取 ip 地址<br/>
				name：指向主机名，如 "www.baidu.com"<br/>
				返回值：window 下返回对应于给定主机名的主机信息；linux 下成功返回非空，失败返回空并设置 errno<br/>
				window 下的头文件是 winsock2.h<br/>
				struct hostent<br/>
				{<br/>
					&nbsp; char *h_name; //主机的规范名<br/>
					&nbsp; char ** h_aliases; //主机的别名<br/>
					&nbsp; short h_addrtype; //主机 ip 地址类型，ipv4（AF_INET）或 ipv6（AF_INET6）<br/>
					&nbsp; short h_length; //主机 ip 地址长度<br/>
					&nbsp; char ** h_addr_list;//主机 ip 地址，以网络字节序存储，打印 ip 时需调用 inet_ntop()<br/>
				};<br/>
				可用于判断是否为域名：if( (hptr = gethostbyname("www.baidu.com") ) == NULL )//不是域名</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>netinet/in.h</h3>
			<ol>
			<li>IPPROTO_UDP：udp 协议</li>
			<li>sockaddr_in：<br/>
			struct  sockaddr_in {<br/>
				&nbsp; short int sin_family; /* Address family */<br/>
				&nbsp; unsigned short int sin_port; /* Port number */<br/>
				&nbsp; struct in_addr sin_addr; /* Internet address */<br/>
				&nbsp; unsigned char sin_zero[8]; /*to make same size as struct sockaddr */<br/>
			};</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>cstddef.h</h3>
			<ol>
			<li>size_t：unsigned 类型，为了适应多个平台，增强可移植性。32 位是 unsigned，64 位是 long unsigned int</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>sys/types.h</h3>
			<ol>
			<li>ssize_t：signed 类型，表示可以被执行读写操作的数据块大小，表示的是 signed size_t 类型</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>sys/time.h</h3>
			<ol>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li>struct timeval<br/>
				{<br/>
					time_t      tv_sec;     /* seconds */<br/>
					suseconds_t tv_usec;    /* microseconds */<br/>
				};</li>
			<ol>
			</div><hr/>
		<div>
			<h3>.h</h3>
			<ol>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>.h</h3>
			<ol>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>.h</h3>
			<ol>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
		<div>
			<h3>编译器支持</h3>
			<ol>
			<li>__FILE__：当前程序文件名，包括路径</li>
			<li>__LINE__：当前文件下的代码行号</li>
			<li>__FUNCTION__：当前函数</li>
			<li>__TIME__：当前编译时间</li>
			<li>__DATE__：当前编译日期</li>
			<li>__STDC__：编译器是否遵循 ANSI C 标准，是为非 0 值</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<ol>
			</div><hr/>
	</div>
</body>
</html>